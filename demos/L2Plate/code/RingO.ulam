quark RingOState {
  Bool(1) mUpState;
  Bool(1) mDownState;
  Bool operator==(RingOState & other) {
    return mUpState == other.mUpState && mDownState == other.mDownState;
  }
  Bool operator!=(RingOState & other) {
    return mUpState != other.mUpState || mDownState != other.mDownState;
  }
  typedef Unsigned(2) StateIndex;
  constant StateIndex cRED_STATE = 2u;
  constant StateIndex cYLW_STATE = 3u;
  constant StateIndex cGRN_STATE = 1u;
  constant StateIndex cBLU_STATE = 0u;
  StateIndex getStateIndex() {
    return (StateIndex) ((mUpState?2u:0u) | (mDownState?1u:0u));
  }
  ARGB color() {
    Bits(32) col = 0u;
    if (mUpState)   col |= 0x00ff0000; // add red
    if (mDownState) col |= 0x0000ff00; // add green
    if (col == 0u)  col =  0x000000ff; // blue if neither
    col |= 0xff000000;                 // add alpha
    ColorUtils cu;
    return cu.color(col);
  }
}

/**
   Sync using a General Distributed Ring Oscillator, given upstream and downstream iterators
 */
quark RingO {
  typedef EventWindow.SiteNum SN;
  typedef BitStorageT(4096) BitStorage4K;

  RingOState mRingOState;

  typedef Unary(2) SyncRelation;
  constant SyncRelation cOTHER_IS_UNRELATED = 0;
  constant SyncRelation cOTHER_IS_UPSTREAM = 1;
  constant SyncRelation cOTHER_IS_DOWNSTREAM = 2;

  //// RingO API
  virtual SyncRelation syncRelation(RingO & other) ; //< How does other relate to self?

  /** return true to let root start next phase */
  virtual Bool rootTick(RingONeighborhood & ngb) { return true; }

  /** return true to let tail start next phase */
  virtual Bool tailTock(RingONeighborhood & ngb) { return true; }

  /** return true to let wire propagate change into self */
  virtual Bool edge(RingONeighborhood & ngb, Bool fromUp, Bool newState) { return true; }
  
  //// RingO SERVICES
  Bool updateRingO(RingOIterator & itr) {                    //< returns true if state changes made
    RingONeighborhood ngb;
    itr.init(self);
    while (itr.hasNext()) {
      RingO & n = itr.next();
      SyncRelation rel = self.syncRelation(n);
      ngb.countRingOState(n, rel);
    }
    
    return ngb.update(self);
  }

  ARGB getRingOColor() {  return mRingOState.color();  }

}







