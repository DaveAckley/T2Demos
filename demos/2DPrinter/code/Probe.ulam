/** Probe atom that floods the reproduction zone and checks for
    conflicts

    \symbol Pr
    \color #222
    \radius 2

    \author Dave Ackley
    \license lgpl
    \version 1
 */
element Probe : RotateContent {
  EventWindow ew;

  typedef UGridContent.S2D S2D;
  typedef S2D.Coord SCoord;

  typedef EventWindow.SiteNum SiteNum;
  typedef Unsigned(7) Channel7;
  typedef Channel7 Nonce[3];

  Nonce mNonce;
  S2D mLocation;
  S2D mBox;
  Bool mIsRoot;
  Bool mDone;

  typedef Unsigned(7) Age;
  Age mAge;

  ARGB getColor(Unsigned selector) {
    ColorUtils cu;
    return cu.color(mNonce[0],mNonce[1],mNonce[2]);
  }
  /*
  typedef Unary(1) FloodState;
  constant FloodState cFLOOD = 0u; // Spreading
  constant FloodState cREPORT = 1u; // Reporting success 
  FloodState mFloodState;
  */

  Self(CPlate & cp) {
    CStatePROBE & p = cp.asPROBE();
    mTag = cp.mTag;
    Random r;
    for (Int i = 0; i < mNonce.lengthof; ++i) {
      mNonce[i] = (Channel7) r.bits(mNonce[i].sizeof);
    }
    mRot = cp.mRot;
    mAge = 0u; // Last time I changed: Now
    mIsRoot = true;  // I'm the root
    mBox.setX(cp.mMax.getX()*2u); // Flood twice the needed width
    mBox.setY(cp.mMax.getY()); // And once the needed height
    mLocation.setX(mBox.getX()-1u); // Starting at the max x
    mLocation.setY(cp.mLocation.getY()-UGridContent.cORIGIN_Y); // Grr fix up origin
  }

  Self(Self & s, C2D reltos) {
    MDist md;
    mTag = s.mTag;
    mNonce = s.mNonce;
    mRot = s.mRot;
    mAge = 0u; // Last time I changed: Now
    mIsRoot = false; // I'm a copy
    mBox = s.mBox;
    mLocation.set(s.mLocation.toC2D() + reltos);
  }

  // XXXX NEEDS MERGED WITH CPLATE ANALOGS
  Void miscarry() {
    mLocation.set(SCoord.maxof,SCoord.minof);
  }

  // XXXX NEEDS MERGED WITH CPLATE ANALOGS
  Bool isMiscarriage() {
    S2D abortCode;
    abortCode.set(SCoord.maxof,SCoord.minof);
    return mLocation.equals(abortCode);
  }

  Bool isReallyMe(Atom & a) {
    if (a as Self) {
      for (Int i = 0; i < mNonce.lengthof; ++i) {
        if (a.mNonce[i] != mNonce[i]) return false;
      }
      return true;
    }
    return false;
  }

  // XXXX NEEDS MERGED WITH CPLATE ANALOGS
  Bool terminated() {
    if (!isMiscarriage()) return false;

    EventWindow ew;
    for (SiteNum i = 1; i < 41; ++i) {
      if (!ew.isAccessible(i)) continue;
      Atom a = ew[i];
      if (!isPartOfMe(a)) continue; // Tag match
      if (a as CPlate) a.miscarry();
      else if (a as SwapLine) a.miscarry();
      else if (a as Trailer) a.massDieOff();
      else if (isReallyMe(a)) {
        Self & s = (Self&) a;
        s.miscarry();
      }
      else continue;
      ew[i] = a;
    }
    ew[0] = Empty.instanceof;
    return true;
  }

  Bool isDone() {
    return mIsRoot && mAge == mAge.maxof;
  }

  Void behave() {
    MDist md;
    super.behave();
    if (terminated()) return;
    if (isDead()) return;
    SiteNum start = md.getFirstIndex(1u);
    SiteNum stop = md.getLastIndex((Unsigned(3)) ew.getRadius());
    if (mDone) {
      for (SiteNum sn = start; sn <= stop; ++sn) {
        Atom & a = ew[sn];
        if (a as Self) {
          if (a.getMyTag() == getMyTag())
            a.mDone = true;
        }
      }
      ew[0] = Empty.instanceof;
      return;
    }
    if (mAge == mAge.maxof) {
      if (mIsRoot) {            // If I'm the root
        Atom & a = ew[4];       // Look for headcommander
        if (a as CPlate) {
          if (a.isHeadCommander() &&
              a.mPlateState == CPlate.cPLATESTATE_PROBE) {
            CStatePROBE & probe = a.asPROBE();
            if (probe.mProbeState == CStatePROBE.cPROBE_WAIT) {
              probe.mProbeState = CStatePROBE.cPROBE_DONE;
              mDone = true;
            }
          }
        }
      }
      return;
    }

    C2D usc = mLocation.toC2D();
    C2D max = mBox.toC2D();
    Unsigned minage = minage.maxof;
    for (SiteNum sn = start; sn <= stop; ++sn) {
      C2D rel = md.getSiteCoord(sn);
      C2D abs = usc + rel;
      if (abs.getX() < 0 || abs.getY() < 0 ||
          abs.getX() >= max.getX() ||
          abs.getY() >= max.getY())
        continue; // Out of box
      Atom & a = ew[sn];
      Bool handled = false;
      if (a as Self) {
        if (a.getMyTag() == getMyTag()) {
          if (a.mAge < minage) minage = a.mAge;
          handled = true;
        }
      } else if (a is Empty && ew.isLive(sn)) {
        Self new(self, rel); // Start with us
        ew[sn] = new;
        minage = 0u; // We are reborn
        handled = true;
      }
      if (!handled) {
        // Not empty, not us, in box ->
        miscarry();
        return;
      }
    }
    if (minage != minage.maxof)
      mAge = (Age) (minage + 1u);
  }
}
