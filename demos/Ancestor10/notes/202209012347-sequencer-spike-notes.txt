{649}  -*-  mode: text; fill-column: 50;  -*-
[0:

Thu Sep  1 23:47:45 2022 OK so OK so OK come on.

Let's start some kind any kind some kind of spike
fantasy progress on HC3 sequencering before
September 1 is done.

[1:

Thu Sep  1 23:48:52 2022 First question in my
mind:

 - Where does the 'main' sequencer go, relative to
   the root of the mother diamond?

   = Wanted it near the root, so root control
     would be eased.

   = But don't want it to BE the root, so
     generality down the road is increased

   = But if we're going to use quadrant
     navigation, we cannot distinguish specific 2D
     offsets from the root. We only quadrant and
     distance from the root - like super coarse
     polar coordinates. So how could we
     grow/gather multiple pocketchains around a
     non-root HC3?

[2:

Thu Sep  1 23:54:39 2022 Note that we'd intended
to get ShapeShifter handling shrink, somehow,
before moving on.. but here we are. My feeling now
is we need an actual pull, an actual spike of some
kind, from the HC3 sequence side, and if we jump
right back into slogging through ShapeShifter we
won't get that.

:2]

:1]

:0]
[3:

Thu Sep  1 23:56:35 2022 What if we imagine an HC3
sequencer immediately adjacent to the root? Put
aside the growth/navigational issues for the
moment.
[4:

Thu Sep  1 23:59:16 2022 Give me a spike layout
here:

      H3    H3   H3   H3

      H3    H3   H3   H3
        C3    C2    B4  B3
 H3   H3    H3   H3   H3   H3
        C4    C1    B1  B2
 H3   H3    H3   Sq   H3   H3
         D2   D1    A1  A2
 H3   H3    H3   R0   H3   H3
         D3   D4    A4  A3
 H3   H3    H3   H3   H3   H3

      H3    H3   H3   H3

[5:

Fri Sep  2 00:03:41 2022 Something like that say:

 R0 - root
 Sq - HC3 Sequencer
 [A-D]1 - PocketChain 'anchor'
 [A-D][2-4] - PocketChain chains

Suppressing the grid:

      ..    ..   ..   ..

      ..    ..   ..   ..
        C3    C2    B4  B3
 ..   ..    ..   ..   ..   ..
        C4    C1    B1  B2
 ..   ..    ..   Sq   ..   ..
         D2   D1    A1  A2
 ..   ..    ..   R0   ..   ..
         D3   D4    A4  A3
 ..   ..    ..   ..   ..   ..

      ..    ..   ..   ..


How could we make such a thing? Well, suppose we
tried to make this:

      ..    ..   ..   ..

      ..    ..   ..   ..

 ..   ..    ..   ..   ..   ..
        C2    C1    B1  B2
 ..   ..    ..   Sq   ..   ..
         D2   D1    A1  A2
 ..   ..    ..   R0   ..   ..

 ..   ..    ..   ..   ..   ..

      ..    ..   ..   ..

[9:

Fri Sep  2 01:57:07 2022 So say we're talking a
'SeedSeq' to get started. It will configure and
place four SeedChains - at (1,1), (1,-1), (-1,-1)
and (-1,1) - and place an Hg root at (0,3).

Actually I guess it's phased:

 - Place Hg at (0,3)
 - Wait a bit
 - Place 4 x SeedChain
 - Wait a bit more
 - Decay into a Sq

and SeedChain pops like a SeedLoop, except without
diffusing first and with a preprogrammed direction
for downstream.

Maybe SeedChain fails in some detectable way if it
can't get the second target spot? Well it all has
to wait.

What about a somewhat generic PocketMaker atom?
It'd be nice to stop proliferating zillions of
SeedX types - especially SeedXs that mostly just
deposit SeedYs. And also a generic PocketMaker
would be a natural for use in future pocketcode.

What's our PocketChain bit budget at the moment,
also?

[10:

Fri Sep  2 02:05:28 2022 It's pretty damn open:

  /*__________________________________________________
  | COMPONENTS of PocketChain <6> (24 bits/40 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 4	| mSegsDown	| Unsigned(4)
  | 4	| 4	| mTempsDown	| Unsigned(4)
  | 8	| 4	| mSegsUp	| Unsigned(4)
  | 12	| 4	| mTempsUp	| Unsigned(4)
  | 16	| 2	| mDSType	| Unsigned(2)
  | 18	| 6	| super	| Segment <53>
  | 24	| 0	| base	| UrSelf <0>
  | 24	| 0	| base	| DiamondTypes <55>
  | 24	| 0	| base	| Intender <51>
  | 24	| 0	| base	| NonDebugUtils <79>
  | 24	| 0	| base	| Pocketable <86>
  |___________________________________________________

and it's not clear how many of the *Down and *Up
fields are actually in use.

PocketMaker
 mElementType
 mPocketAddress

quark PocketAddress {
 typedef Unsigned(2) AddressDomain;
 constant AddressDomain cADOM_VOID = 0u; //< (?) Discard on W, random on R
 constant AddressDomain cADOM_SELF = 1u; //< ew[0]
 constant AddressDomain cADOM_HERE = 2u; //< addressed site in my pocket
 constant AddressDomain cADOM_SIDE = 2u; //< any site in addressed side pocket
 AddressDomain mAddressDomain;

 typedef Unsigned(2) AddressValue;
 /** Address Domain specific value
     cADOM_VOID  random.between(0u,mAddressValue)
     cADOM_SELF  ?
     cADOM_HERE  ?
     cADOM_SIDE  0-3: WNSE
 */
 AddressValue mAddressValue;

}
[11:

Fri Sep  2 03:45:40 2022 Can't get too bogged down
here but maybe instead:

quark PocketAddress {
 Bool(1) mIsImmediate;
 PocketPtr mAddress; // 0..7 as existing
}

or just PocketPtr, come on. We'll add immediate
when we need it.

So.

PocketMaker
 ClassId mElementType         // +16b
 PocketPtr mDestination       // +3b

What about arguments? Bit field writes?
Could we have an ulam-6 syntax for data member
sizes and positions? Or could ClassUtils do this
already?
[12:

Fri Sep  2 04:41:59 2022 Well, how does MFM
AtomViewPanel find the data members, to print?
[13:

Fri Sep  2 04:46:46 2022 Well, eventually it all
winds down to UlamClass<EC>::PrintClassMembers(..)

and UlamClass provides things like

 - GetDataMemberCount()
 - GetDataMemberInfo(u32)
 - struct UlamClassDataMemberInfo

and so on.

But ClassUtils.ulam never mentions the word 'data'
or 'member'..

:13]

:12]


:11]

:10]

:9]

[6:

Fri Sep  2 00:11:37 2022 What's the root bit
budget look like at this point, again?

      /*__________________________________________________
      | COMPONENTS of HardCellG <78> (63 bits/8 unused):
      |
      | Pos	| Bits	| Name	| Type <classid>
      | 0	| 4	| mHardCellWatchdog	| XTimer(4,10u,250u) <61>
      | 4	| 4	| mRootWatchdog	| XTimer(4,10u,100u) <60>
      | 8	| 5	| mMaxHops	| Unsigned(5)
      | 13	| 5	| mUpHops	| Unsigned(5)
      | 18	| 5	| mSettledDownHops	| Unsigned(5)
      | 23	| 12	| mColor[3]	| Unsigned(4)
      | 35	| 10	| mDirs[2]	| Int(5)
      | 45	| 2	| mCmdPhase	| Unsigned(2)
      | 47	| 8	| super	| QHardCell <69>
      | 55	| 0	| base	| UrSelf <0>
      | 55	| 8	| base	| DEWLine <39>
      | 63	| 0	| base	| DiamondTypes <55>
      |___________________________________________________


We can squeeze that pretty quickly by

 - Dropping mColor for +12b -> 20b

 - Merging the dogs for +4b -> 24b
   = Perhaps use two trigger levels to encourage
     root to expires before field. Like go with
     XTimer(4,10u,250u) but have root manually
     trigger at 8 instead of 10

[7:

Fri Sep  2 00:21:10 2022 QHardCell's 8b are

  | 0	| 8	| mNgbRels[4]	| Unsigned(2)

and they help with side pocket iteration and we
really don't want to mess with that.

[8:

Fri Sep  2 00:27:55 2022 We'd want to

 - Ditch mDirs for +10b -> 34b

since we'll be using 'more sophisticated' means of
motion control, and that's probably where we end
up.

So 34b free for each Hg, including root (which,
after all, is only special due to mUpHops==0u.)

That's pretty good, really..

I guess we would like HardCellG to become a quark
too, can we do that?

:8]

:7]

:6]

:5]


:4]
((The MFM architecture itself could be
characterized as 'virtual hardware'.))

:3]
[14:

Fri Sep  2 09:01:45 2022 Restart.

    PocketMaker
     ClassId mElementType         // +16b
     PocketPtr mDestination       // +3b

means:
(1) Attempt to dereference mDestination
(2) Create a default mElementType there if successful

elaborations..

typedef Unsigned(3) Action
constant Action cTRY = 0u;
constant Action cBLOCK = 0u;
constant Action cDIE = 1u;
constant Action cDIFFUSE = 2u;
constant Action cNEXT = 3u;
constant Action cPREV = 4u;

    PocketMaker
     ClassId mElementType     // +16b -> 16
     PocketPtr mDestination   // +3b -> 19
     Action mState            // +3b -> 22
     Action mIfDone           // +3b -> 25
     Action mIfFail           // +3b -> 28

[15:

Fri Sep  2 09:17:00 2022 And yet once again, where
is the sequencer in this? Using (just) PocketPtr
for addressing is pushing towards the 'independent
processes' view, where everything happens relative
to ew[0] - and eventually we start modifying
fields of the 'instruction' in place.. and it's a
process.

[16:

Fri Sep  2 09:54:53 2022 The alternative we wanted
to explore would be more like

typedef Unsigned(2) Unit
constant Unit mSEQ_REG = 0u;
constant Unit mSEQ_INP = 1u;
constant Unit mSEQ_OUT = 2u;
constant Unit mSEQ_INS = 3u;

source : Unit
dest : Unit
type : ClassId
match : ==, <, sub
op :

[17:

Fri Sep  2 10:15:05 2022 Ooh or maybe ClassId is
just a special case of FIELD+VALUE hypersubspace
selection?

Hmm, 7b to select start bit
could do 6b and just say you can't target the last
bits. could have a special case for matching the
type? since we don't want to think partial matches
in the element type would be useful?

There's also classid which is not the element
type. Hmm maybe that's where we could allow
subclass relations, and have element type just be
exact match?

:17]

:16]

:15]
:14]
[18:

Fri Sep  2 11:15:19 2022 Go again:

Instruction
 typedef Unsigned(7) OpCode
 OpCode mOpCode                  +7 / 7
 Unit mSource1                   +2 / 9
 Unit mSource2                   +2 / 11
 Unit mDest                      +2 / 13
 typedef Bits(19) Condition
 Condition mEnable               +19 / 32

[19:

Fri Sep  2 15:16:04 2022 Maybe we could take
advantage of

  constant PocketPtr cPP_RSRV1 = 5u;  //< Don't use
  constant PocketPtr cPP_RSRV2 = 6u;  //< Don't use

to point at HC3Seq units? At least two of them?
Maybe like:

  constant PocketPtr cPP_REG = 5u;    //< Register/stack quadrant
  constant PocketPtr cPP_IO = 6u;     //< IN on R, OUT on W

and if you try to access REG or IO when you're not
in mSEQ_INS space, you just block.

[20:

Fri Sep  2 15:45:09 2022 Well obviously we've
gotten lost in the weeds again here. We can't let
that stop us for long.  How can we rein it in?

[21:

Sat Sep  3 00:18:21 2022 Just start a damn
spike. HC3Seq.ulam
[22:

Sat Sep  3 00:56:10 2022 OK, did:

 - Lifted guts of HardCellG into quark QHardCellG

 - Created quark QProcUnitMap to map from logical
   'ProcUnit' types (REG, INP, OUT, INS) to
   PocketDir quadrants

 - Made DiamondSequencer : QHardCellG which HAS-A
   QProcUnitMap

Building now.

(Noting that with the amount of ulam code this
'chain processor' implies, build times are going
to be absofoggenlutely unbelievable on the
keymaster..) [23:

Sat Sep  3 02:33:03 2022 OK, did:

 - Made quark QDebugUtils that allocates
      Bool mDebugOutputEnabled = false;
   to control debug output on a per-atom basis.

 - Made Intender, Intention, and QHardCell inherit
   from QDebugUtils.

   = Reduced colors from 12 bits to 9 bits to free
     up space

 - Made elements Do (Df) to enable (disable) one
   nearest QDebugUtils atom

 - Felt happy about this new ability.
[24:

Sat Sep  3 02:38:39 2022 So, can we move toward
SeedSeq to layout something like the end of :5:
above?


 ..   ..    ..   ..   ..   ..
        C2    C1 SS B1  B2
 ..   ..    ..   Sq   ..   ..
         D2   D1    A1  A2
 ..   ..    ..   R0   ..   ..

 ..   ..    ..   ..   ..   ..

SeedSeq
 (1) Seed HardCellG root at (0,4)
 (2) Wait until (0,1) is a HC3
 (3) Seed
      D1 SeedLoop(W) at (-1,0)
      C1 SeedLoop(W) at (-1,2)
      B1 SeedLoop(E) at (1,0)
      A1 SeedLoop(E) at (1,2)
 (4) Replace (0,1) with a Sq
 (5) Erase self

SeedLoop
 (1) Wait for availability in configured side pocket
 (2) Set up primal loop in self and side pocket

[25:

Sat Sep  3 02:55:55 2022 Not that far down the
road we'd like to replace a lot of these Seed*
elements with PocketMakers!

That is, when they're used programmatically, like
the SeedLoops from the SeedSeq..  We'll just get
default values trying to place a PocketMaker
manually.

:25]

:24]
:23]

:22]
:21]

:20]

:19]

:18]
[26:

Sun Sep  4 02:53:01 2022 OK so we're making some
progress here; got four loops trying to grow.. but
the layout in :24: is kind of messed up for
purposes of loop growing, because the loops aren't
centered on the root.

[27:

Sun Sep  4 06:45:41 2022 Got it working by fixing
a couple bugs and relaxing the quadrant
restrictions a little bit. Starting a movie stress
test before nap.[28:

Sun Sep  4 06:57:48 2022 Started up 10 Hg in one
grid. Nine booted the loops okay but one lost its
NE loop. Examining the captured frames it's clear
that what happened is that loop got popped too
early, before the diamond was fully-enough
established, and the outer part of the loop stuck
out too far beyond the diamond edge, and punched
out:

    20220904065144-3326: 279AEPS [83FE9F07]MSG: print: "DYING"
    20220904065144-3327: 279AEPS [83FE9F07]MSG: print: "PocketChain: Too open pocket"
    20220904065144-3328: 279AEPS [83FE9F07]MSG: (Sf) ShapeShifter
     :9F81FFA00000022400000000

So that's useful info. We should have SeedLoop11
check the Hg settledDownCount or something before
popping. And we wonder how on earth a 'general'
PocketInstruction could be programmed to make such
a check without having it totally hard-wired..

A super-hack natural-life evolvo-inspired approach
would be like just read a bitfield that happens to
be the high-order bits of mSettleDownCount, and
just test them for non-zero..

Could have two instructions for deployment; first
one makes the checks:

IF PROC@36:3 != 0 -> NEXT

where PROC means the DiamondSequencer atom itself,
then like a bitfield and a condition..

[29:

Sun Sep  4 07:25:58 2022 But then the next
instruction will have to be swapped in to execute,
so it won't execute atomically wrt the IF
test. Guess that's just the price of admission to
sequential coding?

[30:

Sun Sep  4 07:31:27 2022 Um, if it's just a
two-instruction loop, conceivably the swap could
be done and then a new self drawn from ew[0] and
the second instruction actually could run
atomically with the first ??

Even if it wasn't a two-instruction loop, if the
upstream was already a temp and the downstream was
already in place.. Running multiple pretty clearly
distinct transitions in a a single event window??

It could be done, right?

It would pretty badly fuck up the MFM mobile
instruction cache ideas I've been kicking around
in the back of my head.. Really would need to
whole codebase available everywhere.

But that's kind of already true isn't it, what
with all the base class methods and so
forth. Per-element caches would have to have
pretty tremendous code duplication, so much so it
wouldn't really be 'per element' in any
significant way.

:30]
:29]

:28]

:27]

:26]
[31:

Mon Sep  5 16:49:38 2022

 - Byte code (or bit code) with multiple
   instructions per PocketChain atom

 - explicitly do things like block for completion

 - trigger things

 - seq has component mapping plus posted
   operations

 - 'tail call' continues event if next atom
   successfully moves into ew[0].

[32:

Tue Sep  6 00:43:30 2022 So, as an example,
element Demo currently has 43 unused bits. We
could stuff four 10 bit instructions in there, and
a 2 bit intra-atom program counter, and still have
a bit left over.

We could get a lot of mileage out of a 10 bit
instruction.

00 + 8 bits : push immediate
01 + 8 bits
10 + 8 bits

11 +

[33:

Tue Sep  6 01:35:36 2022 Well if we imagine a
single event VM, we could go smaller, like 8 or
even 6 bits/op, allowing five or six uinstructions
in an atom.

The idea there, I guess, would be to compose ..

Well maybe these uops could help us explore future
FPGA/ASIC-ish event window operations. Like
consider:

Category: EW ops

Void <- MAPCLASS tagnum, classid
Void <- MAPBASE tagnum, baseclassid
 SN  <- REDUCE tagmask, combiner

[34:

Tue Sep  6 01:48:22 2022 Around and aground,
aground all around.

 - So so much new design implied by uops

 - Gut says six or even ten uops would still be
   very confining very quickly

 - Pushing me back towards the VLIW-style
   atom-wide 'single instruction processes'

   = Hope for less new design because reuse
     (significant chunks of) existing ulam code

   = Be able to tailor back and forth along the
     true programming / mere configuration axis as
     time and energy and success suggest

[35:

Tue Sep  6 02:08:44 2022 If we wanted to move
forward on atom-wide 'complex' instructions

ACISC - Atomic Complex Instruction Set Computing
SIAS - Single Atom Instruction Set
SIPAC - Single Instruction Per Atom Computing
APSC - Atomic Process Sequencing Computing
EPS - Elemental Process Sequencing


:35]

:34]

:33]

:32]

:31]
[36:

Tue Sep  6 03:13:53 2022 So, head fake, head fake,
dodge, and come in from below.

 - Stop trying to think of specific instructions
   or instruction formats

 - Think of infrastructure to execute instructions
   regardless of detailed format or function

(1) How to get 'next instruction' into position

(2) What 'in position' means

(Re)state assumptions

DiamondSequencer HAS-A
 ComponentToQuadrantMap mComponentToQuadrantMap; //< +8b

 typedef Unsigned(2) PendingOperation;
 constant PendingOperation cDONE = 0u; //< No operation in progress
 constant PendingOperation cFRWD = 1u; //< Roll forward, bringing next upstream here
 constant PendingOperation cBACK = 2u; //< Roll backward, bringing next downstream here
 constant PendingOperation cFREE = 2u; //< Bring an empty slot here
 typedef PendingOperation QuadrantToPendingOperation[4];

 QuadrantToPendingOperation mQuadrantToPendingOperation; // +8b

[37:

Tue Sep  6 03:45:28 2022 When any 'Sequenceable'
element takes an event, it
(1) Inits and finds a DiamondSequencer, or pdiffuses
(2) Consults ds.mComponentToQuadrantMap to find
    its current component identity
(3) Checks mQuadrantToPendingOperation to find its
    current chain operation if any
(4) If operation is non-zero, attempt to complete
    the operation or pdiff
(5) If operation is zero and identity is not INST,
    pdiff
(6) Otherwise it runs its Sequenceable.execute(..)
    function, which does whatever it does, perhaps
    adding pending operations or reconfiguring the
    Component map.

[38:

Tue Sep  6 09:16:09 2022 Well, made a
Sequenceable.ulam to get started, but going to
need a review and plan for integrating (1)-(6)
above into the Intender/Intention framework - even
though, I expect, it'll all be happening under a
single Intention.

We'll see.

:38]
:37]

:36]
[39:

Wed Sep  7 17:48:06 2022 So, what all does
PocketChain/PocketChainState do? We're proposing
that SequenceableState will build off that.

Also, what about a generalized seed aka
PocketMaker?

element GeneralSeed {
  ClassId mTypeToMake
}

:39]
[40:

Thu Sep  8 12:29:09 2022 So I made GeneralSeed be
Sequenceable and it's sort of working, for what
that's worth.. but I'm stuck again on why do this
GeneralSeed idea at all.

Why not just build the underlying element?

Is it just to keep the element 'quoted' until the
magic moment when it turns out to be in the
instruction stream of a processor? If so then why
not go with the Bool mQuoted idea and screw the
GeneralSeed? Or mUnquoted or mLive or whatever, to
default passive.

[41:

Thu Sep  8 13:09:17 2022 OK so we made

 quark Quotable : Sequenceable

that adds a Bool mIsLive.

Now we need something to be Quotable.

The idea is the Sequencer, when it's ready for
another instruction, will look at the instruction
stream and dequote whatever's there?

Really seems iffy to be reifying the quotation
status, rather than, say, searching for the
processor and checking its status to determine if
we are quoted.

DON'T STORE STATE.
[42:

Fri Sep  9 10:57:37 2022 OK so we're down to
implementing

  Bool Quotable.isLive(Intention & it)

to do those steps from :37: above. We're going to
be assuming the Intention is at least
PocketChainState (or maybe just SegmentState?) and
we want to know how early we can expect to call
isLive and have the Intention know enough to help
with those steps.[43:

Fri Sep  9 11:59:41 2022 So it's

 SequenceableState ->
 PocketChainState ->
 SegmentState ->
   mEWSNMate
   mPocketWithMate
 PocketableState ->
   mPocket
 Intention

[44:

Fri Sep  9 12:03:05 2022 So it kind of looks like
after mPocket.init() returns false via
PocketableState.init(..), we know we have a
cSTATUS_OK pocket. And what information does that
give us?

It gives us pocket bounds in

  Bound mBounds[4];

[46:

Fri Sep  9 12:23:26 2022 So in fact it seems like
PocketableState.init(..) isn't enough for what we
want. But could it be? [47:

Fri Sep  9 12:25:37 2022 Well, there's
Pocketable.findAvailables(PocketableState&), which
fills in a bunch of info:

  SN mEWSNAvailables[Pocketable.cPP_EAST+1u]; // 0..4
  Bool mPocketIterable[Pocketable.cPP_EAST+1u]; // 0..4
  Unsigned mPocketSize[Pocketable.cPP_EAST+1u]; // 0..4
  Unsigned mPocketUsCount[Pocketable.cPP_EAST+1u]; // 0..4
  Unsigned mPocketFull[Pocketable.cPP_EAST+1u]; // 0..4
  Unsigned mPocketEmpty[Pocketable.cPP_EAST+1u]; // 0..4
  Unsigned mPocketInaccessible[Pocketable.cPP_EAST+1u]; // 0..4

and I'd think could record HC3 positions too?

Actually, couldn't PocketHC3 do that, and
  earlier?[48:

Fri Sep  9 12:39:15 2022 Wait, PocketHC3 already
sets up

  C2D mCoords[PocketDir.maxof+1]; // 0 --, 1 +-, 2 ++, 3 -+
  Unsigned mCoordCount;

and isn't that what we need? Assuming
mCoordCount==4u, then it'd be like

  Atom & a = ew[p.mCoords[i]];
  if (a as DiamondSequencer) {
   ..
  }


:48]

:47]

:46]

and corner info in

  PocketHC3_CornerInfo mCornerInfo[4];

which sounds encouraging but corner info there is

    transient PocketHC3_CornerInfo {
      typedef QHardCell.NgbRels NgbRels;
      NgbRels mNgbRels;
    }

and NgbRels is

  typedef Unsigned(2) NgbRel;
 ..
  typedef NgbRel NgbRels[4];

with like

  constant NgbRel cNGBREL_OFFN = 0u; //< ngb off axis or non-existent
  constant NgbRel cNGBREL_GAP1 = 1u; //< ngb on axis pocket gap 1
  constant NgbRel cNGBREL_GAP2 = 2u; //< ngb on axis pocket gap 2
  constant NgbRel cNGBREL_GAP3 = 3u; //< ngb on axis pocket gap 3

And is that crazy or not? In effect 4x4 2D array
with 16 numbers there? [45:

Fri Sep  9 12:15:06 2022 Maybe it's not crazy. We
have QHardCell.mNgbRels as persistent state, and
the transient (I think) assembles that information
from all four sides, so a pocket inhabitant can
get a view on the status of all the side pockets,
even though most of the HC3s bordering the side
pockets are out of the event window.

:45]


:44]

:43]

:42]
:41]:40]
[49:

Fri Sep  9 13:35:15 2022 OK well here we are
again. This:

    element DiamondSequencer : QHardCellG {
      QProcUnitMap mProcUnitMap;          //< Process function to direction
      QDirStatusMap mDirStatusMap;        //< Quadrant direction to process status
    }

gets us this:

    ./DiamondSequencer.ulam:63:9: ERROR: Trying to exceed allotted bit size (71) for element DiamondSequencer with 77 bits.
    ./DiamondSequencer.ulam:63:9: NOTE: Components of DiamondSequencer are..
    ./DiamondSequencer.ulam:64:3: NOTE: (8 of 77 bits, at 0) QProcUnitMap mProcUnitMap.
    ./DiamondSequencer.ulam:65:3: NOTE: (8 of 77 bits, at 8) QDirStatusMap mDirStatusMap.
    ./HardCellG.ulam:1:7: NOTE: (44 of 77 bits, at 16) from super base class: QHardCellG.
    ./DEWLine.ulam:4:7: NOTE: (8 of 77 bits, at 60) from shared base: DEWLine.
    ./DiamondTypes.ulam:4:7: NOTE: (0 of 77 bits, at 68) from shared base: DiamondTypes.
    ./QDebugUtils.ulam:1:7: NOTE: (1 of 77 bits, at 68) from shared base: QDebugUtils.
    ./QHardCell.ulam:3:7: NOTE: (8 of 77 bits, at 69) from shared base: QHardCell.
    ./DiamondSequencer.ulam:63:9: ERROR: CLASS (regular) 'DiamondSequencer' SIZED 77 FAILED.

So. WTF is QHardCellG doing with 44 bits?
[50:

Fri Sep  9 13:40:14 2022 It's doing:

  /*__________________________________________________
  | COMPONENTS of QHardCellG <72> (61 bits/3 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 4	| mHardCellWatchdog	| XTimer(4,10u,250u) <64>
  | 4	| 4	| mRootWatchdog	| XTimer(4,10u,100u) <63>
  | 8	| 5	| mMaxHops	| Unsigned(5)
  | 13	| 5	| mUpHops	| Unsigned(5)
  | 18	| 5	| mSettledDownHops	| Unsigned(5)
  | 23	| 9	| mColor[3]	| Unsigned(3)
  | 32	| 10	| mDirs[2]	| Int(5)
  | 42	| 2	| mCmdPhase	| Unsigned(2)
  | 44	| 8	| super	| QHardCell <81>
  | 52	| 0	| base	| UrSelf <0>
  | 52	| 8	| base	| DEWLine <42>
  | 60	| 0	| base	| DiamondTypes <58>
  | 60	| 1	| base	| QDebugUtils <76>
  |___________________________________________________
  */

So immediately I'd say:

 - Merge mHardCellWatchdog and mRootWatchdog

 - Strip out mDirs and mCmdPhase and move them
   to a RootHardCellG

Together that buys us 16 bits. We'll save the 9
bit color to kill another day.

[51:

Fri Sep  9 14:02:24 2022 OK, down to:

  /*__________________________________________________
  | COMPONENTS of QHardCellG <71> (57 bits/7 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 4	| mHardCellWatchdog	| XTimer(4,10u,250u) <63>
  | 4	| 5	| mMaxHops	| Unsigned(5)
  | 9	| 5	| mUpHops	| Unsigned(5)
  | 14	| 5	| mSettledDownHops	| Unsigned(5)
  | 19	| 9	| mColor[3]	| Unsigned(3)
  | 28	| 10	| mDirs[2]	| Int(5)
  | 38	| 2	| mCmdPhase	| Unsigned(2)
  | 40	| 8	| super	| QHardCell <80>
  | 48	| 0	| base	| UrSelf <0>
  | 48	| 8	| base	| DEWLine <42>
  | 56	| 0	| base	| DiamondTypes <58>
  | 56	| 1	| base	| QDebugUtils <75>
  |___________________________________________________
  */

[52:

Fri Sep  9 14:22:19 2022 OK, down to

  /*__________________________________________________
  | COMPONENTS of QHardCellG <71> (45 bits/19 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 4	| mHardCellWatchdog	| XTimer(4,10u,250u) <63>
  | 4	| 5	| mMaxHops	| Unsigned(5)
  | 9	| 5	| mUpHops	| Unsigned(5)
  | 14	| 5	| mSettledDownHops	| Unsigned(5)
  | 19	| 9	| mColor[3]	| Unsigned(3)
  | 28	| 8	| super	| QHardCell <80>
  | 36	| 0	| base	| UrSelf <0>
  | 36	| 8	| base	| DEWLine <42>
  | 44	| 0	| base	| DiamondTypes <58>
  | 44	| 1	| base	| QDebugUtils <75>
  |___________________________________________________
  */

and I think DiamondSequencer will now fit with
both its maps. See how much room we might have
left for carry flags or who-knows-what..
[53:

Fri Sep  9 14:25:30 2022 10 bits left:

  /*__________________________________________________
  | COMPONENTS of DiamondSequencer <68> (61 bits/10 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 8	| mProcUnitMap	| QProcUnitMap <69>
  | 8	| 8	| mDirStatusMap	| QDirStatusMap <70>
  | 16	| 28	| super	| QHardCellG <71>
  | 44	| 0	| base	| UrSelf <0>
  | 44	| 8	| base	| DEWLine <42>
  | 52	| 0	| base	| DiamondTypes <58>
  | 52	| 1	| base	| QDebugUtils <75>
  | 53	| 8	| base	| QHardCell <80>
  |___________________________________________________
  */

(or 11 if we give up QDebugUtils, but that won't
happen any time soon anyway.)

[54:

Fri Sep  9 15:18:53 2022 OK, so SeedSeq seems to
make what we expect, including a DiamondSequencer
that now has a QProcUnitMap and a QDirStatusMap.

So we ought to be able to write and test
isLive(..) pretty soon, here, right?

Looks like next up is figure out what quadrant
we're in, so we can see if we're maybe
instructions. [55:

Sat Sep 10 03:59:46 2022 Well, at very very long
last, we appear to have a Demo - which is now a
Quotable, successfully realizing it is the head of
an instruction stream of a DiamondSequencer that
has nothing else to do.

Tons of immediate issues but let's recognize
getting this far is actually a bit of a thing.

Break.

:55]

:54]
:53]

:52]
:51]
:50]
:49]
[56:

Sat Sep 10 12:22:43 2022 So. Had to change the
pump on the swamp cooler this morning but now
we're set.

IMMEDIATE ISSUES IN SEQUENCING

 - Current Demos swap in and out of the
   DiamondSequencer instruction pocket all will-ye
   nil-ye. They need to respect their ProcStatus

 - Somewhere we need semi-general Quotable
   handling - the behavior it does when it's not
   live. Where that includes:

   = Executing the ProcStatus codes
      cDSTATUS_IDLE - do nothing (or, you're live, if INS)
      cDSTATUS_UPWD - if temp self make down, else
                      if temp upstream make down
                      if..
      cDSTATUS_DNWD - if temp self make up, else
                      if temp downstream make up
      cDSTATUS_TEMP - if temp done
                      if upstream temp swap down, done
                      if downstream temp swap up, done

[57:

Sun Sep 11 03:33:48 2022 OK we're still not clear
on chain processing steps. "What do we imagine we
might have been imagining?"
[58:

Sun Sep 11 12:15:34 2022 Maybe we imagined:

 - IN, REG, INS streams would self-stabilize towards
   having a non-temp in the processor pocket.

   = (But then if we're going to be able to
      request a temp in one of those pockets, we'd
      need some completion flag to distinguish
      between a requested temp now available vs
      one that we're supposed to stabilize away
      from.)

 - OUT would self-stabilize towards having a temp
   in the pocket

 - So a non-idle procstatus means "Do this thing
   once and then reset your procstatus to idle
   atomically as part of doing it."

[59:

Sun Sep 11 14:28:18 2022 And how do those
self-stabilization ops work?

:59]

:58]

:57]

:56]
[60:

Sun Sep 11 16:11:17 2022 OK a little cleanup. I
think we should merge Sequencable and Codon.. or
maybe no? I suppose there could be sequencable
stuff that's never executable? But we should move
isExecutable to the Codon level. [61:

Sun Sep 11 16:30:22 2022 OK, well Sequenceable is
a pretty empty API at the moment, but I'm leaving
it there for now.

But now we need some guts for CodonState.act(..)
to deal with the case when the codon is not
executable. [62:

Sun Sep 11 16:43:22 2022 So, all our Codons are
still PocketChain, and so have PocketChain.mDSType
and all.

I think we'd like the main sequence in
CodonState.act(..) to use PocketChain stuff as
services, at whatever level, and so we'd like
PocketChain (and or PocketChainState) to provide
such services at useful levels.

[63:

Sun Sep 11 17:01:54 2022 And hmm we need a
three-way split between

 - executable,
   = so do all our fancy stuff, vs

 - in processor pocket but not executable,
   = so do procstatus rolls and stuff, vs

 - not in processor pocket,
   = so do free-space temp propagation, growth
     (and reshaping) and stuff.

So isExecutable(..) wouldn't be the API we want
there.
[65:

Thu Sep 15 02:11:01 2022 OK so we need/want to hit
the ground running here on DS and Codon. What
about that three-way split there?[66:

Thu Sep 15 02:45:08 2022 We already switched to

      typedef Unsigned(2) ExecutionContext;
      constant ExecutionContext cEXCT_ACTV = 0u; //< Active, we are code, we do our special thing
      constant ExecutionContext cEXCT_PASV = 1u; //< Passive, we are data, we shuffle as directed
      constant ExecutionContext cEXCT_FREE = 2u; //< Free, we are chain, we manage ourselves
      constant ExecutionContext cEXCT_DIFF = 3u; //< Diffuse, try to get around something unsettled

and

      /** Determine our current execution context */
      ExecutionContext
      getExecutionContext(Intention & it) ..

in //// CODON SERVICES

Though at the moment we don't seem to use anything
except Codon.cEXCT_ACTV.

According to getExecutionContext(Intention &), if
there's no DS around, we are cEXCT_FREE.

Now, "no DS around" apparently includes anything
that causes PocketHC3.mStatus to be NOT
cSTATUS_OK.

So that seems kind of wrong: If we're in a bent
pocket (that contains a DS), we want to block..

..although perhaps the end of "Free, we are chain,
we manage ourselves" means we'd re-detect the bent
pocket later, as part of chain self-management,
and we'd block then so it wouldn't be a problem.
[67:

Thu Sep 15 03:28:53 2022 Let's just keep that in
mind as a possible issue but not hang up on it.

:67]
:66]

:65]
:63]

:62]

:61]

:60]
[64:

Mon Sep 12 04:21:06 2022 OK! So it's an incredibly
silly demo, but we have

:64]
[68:

Thu Sep 15 04:17:00 2022 Need some good

TODO

 - Write outline of execution context codon
   behavior

 - Write outline of free chain codon behavior

 - Spike a "first family" of codon
   subclasses. Make an instruction framework that
   can
   = set entrance requirements on PUs
   = wait for reqmts to be satisfied
   = call down
   = set exit requirements on PUs

:68]
[69:

Thu Sep 15 04:24:33 2022 What's our Codon bit
budget look like?

  | COMPONENTS of Codon <42> (25 bits/39 unused):

Not too bad. But do 'entrance reqmts' make sense?

We're thinking we're going to wait for all PUs to
go IDLE before declaring the current instruction
ACTV. So what do entrance requirements mean?
Wouldn't setting PU functions be part of the call
down?

And an instruction (typically) ends by setting
NEXT (meaning cDSTATUS_UPWD?) on the INS PU, which
will cause it to block until it's away from the DS
and then under cEXCT_FREE rules.

[70:

Thu Sep 15 08:33:59 2022 So, does DS do anything
on it's own initiative? So far it sounds like
we're manipulating everything from the
pockets.[72:

Thu Sep 15 08:47:17 2022 (At the moment, DS offers
some services but does not even have its own
behave().. )

:72]

But at one point back there, we were thinking that
at least inter-PU processing could be easier from
DS' central location. No?

Dammit get back to to-do for a specific
spike. Diverging again.

:70]

:69]
[71:

Thu Sep 15 08:36:24 2022

INTENDER BEHAVIOR
 v/UrSelf.behave()
 Intender.pursueIntention()
   v/getIntentionClass()
 v/Intent.init
 v/Intent.pursue


OUTLINE OF CODON INTENTIONAL BEHAVIOR
  (Based on Demo I guess)

  INIT
    Intention.init() - set debug output if enabled
    PocketableState.init - init mPocket or true
    SegmentState.init - PASS THROUGH
    PocketChainState.init - die if mPocket status OPEN
    SequenceableState.init - PASS THROUGH
    CodonState.init - PASS THROUGH

  OBSERVE
    PocketChainState.observe - findMates or diffuse

  STABILIZE
    PocketChainState.stabilize - updateGradients or true

  ACT
   [^DemoState.init - set mWasLive]
    PocketChainState.act - movingSeg/{head|tail}Special
    CodonState.act - 'passive codon behaviors'
   [DemoState.init - diffuse if not special, else regrip]

:71]
[73:

Thu Sep 15 09:50:59 2022 I'm going to commit all
this stuff as a checkpoint, before starting to
tear into guts again. It's been way too long.
[74:

Thu Sep 15 11:31:07 2022 OK, pushed all sorts of
stuff from Plating to TheTeamWillHaveYourBack to
Sequencer16.

:74]

:73]
[75:

Thu Sep 15 11:32:03 2022 So that summary in :71:
above was pretty helpful. Suggests that maybe we
want CodonState.stabilize(..) to do the 'passive
codon behaviors', rather than trying to mess with
the Intention.act(..) ordering.[76:

Thu Sep 15 11:45:44 2022 And am I convinced that
'passive codon behaviors' MEANS the DS-related
non-executiong processing? Rolling the chain,
finding a temp, that sort of thing?

[77:

Thu Sep 15 12:05:02 2022

DS states and Codon reactions:

  constant ProcStatus cDSTATUS_IDLE = 0u; //< Ready for new adventure

Codon:

 Notation: For DS [POCKET], NON-TEMP X & Y,
 up-temp U, down-temp D, any temp T

 FOR cDSTATUS_UPWD: //< Needs roll toward body up (temp down)
      (1) if reachable layout is   T -> [X] -> Y
          switch to                X -> [Y] -> D
          and set _IDLE
      (2) if reachable layout is   T -> [X]
          switch to                [D] -> X
          and stay in UPWD
      (3) if reachable layout is   [D] -> X
          switch to                [X] -> D
          and set _IDLE
      (4) if reachable layout is   X -> [Y] -> U
          switch to                X -> [Y] -> D

 For cDSTATUS_DNWD; //< Needs roll toward body down (temp up)
      (1) if reachable layout is   X -> [Y] -> T
          switch to                U -> [X] -> Y
          and set _IDLE
      (2) if reachable layout is   [X] -> T
          switch to                [U] -> X
          and stay in DNWD
      (3) if reachable layout is   X -> [U]
          switch to                U -> [X]
          and set _IDLE
      (4) if reachable layout is   D -> [X] -> Y
          switch to                U -> [X] -> Y

 For cDSTATUS_TEMP; //< Needs a temp
      (0) if reachable layout is   [T]
          set _IDLE
      (1) if reachable layout is   [X] -> U
          switch to                [U] -> X
          and set _IDLE
      (2) if reachable layout is    D -> [X]
          switch to                 X -> [D]
          and set _IDLE

   (Though this section is pretty unclear --
   caller doesn't know which way a non-temp will
   go? How likely is that to be useful?)

[78:

Thu Sep 15 12:32:12 2022 Well, it's possible
that's some progress. Possible something there
might be worth implementing.

(Perhaps cDSTATUS_TEMP uses a fixed direction per
PU. Like cDSTATUS_TEMP on OUT only does (2),
cDSTATUS_TEMP on IN only does (1). Who knows about
INS and REG?)
[79:

Thu Sep 15 16:38:58 2022 Now, some of those
conditions are only two-armed - like we might be
able to execute them even if we could find only
one of our mates. Does findMates support such a
distinction?[80:

Thu Sep 15 16:42:58 2022 Not really:

      typedef Unsigned MateStatus;
      constant MateStatus cMATE_OK      = 0u; //< All needed mate(s) located consistently
      constant MateStatus cMATE_POCKET  = 1u; //< Bad pocket can't search
      constant MateStatus cMATE_UNSURE  = 2u; //< At least one mate missing but some sites inaccessible
      constant MateStatus cMATE_MISSING = 3u; //< At least one mate is definitely missing
      constant MateStatus cMATE_WRONG   = 4u; //< At least one mate is inconsistent with us
  ..
      MateStatus findMates(SegmentState & ss) {
  ..

And I'd say screw the efficiencies for now and
just go with the three-armed versions.. but
thinking it through now, I think the rules need
generalizing to include a 'temp or non-temp'
type, or we'll have trouble getting off the dime
when we're just two segments long.

:80]




:79]
:78]

:77]

:76]

:75]
[81:

Fri Sep 16 00:35:55 2022 OK, how can we do a spike
to see a couple of these DS states and Codon
reactions happen? Just have DS detect all-0 status
and make up stuff? Then let the Codons try to
react?
[82:

Fri Sep 16 02:54:12 2022 OK let's try again:

CODON V11:

 Notation: For DS [POCKET], NON-TEMP X & Y,
 up-temp U, down-temp D, any temp T, any chain C

 FOR cDSTATUS_UPWD: //< Needs roll toward body up (temp down)
      (1) if reachable layout is   T -> [X]
          switch to                X -> [D]
          and stay in UPWD
      (2) if reachable layout is        [D] -> X
          switch to                     [X] -> D
          and set _IDLE
      (3) if reachable layout is        [X] -> U
          switch to                     [X] -> D
          and stay in UPWD

 For cDSTATUS_DNWD; //< Needs roll toward body down (temp up)
      (1) if reachable layout is        [X] -> T
          switch to                     [U] -> X
          and stay in DNWD
      (2) if reachable layout is   X -> [U]
          switch to                U -> [X]
          and set _IDLE
      (3) if reachable layout is   D -> [X]
          switch to                U -> [X]
          and stay in DNWD

:82]
:81]
[83:

Fri Sep 16 05:10:30 2022 So we were thinking of
rewriting mDSType in some better or more
stigmergic way. If we're going to do that.. around
now would be a good time.
[84:

Fri Sep 16 05:24:38 2022 Well I thought I'd done
some thinking along those lines but I can find no
evidence of it now. Think it was mostly WIBNI
anyway. So.

Stick with DSType for now?

Let's try that, and feel its pain points again.

So we're back in CodonState.stabilize(..)

:84]
:83]
[85:

Fri Sep 16 16:45:47 2022 Well, with tons of pasted
code we are starting to chip away at the
'autonomic DS pocket functions'. Have to bug out
shortly but I think we're about up to dealing with
WTF cDSTATUS_TEMP is supposed to mean. Do we have
any implementable claims about that at all?

[86:

Fri Sep 16 16:57:42 2022 Well it's this I guess:

 For cDSTATUS_TEMP; //< Needs a temp
      (0) if reachable layout is   [T]
          set _IDLE
      (1) if reachable layout is   [X] -> U
          switch to                [U] -> X
          and set _IDLE
      (2) if reachable layout is    D -> [X]
          switch to                 X -> [D]
          and set _IDLE

Question is what to do about motion direction?
Really let non-temp movement direction be
determined by ngb temps? And even if so, what
happens with like this:  D -> [X] -> U ? We flip a
coin to decide which way X goes?

Suppose we say we want to make 'give me a temp' as
specifically an APPEND operation. That means we
want to roll an X out the top and leave a ..

[87:

Fri Sep 16 17:01:56 2022 Actually, don't we want a
'stable' temp that won't go either way, by itself?

Or does nothing move automatically from a DS
pocket, so it doesn't matter?

[88:

Fri Sep 16 17:23:49 2022 Well time to bug so we'll
have to pick it up there later. Not sure what to
think about 'stable temps', since mDSType is bit
budget and we're using all its codes..
[89:

Sat Sep 17 03:44:58 2022 What if we make a special
'pocket temp' type that can be produced when the
procstatus is requesting a temp. Then we can nail
it down with overrides or do whatever we want with
it, and in particular we can distinguish it from a
transitional temp that's just moving through.

So it would be something like

 Notation: For DS [POCKET], NON-TEMP X & Y,
 up-temp U, down-temp D, U or D temp T, fixed temp F,
 any chain C

 For cDSTATUS_TEMP; //< Needs a temp
      (1) if reachable layout is   [F]
          set _IDLE
      (2) if reachable layout is   [T]
          switch to                [F]
          set _IDLE
      (3) if reachable layout is   [X] -> U
          switch to                [F] -> X
          and set _IDLE
      (4) if reachable layout is    D -> [X]
          switch to                 X -> [F]
          and set _IDLE


:89]
:88]

:87]


:86]

:85]
[90:

Sat Sep 17 12:36:55 2022 OK, we make 'EmptyCodon'
to be the 'fixed temp F' and have been trying
various cases around that.

Current issue is: ProcStatus is _DNWD, and we have

   U -> [U] -> X

around the pocket, and nothing is happening.
[91:

Sat Sep 17 12:41:40 2022 I guess we were expecting
we should keep rolling up temps until the X went
all the way around to the upstream side, at which
point the roll _DNWD would success.

The mDemoProvider Demo's mDSType == 1, cDS_NORM,
so that shouldn't be stopping things.  The picture
around the mDemoProvider is like

   [U] -> X -> U

and we want to know why that downstream U doesn't
swap up when it has the chance. Let's get a
debugblast on that..
[92:

Sat Sep 17 12:58:01 2022 Wow, super short:

    20220917125749-3216: 1197AEPS [B3EC6CD7]MSG: print: "SIND10"
    20220917125749-3217: 1197AEPS [B3EC6CD7]MSG: print: "SIND11"
    20220917125749-3218: 1197AEPS [B3EC6CD7]MSG: print: "SIND12"
    20220917125749-3219: 1197AEPS [B3EC6CD7]MSG: print: "PKBST11"
    20220917125749-3220: 1197AEPS [B3EC6CD7]MSG: print: "PCHNS11"
    20220917125749-3221: 1197AEPS [B3EC6CD7]MSG: print: Unsigned: 3
    20220917125749-3222: 1197AEPS [B3EC6CD7]MSG: print: "PCHNS14"

..ah it's a distorted pocket at the moment. That's
not stuck though, is it?[93:

Sat Sep 17 12:59:34 2022 OK, now the pockets look
flat. What happens now?

[94:

Sat Sep 17 13:00:09 2022 Still not much:

    20220917125958-3334: 1209AEPS [B3EC6CD7]MSG: print: "SIND10"
    20220917125958-3335: 1209AEPS [B3EC6CD7]MSG: print: "SIND11"
    20220917125958-3336: 1209AEPS [B3EC6CD7]MSG: print: "SIND12"
    20220917125958-3337: 1209AEPS [B3EC6CD7]MSG: print: "PKBST11"
    20220917125958-3338: 1209AEPS [B3EC6CD7]MSG: print: "PKBST12"
    20220917125958-3339: 1209AEPS [B3EC6CD7]MSG: print: "SGST11"
    20220917125958-3340: 1209AEPS [B3EC6CD7]MSG: print: "PCHNS15"
    20220917125958-3341: 1209AEPS [B3EC6CD7]MSG: print: "CDST11"
    20220917125958-3342: 1209AEPS [B3EC6CD7]MSG: print: "CDST12"
[96:

Sat Sep 17 13:03:55 2022 OK
wait.. CodonState.init(..) is returning true if it
can't find a sequencer? So caller has to be aware
of that?

:96]
[95:

Sat Sep 17 13:01:11 2022 (One thing I note is 3 of
6 of the Demos in this loop have mTargetQuadrant
== 0, where the others, correctly, have ==
2. ShapeShifter growth process still messed up
maybe?)

:95]


:94]

:93]


:92]

:91]
:90]
[97:

Sun Sep 18 01:33:27 2022 Well, at long last, it
appears our latest pointless demo is avoiding DS
deadlock, although the automatic 'refunctionizing'
in DiamondSequencer.behave happens more and more
rarely as the loops grow, just as the DS grip
rotation in DemoState.act does too.

[98:

Sun Sep 18 01:39:02 2022 Except we're still
failing to propagate mTargetQuadrant for some
reason, in some cases, with the result (I think)
that the loop kind of stalls?

[99:

Sun Sep 18 01:50:51 2022 OK, SfCorner spawned from
ShapeShifter isn't picking up TQ, that's one problem..
[100:

Sun Sep 18 02:02:41 2022 OK tq propagation is
seeming okay so far now.[101:

Sun Sep 18 02:03:49 2022 And now the grip rotation
is *really* slowing down, as the loops fill in
their quadrants..

Which all just drives home the next point: We need
new design on subclasses of Codon and thoughts
about

 Baby's First Instructions (TM)

from Fisher-Price.

[102:

Sun Sep 18 03:00:54 2022 Well, how about
BabyForkBomb, then? When executed, it

(1) Requests cPUNIT_OUT <- cDSTATUS_TEMP
(2) Waits for [F]
(3) Copies itself into that [F]
(4) Requests cPUNIT_INS <- cDSTATUS_UPWD

and ceases to be executable at that point.[104:

Sun Sep 18 09:34:02 2022 Although, actually,
between (1) and (2) it's not executable either,
since (1) sets the procstatus map non-zero. It's
just that after (1) it's still in the pocket but
not after (4)..

:104]

[103:

Sun Sep 18 03:12:30 2022 I guess a better name for
that (considering it just duplicates itself once
and doesn't actually fork bomb unless looped)
would be.. wait for it: Baby Dooper!

:103]

:102]

:101]

:100]
:99]

:98]

:97]
[105:

Sun Sep 18 09:42:32 2022 OK we've got a
ShapeShifter failure I think related to the
long-suspicious mSuspended.

 - Demo provider, in a DS input pocket [connected
   upstream to a
     EC, dstype 2 (down temp)
   ] pops a
     Sf, iidx 0, dstype 1, msusp false

 - Sf pops a
     Fc, iidx 0, dstype 0

 - Fc pops a
     Fs, iidx 0, dstype 0
   then switches to Fc, iidx 1

 - Fs retargets EC upstream to itself and its
   downstream to the EC, and switches to Fs, iidx 2

 - A Demo dstype=2 (downstream temp) that is
   upstream of the Demo provider swaps downstream
   with the Demo provider. So now there's a Demo
   non-provider upstream of the Sf.

 X The Demo non-provider swaps downstream with the
   Sf, completely ignoring the Sf.mSuspended flag,
   and destroying the incomplete growth process.

[106:

Sun Sep 18 10:02:26 2022 And that error occurs due
to the Codon.stabilize(..) implementation of this
rule:

      // (2) if reachable layout is        [D] -> X
      //     switch to                     [X] -> D
      //     and set _IDLE

because its code amounts to this:

        Atom & d = ew[dnsn];
        if (d as PocketChain) {
..        if (d.isRealMobile()) {  // and if upstream is X (i.e., mobile nontemp)

where the 'd', in this case, refers to the Sf --
with its mSuspended = true, but that doesn't stop
isRealMobile from returning true, because the Sf
dstype is 1, which is advertising 'normal
swappable'.

[107:

Sun Sep 18 10:21:01 2022 So now we are at the
question:

 - Why didn't we just set the Sf dstype to 0
   (dumb, unswappable) for the duration of the
   growth attempt, instead of creating the
   mSuspended flag to begin with?

Is it possible we thought there might be 'other
types' of Sf for some purpose, so if we overwrote
a prior mDSType we wouldn't be able to get it
back?

Not sure.

Let's look at mSuspended hits and see what we
think of them all.
[108:

Sun Sep 18 10:30:17 2022 Well, there's this:

      Bool mSuspended; // Set when I might be inconsistent

from 202206220056-notes-v14+.txt:249: - and yes,
being actually deliberately inconsistent with
respect to up- and downstream pointers is a bigger
thing 'merely' being mDSType == cDS_DUMB

[109:

Sun Sep 18 10:34:38 2022 So maybe we want both
DUMB and mSuspended?

mSuspended is used only internally to the
ShapeShifter collective, while mDSType is
public.. Using both is certainly believable, but
what if Sf-internal overloaded DUMB to mean 'maybe
inconsistent'.

[110:

Sun Sep 18 10:38:29 2022 What if we go to
Sequencer17 and just try that?
[111:

Sun Sep 18 10:39:38 2022 Well, aand here we
are. Going to try tearing out mSuspended and
instead using mDSType == 0 for 'mSuspended = true'
and mDSType == 1 for 'mSuspended = false'.

But have to get stuff into the slow cooker
first. [112: Sun Sep 18 10:44:51 2022 OK that was
quick.. :112]

:111]
:110]

:109]
:108]
:107]

:106]


:105]
[113:

Sun Sep 18 12:23:24 2022 You know, we could have
MSensor be sensitive to maxhopsgoal (somehow) and
when the diamond 'matures' size-wise, MSensor
automatically starts deploying MCilia or
MSensorExtended or whatever. To get more
contactwarning-free room to grow in, at that
larger size.

The point being we don't need to signal 'please
ciliate' from the root. We're already signaling
maxhopsgoal and that's the same distinction we're
trying to make.

:113]
[114:

Sun Sep 18 16:13:35 2022 So, the loops seem to've
stopped growing at like 158 Demos, seemingly about
evenly.. well, actually bottoms are bigger:

37 nw
33 ne
48 sw
42 se

(but that's 160 so I blew the count a bit.)

Anyway, I suspect they've stopped growing because
of this in CodonState.act(..):

    if (mDSseqc.length() == 0u) // At Codon level, we cannot act without a DS
      return true;

which shortcircuits DemoState.act(..) so the
loop-growing code doesn't run. We're absolutely
going to have to deal seriously with lots of these
PocketChain..Codon..Demo issues, and soon.. but
for now let's switch to

    if (mDSseqc.length() == 0u) // At Codon level, we cannot act without a DS
      return false;

and watch the loops once again fill space..[115:

Sun Sep 18 16:39:41 2022 OK yeah now they're
filling out in the normal pattern - with lots of
Sfs circulating.

So: This 'Demo Provider' concept. We think it has
to go. We'd like to organize 'around the Codon
that's in a DS pocket', I think.

[116:

Sun Sep 18 17:10:10 2022 Now I'd think we'd like
to know if a neighbor is in the pocket, but that
isn't knowable in general via direct observation.

We could set the mDemoProvider bit based on having
an available DS, instead of doing that with
mWasLive as we are now.

And chain ngbs could rather to mDemoProvider to
decide what's what, with just a bit of latency in
the signal.

[117:

Sun Sep 18 17:24:22 2022 And what might the what
be, for those chain ngbs, do we think?

I was thinking we'd like to maintain a population
of temps near the mDemoProvider (or whatever we
end up calling it), so temps could count off or
count down from there, and somebody could make a
decision about popping an Sf if things seem to be
getting tight.

[118:

Mon Sep 19 11:07:40 2022 Still not sure how to
think about desired asymmetries in temps -- like
expecting the OUT unit to be primarily
append-only, so would mostly need temps only on
one side..

APPEND d=3

{IDLE}   1 -> 2 -> D -> [F] -> U -> U

{APND}   1 -> 2 -> D -> [3] -> U -> U

         1 -> 2 -> 3 -> [D] -> U -> U  {APND}

         1 -> 2 -> 3 -> [F] -> D -> U  {IDLE}
         1 -> 2 -> 3 -> [F] -> U -> D
         1 -> 2 -> 3 -> [F] -> U -> U
 ..
         D -> 2 -> 3 -> [F] -> U -> U
         2 -> D -> 3 -> [F] -> U -> U
         2 -> 3 -> D -> [F] -> U -> U


APPEND d=3

{IDLE}   1 -> 2 -> D -> [F] -> U -> U
{IDLE}   1 -> 2 -> 3 -> [F] -> D -> U


APPEND d=3

{IDLE}   1 -> D -> [2] -> U -> U
{APND}   1 -> 2 -> [D] -> U -> U
{IDLE}   1 -> 2 -> [3] -> D -> U
         1 -> 2 -> [3] -> U -> D
         D -> 2 -> [3] -> U -> U
         2 -> D -> [3] -> U -> U

[119:

Mon Sep 19 11:30:36 2022 Maybe we should start
with simpler ops..

{IDLE}  1 -> 2 -> D -> [3] -> U -> 4 -> 5
{UPWD}  1 -> 2 -> D -> [3] -> U -> 4 -> 5
{UPWD}  1 -> 2 -> 3 -> [D] -> U -> 4 -> 5  (1)
{UPWD}  1 -> 2 -> 3 -> [D] -> D -> 4 -> 5  ?
{UPWD}  1 -> 2 -> 3 -> [D] -> 4 -> D -> 5  ?
{UPWD}  1 -> 2 -> 3 -> [4] -> U -> D -> 5  ?    {IDLE}
        1 -> 2 -> 3 -> [4] -> U -> 5 -> D
        D -> 2 -> 3 -> [4] -> U -> 5 -> 1
        2 -> D -> 3 -> [4] -> U -> 5 -> 1
        2 -> 3 -> D -> [4] -> U -> 5 -> 1

{IDLE}  1 -> 2 -> D -> [3] -> U -> 4 -> 5
{DNWD}  1 -> 2 -> D -> [3] -> U -> 4 -> 5
{DNWD}  1 -> 2 -> D -> [U] -> 3 -> 4 -> 5
{DNWD}  1 -> 2 -> U -> [U] -> 3 -> 4 -> 5
{DNWD}  1 -> U -> 2 -> [U] -> 3 -> 4 -> 5
{DNWD}  1 -> U -> D -> [2] -> 3 -> 4 -> 5       {IDLE}
        U -> 1 -> D -> [2] -> 3 -> 4 -> 5
        5 -> 1 -> D -> [2] -> 3 -> 4 -> U
        5 -> 1 -> D -> [2] -> 3 -> U -> 4
        5 -> 1 -> D -> [2] -> U -> 3 -> 4

[120:

Mon Sep 19 11:49:42 2022 So suppose we just call
it a deque, so we must support push, pop, and read
at either end. Now we have only one end actually
in the pocket at any given moment, so there'll be
some nagging asymmetry due to that.

And following the AtomDeque approach, perhaps we'd
like to interleave the contents with empties as
much as possible?

A difference from AtomDeque is that there stuff
was close enough that we could count on reaching
over two positions atomically.

What if up and down temps mean move just one
position and then stop? Or if that was one
available mechanism? Up and Down flags, to help
complete non-atomic 'ChainDeque' ops?

Maybe a ShapeShifter could be like 'quiescent' as
it swaps around a chain, but increments a little
counter as it swaps without seeing other
empties. And if its counter reaches some limit,
the Sf 'activates' and tries to start growing.

[121:

Mon Sep 19 12:28:40 2022 Does seem clear we're
going to need a more systematic notion of 'Chain
empties', and focus on their semantics beyond just
near-DS behavior.

The goal of a 'Chain empty' is to keep the Chain
fluffy but not floppy. Not too loose but not too
tight. As more crap gets inserted into a chain,
the Chain empties will try to grow. (In the
future,) As more stuff gets pulled out of a chain,
the Chain empties will start closing things up.

[122:

Mon Sep 19 12:37:56 2022 Fantasy Chain rules

CE - ChainEmpty  ..hmm or:
EC - EmptyCodon

Let's go with EC for now. I'm okay calling all
this behavior Codon specific.

INITIALIZATION: How to create a chain

    EC <=> EC

INSERT X in Chain:

    before:   EC -> ??
    after:    X -> ??

DELETE from Chain

    before:   X -> ??
    after:    EC -> ??

NEXT in Chain

    before:   EC -> X
    after:    X -> EC

PREV in Chain

    before:  X -> EC
    after:   EC -> X

not clear if/how we make ECs 'transparent' to the
chainops..


SPREAD in Chain

    before:  X -> Y -> EC
    after:   X -> EC -> Y

    before:  EC -> X -> Y
    after:   X -> EC -> Y

COMPACT in Chain

    before:  X -> EC -> EC
    after:   EC -> X -> EC

    before:  EC -> EC -> X
    after:   EC -> X -> EC

[123:

Mon Sep 19 12:48:06 2022 So, question: Do only ECs
run these rules, or do all Codons do it? At least
if we don't require (any|much) additional state,
we could have all Codons do it, which would be
excellent.

We could have some special EC types for special
purposes, and they could have state, but general
Codons would do the stateless rattling whenever
they're not in a DS pocket.

When DS wanted to 'summon' a non-empty, it would
just keep setting the 'down' (or 'up') flags on
whatever EC it's looking at, and stuff would begin
swapping up (or down) toward the DS.

[124:

Mon Sep 19 13:01:57 2022 And what's the semantics
of the 'up' and 'down' flags, exactly?

FLAG SET FOR DEPARTURE
  before:    [EC]
  after:     [ECd]

  before:    [EC]
  after:     [ECu]

FLAG CLEARS ON ARRIVAL
  before:    ECd -> [C]
  after:     EC -> [C]

  before:    [C] -> ECu
  after:     [C] -> EC

FLAG TRAVEL
  before:    ECd -> C
  after:     C -> ECd

  before:    C -> ECu
  after:     ECu -> C

FLAG BIASES MOVEMENT
  before:    C -> ECd -> D
  after:     C -> D -> ECd

  before:    C -> ECu -> D
  after:     ECu -> C -> D

(vs:

  before:    C -> EC -> D
  after0:    C -> EC -> D
  after1:    C -> D -> EC
  after2:    EC -> C -> D
)

:124]

:123]

:122]

:121]

:120]

:119]
:118]

:117]

:116]

:115]

:114]
[125:

Mon Sep 19 13:53:51 2022 OK so can we think about
a plan to try some of this? Fresh start on EC,
which is currently pretty empty anyway? Try some
TODO:

[130: Tue Sep 20 03:10:29 2022
DONE :130] - Break out to EmptyCodon.ulam

 - Build services (for anybody) to try/apply the
   rules, given on SNs of accessible Codons.

[131: Tue Sep 20 03:45:20 2022 Well but this is
basically what element SeedLoop11 does, except it
makes one Demo and one Sf.. If it made ECs?
  :131] - Build a loop initialization service given two
   accessible SNs of emptys ((presumably in
   separate pockets.)  Hmm maybe we should presume
   SegmentState instead, and work in PocketPtr
   terms?)

:125]
[126:

Mon Sep 19 16:11:16 2022 Review EC-related rules:

 - What is different about EC rules when in DS
   pocket?

[127:

Mon Sep 19 16:21:16 2022 Maybe subset of ops
happen when loose in the Chain (out of DS pocket)?

 SPREAD and COMPACT happen
 NEXT and PREV happen
 GROW and SHRINK (not yet documented) happen

and that's it?

[128:

Mon Sep 19 20:19:47 2022 If EC tracked (signed)
distance to DS we could know which way to fluff
towards.. Or separate unsigned body up and body
down. We could bias SPREAD and COMPACT ops based
on that info.
[129:

Tue Sep 20 02:41:16 2022 OK so let's try a cut at
this..
[132:

Tue Sep 20 12:38:16 2022 Well, so we can now seed
a random loop with a SeedLoop11. We can either
preload its mSeedDir and mTargetQuadrant, or we
can let it pick the former randomly and the latter
from the environment.

[133:

Tue Sep 20 12:47:58 2022 Back from singing.

Could we now make a loop eraser? That chews up a
loop from both ends until it's all gone?

:133]

:132]

:129]
  :128]

:127]

:126]
[134:

Tue Sep 20 16:08:23 2022 Aand here we are: with an
apparently genuine need for Sf.mSuspended as
distinct from mDSType == DUMB.

When Fc decides to give up, it finds its Sf base
and does

  base.setSuspended(false)

to tell the base to clean up the Fc. That call
used to set mSuspended, but at present it boils
down to:

      mDSType = issuspended ? cDS_DUMB : cDS_NORM;

Which is fine as far as it goes, but then the Sf
is FREE TO BE SWAPPED by its up or downstream,
perhaps before it gets a chance to clean up the
Fc.

[135:

Tue Sep 20 16:33:45 2022 Althought actually, it
appears in this case the Sf DID get an event, but
didn't clean up the Fc.. What's that about?[136:

Tue Sep 20 16:37:58 2022 It appears that happened
because one of the Sf mates was outside the ew, so
findMates returned (I think) cMATE_MISSING, so
PocketChain.observe decided to diffuse with no
further consideration of anything.

Now, how was Sf supposed to know about dealing
with Fc? When does it notice that little
task?[137:

Tue Sep 20 16:41:06 2022 It deals with it in
ShSfState.trySide(..), which is called by
ShSfISide1.act(..) and ShSfISide2.act(..)

..which we certainly don't reach when
PocketChain.observe imperiously chops off
processing and decides to diffuse.

[138:

Tue Sep 20 16:44:55 2022 buuuut still, just
diffusing, by itself, wouldn't actually kill
anything - if Sf later saw both its mates,
affairs would continue as planned.

So it's still, really, the overloading of cDS_DUMB
for two purposes.

What about creating some extra intentions? Could
we do that without a lot of fuss? And corner would
leave Sf in DUMB, and just change its intention
instead. and those 'deal with corner failure'
intentions could switch to NORM only after they
cleaned up the Fc.

Seems plausible at this distance.
[139:

Wed Sep 21 02:00:53 2022 OK, let's review the Sf
intentions situation and see what we could maybe
do.[140:

Wed Sep 21 02:12:07 2022 Well, there's two left
ATM if we want them:

      typedef Unsigned(3) IntentionIndex;
      /// GROWTH INTENTIONS
      constant IntentionIndex cIIDX_SIDE1 = 0u;
      constant IntentionIndex cIIDX_SIDE2 = 1u;
      constant IntentionIndex cIIDX_ADVANCE = 2u;

      /// SHRINK INTENTIONS
      constant IntentionIndex cIIDX_WORM_HEAD = 3u;
      constant IntentionIndex cIIDX_WORM_MID =  4u;
      constant IntentionIndex cIIDX_WORM_TAIL = 5u;

      constant IntentionIndex cIIDX_RESERVE1 = 6u;
      constant IntentionIndex cIIDX_RESERVE7 = 7u;


:140]

:139]
:138]

:137]

:136]

:135]

:134]
[141:

Wed Sep 21 03:26:49 2022 So why do we need to
suspend Sf at all? Can't it just keep discovering
that its own Fc is out there, and it can look in
the Fc to see if it's failed yet, and clean up if
so?

Nap.
[142:

Wed Sep 21 08:00:26 2022 Well, it can't "just keep
discovering that its own Fc is out there" because
its own Fc might be out of the ew for periods of
time.

Now, theoretically the Sf should always see an
incomplete side pocket at those times, though,
right? So it won't, actually, do anything rash?

[143:

Wed Sep 21 08:05:09 2022 Well, not exactly,
because of this 25% possibility:

    SN cornersn = pocket.searchPocket(side, SfCorner.classidof);
    if (cornersn == SN.maxof) {  // bent or missing
      if (random.oneIn(4u))     // 25%
        return moveOn(ng, side1); // move on
      return ng.diffuse(self);    // but 75% block
    }

so unless it's got an explicit reason to hang
around, it might just take off and strand its own
Fc. [144:

Wed Sep 21 08:15:32 2022 Ookay so I tried just
ditching the 25% case entirely, but now my Sfs are
just sitting there waiting for the broken corner
at the edge of the grid to rectify itself. Which
it actually will in this case but might not in
general.

Soooooo.

We do, I actually think, need more state. We need
to remember if we've even tried deploying Fc in a
direction, so we can try harder to see if it's
done and waiting for cleanup.

Weeeellllll let's try drafting cIIDX_WAIT1 and
cIIDX_WAIT2 and see how it goes..
[145:

Wed Sep 21 10:12:49 2022 Well, I tried, but I'm
not sure I can stand two more intentions for this
issue..

:145]
:144]

:143]

:142]
:141]
[146:

Wed Sep 21 11:56:19 2022 OK moving the
flag. Leaving the code in a not-very-happy
state. Need to

[150: Thu Sep 22 17:07:47 2022
DONE :150] - Make more Sf intentions, or

 - Reincorporate something like the suspended
   flag, or

 - Think of some third approach so Sf can
   distinguish between 'waiting for Fc I spawned'
   and 'have not yet spawned Fc' (on a given
   side).

:146]
[147:

Thu Sep 22 11:32:10 2022 OK, we've tried making
WAIT[12] Sf intentions, and the current issue is
that Sf is dying in WAIT1 because it detects the
inconsistency between itself and its (up and
down)stream Demo. (The Demo's upstream has already
been rerouted to the Fs, while Sf's downstream
hasn't been changed.)

So how do we intervene to:

 (1) Avoid allowing PocketChainState.observe(..)
     to detect the link anomaly, while
 (2) Allowing ..Wait[12] to find the Fc and detect
     Fc's cSUCCEED or cFAIL_DEPLOY?

observe(..) is pretty early, right? Right after
init(..)?

[148:

Thu Sep 22 12:03:46 2022 This seems pretty
bad. Well, to be specific: We need a successfully
initted PocketHC3, so we can search a side pocket
for an Fc, without getting as far as findMates in
PocketChain.observe(..), which will detect the
anomaly.

PocketHC3 inits during.. PocketableState.init(..)

So, WAIT[12].init(..) could search a side pocket
safely, and bail before PocketChain.observe(..)?
[149:

Thu Sep 22 17:05:28 2022 Well, we seem to've
gotten the expanded-set-of-Sf-intentions solution
working, after stumbling over the typical host of
bugs - typoe, copypasta, and otherwise.

:149]
:148]

:147]
[151:

Fri Sep 23 01:33:41 2022 Well, it's foggen Friday
before t2sup and we're way short of any running
program in chain land.

Could we start implementing, like, :122: above?

What all might we need?

 - Reasonably compact pattern matching among
   2 and 3 chain ngbs

Well mostly that.

Suppose we enumify the :122: patterns

typedef Unary(7) ChainType;
constant ChainType cCPAT_EC = 0u; //< EmptyCodon only
constant ChainType cCPAT_X  = 1u; //< Any DUMB or NORM Codon
constant ChainType cCPAT_Y  = 2u; //< Any DUMB or NORM Codon
constant ChainType cCPAT_U  = 3u; //< Any UPWD Codon
constant ChainType cCPAT_D  = 4u; //< Any DNWD Codon
constant ChainType cCPAT_T  = 5u; //< Any temp (UPWD or DNWD) Codon
constant ChainType cCPAT_C  = 6u; //< Any chain at all
constant ChainType cCPAT_N  = 7u; //< Nonexistent (nothing to match here)

typedef ChainType ChainPattern[3]; //< 0: body up, 1: us, 2: body down

transient ChainMatch {
  ChainPattern mPattern = {  cCPAT_N, cCPAT_N, cCPAT_N };
  SN mBindings[3] = {SN.maxof, SN.maxof, SN.maxof };
  Bool mMatched = false;
}

transient ChainRule {
  ChainMatch mLHS;
  ChainPattern mRHS = {  cCPAT_N, cCPAT_N, cCPAT_N };
}

:151]
[152:

Sat Sep 24 16:48:40 2022 OK, well at long last,
InsertZONG sort of appears to be working. It's
almost time for the evening, but we could have Sat
night to try to

[154: Sun Sep 25 11:34:29 2022
DONE :154](1) Pound out the other planned rules.
[155:
DONE :155](2) Redo LoopKiller to anchor at the starting
    point, so the starting point ends up being the
    last to go, so 'caller' can tell when the
    erasure is completed.
(3) Try to get 'self-regulating' loop growth going
    via a crowding rule.
(4) Try to get a demo that generates a loop with
    distinguishable color segments or something.
(5) Yeah sure.

:152]
[153:

Sun Sep 25 11:34:11 2022 Well, made some progress
I guess..
[156:

Sun Sep 25 11:34:54 2022 So, with the :122: rules
implemented (if not all tested), we're up to the
'self-regulating loop' goal. And so: What order do
we want to try the :122: rules - and how do we
want to put weights or odds on them before
choosing?
[157:

Sun Sep 25 12:05:05 2022 Well for starters, I
guess, let's just do SPREAD and COMPACT. And then
maybe we'll want a new rule like:

GROW in Chain

    before:  X -> EC -> X + oneIn(20 or whatever)
    after:   X -> Sf -> Y

which is sad because X -> EC -> Y is really just
what we'd like to be a stable state.. but we can't
do anything with the actual crowded state X -> Y
-> Z because it's got no ECs to work with.

We could have some weight state in EC allowing
them to estimate local densities. Like

    before:  X -> Y     -> EC
    after:   X -> ECw+1 -> Y

    before:  EC -> X     -> Y
    after:   X  -> ECw+1 -> Y

    before:  EC -> EC    -> EC
    after:   EC -> ECw-3 -> EC

or whatever, and then something like

    before:  . -> ECw>10 -> .
    after:   . -> Sf     -> .

:157]
:156]
:153]
[158:

Sun Sep 25 13:09:15 2022 Well, so here's a foggen
question: In a rule like

    COMPACT in Chain

        before:  X -> EC -> EC
        after:   EC -> X -> EC

what if X is in a DS pocket, but we don't know
that? We just tore it out of the pocket? Do we
actually need a constraint that we can't move
non-center non-temps?

[159:

Sun Sep 25 13:12:57 2022 Also affects NEXT and
PREV.

Is there any way to know if the ngbs see a DS?

Well wait. Can't/Couldn't we say that any non-temp
in a DS pocket should set cDS_DUMB explicitly? And
then none of these rules will apply? Does 'X'
match a DUMB non-temp or only a NORM one?

[160:

Sun Sep 25 13:25:01 2022 At the moment,
ChainRule.isCodeAt(..) says:

    case cCPAT_X:
    case cCPAT_Y:  { return p.mDSType == c.cDS_DUMB || p.mDSType == c.cDS_NORM; }

but shouldn't we really distinguish between
swappable and non-swappable non-temps?

It's been looking like the X vs Y distinction is
unnecessary, at least internally, since we refer
to matches positionally. Perhaps we want to rework
for NORM vs DUMB non-temps while we still have a
little leeway here?

Redo.

typedef Unary(7) ChainType;
constant ChainType cCPAT_EC = 0u; //< EmptyCodon only
constant ChainType cCPAT_X  = 1u; //< Any NORM Codon
constant ChainType cCPAT_Y  = 2u; //< Any DUMB Codon
constant ChainType cCPAT_U  = 3u; //< Any UPWD Codon
constant ChainType cCPAT_D  = 4u; //< Any DNWD Codon
constant ChainType cCPAT_T  = 5u; //< Any temp (UPWD or DNWD) Codon
constant ChainType cCPAT_C  = 6u; //< Any chain at all
constant ChainType cCPAT_N  = 7u; //< Nonexistent (nothing to match here)

INITIALIZATION: How to create a chain

    EC <=> EC

INSERT X in Chain:

    before:   EC -> ??
    after:    X -> ??

DELETE from Chain

    before:   X -> ??
    after:    EC -> ??

NEXT in Chain

    before:   EC -> X
    after:    X -> EC

PREV in Chain

    before:  X -> EC
    after:   EC -> X

SPREAD in Chain

    before:  Y -> X  -> EC
    after:   Y -> EC -> X

    before:  EC -> X  -> Y
    after:   X  -> EC -> Y

COMPACT in Chain

    before:  X -> EC -> EC
    after:   EC -> X -> EC

    before:  EC -> EC -> X
    after:   EC -> X -> EC

[163: Sun Sep 25 14:35:19 2022 (Redone for 4bit chaintype)  :163]
..Well so that doesn't really change much: Now the
rules just never refer to Y.

We still have to arrange for non-temps that find
themselves in pocket to go DUMB for the
duration. And have the DS stabilize ops be willing
to override and adjust that when it moves things,
on the view that DSType info is only for 'free'
Codons maintaining themselves away from actual
execution.
[161:

Sun Sep 25 14:30:58 2022 Hmm, for things that we
don't move, we might want a movable-or-not
code. Maybe X for NORM, Y for NORM or DUMB? Z for
just DUMB.. ..but we're out of codes at the
moment.[162:

Sun Sep 25 14:33:31 2022 Well, bumped ChainType up
to Unsigned(4). Not like it's bit budget anywhere.

:162]

:161]
:160]


:159]


:158]
[164:

Sun Sep 25 17:56:50 2022 OK, moved the
'Codon.newAct(..)' stub to 'newStab(..)' to try
matching our new patterns during
Codon.stabilize:

      @Override
      virtual Bool stabilize(Intender & in) {
        if (super.stabilize(in)) return true;

        print("CdnStab10");

        // If we are free, self-managed chain,
        if (mExecutionContext == cEXCT_FREE)
          return newStab(c);        // Go deal with that

Actually why don't we call it freeStab. Done.

And the rule ordering is going to be what?

Try pattern(..) and matches(..) on these rules,
collecting the match results:

 spread10
 spread11
 compact10
 compact11

and for now I guess, just pick one randomly from
the matching, and do that. Oh, where was our grow
method? It's :157: above but did we implement it?

I don't think we did. Let's do that. Don't do the
odds business; leave that for caller.[165:

Sun Sep 25 18:07:01 2022 Hmm let's get specific on
the rule names, here:

  ChainRule_SPREAD10
  ChainRule_SPREAD11
  ChainRule_COMPACT10
  ChainRule_COMPACT11
  ChainRule_ALLEMPTY

  ChainRule_PREV
  ChainRule_NEXT
  ChainRule_DELETE
  ChainRule_INSERT

[166:

Sun Sep 25 18:13:30 2022 OK now we have

  ChainRule_CROWDGROW

and we moved ChainRule.matches(..) into the API to
allow overriding. So CROWDGROW matches if there's
an EC in the center that has mCrowdWeight
maximized. And its apply(..) replaces the center
with an Sf GROW.

:166]

:165]

:164]
[167:

Sun Sep 25 20:23:49 2022 OK we're
debugging. Current issue is WTH is the difference
between execution context cEXCT_NIQD and
cEXCT_FREE? "Doc" (hoho) says:

  constant ExecutionContext cEXCT_NIQD = 0u; //< Not in quadrant, don't know squat
vs
  constant ExecutionContext cEXCT_FREE = 3u; //< Free, we are chain, we manage ourselves

where 'quadrant', there, means 'DS quadrant' and
not diamond quadrant.

I guess we really don't understand cEXCT_DIFF
either. Is that ever used?[168: Sun Sep 25
20:26:28 2022 Nope.

Let's check NIQD vs FREE uses and see if we can
fold them together..

[169:

Sun Sep 25 20:27:36 2022 Well this is lovely:

    if (mInQuadrant) {
  ..
      if (!mInQuadrant)
        mExecutionContext = cEXCT_NIQD;
      else if (mDSseqc.length() == 0u)
        mExecutionContext = cEXCT_FREE;
  ..

just in case mInQuadrant decides to flip its value
for no reason..

:169]

:168]

 :167]
[170:

Sun Sep 25 23:36:17 2022 OK found a typoe in
SPREAD10 and things are beginning to work a
little. Now have a semithinko about measuring
crowding: Right now, a cruising Sf is NORM, and so
counts as an X for SPREAD10 and SPREAD11, and so
the involved EC increments its crowdweight, which
seems distinctly wrong.

I guess we want a special case not to do that if
we see Sf?[171:

Sun Sep 25 23:40:25 2022 Well, doing like:

    if (x is ShapeShifter)
      ec.mCrowdWeight--;
    else
      ec.mCrowdWeight++;

We shall see.[172:

Sun Sep 25 23:53:00 2022 Pushed up to

    if (x is ShapeShifter)
      ec.mCrowdWeight /= 2u;
    else
      ec.mCrowdWeight++;

to try to reduce density.

:172]

:171]

:170]
[173:

Mon Sep 26 11:56:56 2022 From the fresh part last night:

GATHER OUR RICHES

 LoopReset q, type of Codon to seed with [RETRY COUNT]
 LoopInsert q, source
 random q,

:173]
[174:

Mon Sep 26 14:56:33 2022 OK so we are really
really really out of time here, but the last
lingering dribs of development I'm doing (LX.ulam)
make abundantly that we're going to have to
have the DS itself execute instructions on behalf
of the instruction stream, because only the DS
itself will have a flying fog of a chance at
accessing all the processing units in a single
event window.

So we're going to have to reorg a fair chunk of
stuff, I expect, because - even though I thought
about this before at least once - when I got down
to implementing I just went self-centric as
always..

:174]
[175:

Sun Oct  2 03:02:39 2022 OK so we just like that
lost most of a week, here. Ugh. Was working on
other legitimate stuff but still tick tock Dave.

So: The 'next step' is a DiamondSequencer
instruction execution service that assembles the
available components and then calls some Codon API
to do the execution based on the assembled
components. That Codon API should basically not
look at the ew at all but just work through the
component representations passed as args.

[176:

Sun Oct  2 07:30:24 2022

So right now, DS.behave() is this:

  virtual Void behave() {
    if (mDirStatusMap.isAllIdle())
      mDirStatusMap.randomizeIdles();
    super.behave();
  }

and, I guess, it wants to be something like this:

  virtual Void behave() {
    if (mDirStatusMap.isAllIdle())
      if (tryExecution()) return;
    super.behave();
  }

so we don't go to QHardCellG.behave() if we
actually managed to execute an instruction.

And tryExecution() wants to build up some kind of
DiamondSequencerState (which we don't have yet),
and pass that to the instruction-being-tried.

Now, I'm wondering how we do pocket stuff when
ew[0] is an HC3.[177:

Sun Oct  2 07:40:50 2022 If we call
PocketHC3.init() from when ew[0] in an HC3, we are
going to get cSTATUS_EDGE back every time, with
nothing much set up. Not helpful.

So suppose we scan the ew ourself. But wait: HC3
must be doing that already, when it checks grid
alignment. We've been living en-pockette for so
long we've forgotten about grid stuff.[178:

Sun Oct  2 07:46:49 2022 Yeah, it's
HC3NgbState. Actually that's just one ngb.

We want HC3State; that's got four of them.[179:

Sun Oct  2 07:50:44 2022 QHardCell.update() makes
an HC3State and does a ton of work with
it. Presumably we should do that work first if
needed, and consider DS instruction execution
('IX'?) if things are still stable afterward.
[180:

Sun Oct  2 16:46:08 2022 OK, so we've got
DS.tryExecution(DiamondSequencerState&) getting
called. What do we want it to do first?[181:

Sun Oct  2 17:57:32 2022 Well, we have an initted
HC3State (inside the DSS) so (I think) we could
determine which pockets are bent and which pockets
we can see all of. That seems like a useful thing,
on the way to searching the pockets for
codons.[182:

Sun Oct  2 23:05:38 2022 Does anybody have any
existing code to help us with assessing pockets
from HC3State? Code that doesn't depend on ew[0]
being in a pocket?[183:

Sun Oct  2 23:29:59 2022 Well we should be able to
come in at the level of RectIterator anyway, that
should help some?[184:

Sun Oct  2 23:38:05 2022 Well screw it, let's just
start implementing and see what resonances may
develop. In DiamondSequencerState for starters I
guess.

[185:

Mon Oct  3 06:27:54 2022 So, for after nap:

STEPS

0 - Run HC3 ops, out if mods
     DS.behave() -> update(dss)
                    = does dss.init(self)
1 - out unless IX or tryExecution(dss)
2 - Find ProcUnit quadrants
    dss -> mPUInfos.init(DSS&)
3 - Determine per PU HC3 status, out unless pocket square
4 - PU pocket is 2x2 1x2 or 2x1 or out
5 - Search per PU for [opt] single Codon and Empty
6 - Invoke Codon.execute(DSS &) service
7 - Pick up over on the Codon side
8 - Out unless get needed PUs (VM)
9 - Do op

[186:

Mon Oct  3 14:00:21 2022 So, trying to work
through this, I'm noticing that QHardCell
seemingly predated the Intender/Intention
framework? Intentions have been kind of successful
so now I'm wondering if I should try yak shaving
down to converting the former to use the latter..
[187:

Mon Oct  3 15:57:14 2022 Well, QHardCell now IS-A
Intender and QHardCellState (exists and) IS-A
Intention. And QHardCell.update(HC3State&) now
happens during Intention.stabilize(..)

So.. Now what?

Put tryExecution in DSS.act? Maybe.[188:

Tue Oct  4 00:41:11 2022 OK that's getting called;
what's next?
[189:

Tue Oct  4 00:42:20 2022 At the moment,
DSS.init(..) just initializes members. We have a
ProcUnitInfo.findQuadrant that we were expecting
to call; perhaps try to do that during
DSS.observe(..)? [190:

Tue Oct  4 00:57:45 2022 Hmm, except then
blockages in observe(..) keep stabilize(..) from
running and the DS blocks the whole diamond. If
we're going to keep the findQuadrant calls there,
we can't be upset if they fail.[191:

Tue Oct  4 01:38:23 2022 OK, so now we get down to
findQuadrant in observe(..) and later get down to
tryExecution in act(..). What next?

[192:

Tue Oct  4 01:39:17 2022 I guess we'll start
populating tryExecution for now and expect to
migrate stuff out if and when structure
develops. I guess check 3 and 4 of :185: above?
[193:

Tue Oct  4 01:57:24 2022 OK here's a thing: We now
call the gigantic QHardCell.update() method from
QHardCellState.stabilize(..). But update() makes a
lot of 'act()-ish' decisions - like returning true
after deciding it needs to block because it
doesn't "HAVE ENOUGH DOWN ALIGNMENT TO MOVE NOW"
(QHCUP223).

So that amounts to saying we can only execute
instructions if the (local) diamond grid is
settled enough to move? That seems kind of
extreme.

If we're not making any representations to IX that
the grid is in any particular shape - other than
the immediate DS quadrants are good - I don't see
why we need that.

So is the idea that update shouldn't return true
to 'block'? The point is: If it was going to
actually move or like that, it would just do it,
and then return true. So having block() return
true is, at best, misleading.

Other HC3, that don't depend on moving, could
continue, right? Let's evaluate the block()-type
returns in QHC.update() and see how many we think
could be followed by IX.

[194:

Tue Oct  4 02:58:02 2022 We are blocking out of
update when:

1. We have modified our upHops
2. We have modified our maxHopsGoal
3. We have uninitted neighbors
4. We have modified our maxHopsGoal (again??)
5. We have modified our upHops (also, again??)
6. We find multiple HC3 in one ngb region
7. We have updated contact warnings
8. We spawned
9. We are not settled enough to move
10. My ups are not consensus-aligned
11. I want to move but dest is not empty
12. We actually moved.

We blockOrDie when
 - Our upHops exceeds the upHopsGoal

[195:

Tue Oct  4 03:07:02 2022 And of the 1..12 there,
which ones do we think we could IX after? Or put
it this way: Which ones do we think we CAN'T IX
after?

Maybe 8 and 12? And 3? Like that's it? Maybe 6?

But I think we'd need to record the difference
between false-meaning-nothing-going-on and
false-meaning-blocked-for-move-and-grow-ops.

I'd think downstream could need to know
that. Because even though at the moment we have
rootBehave(), for example, getting called directly
from update(), I'd think we'd like to have the
option to deal with such things in subclasses.

What if we redid QHC.block() as like

  mIsBlocked = true;
  return false;

and see what happens?
[196:

Tue Oct  4 22:35:10 2022 OK, we had a stupid bug
that cost a chunk of time - calling
Intention.init(Intender &) and thereby erasing
later work - but now I think we're headed forward
on IX again.

[197:

Wed Oct  5 00:49:49 2022 OK so I'm starting to
convince myself that despite all the artillery
deployed so far, we don't immediately have at hand
the information that we want about the quadrants
surrounding the DS (or an HC3 generally).

What we want is like:

  Bool mQuadGood; // square and accessible
  RectIterator mQuadRI; // also provides C2D min and max

and

  Bool pocketReachable() {
    // if mQuadGood pocket and size <= 2x2
  }

[198:

Wed Oct  5 09:01:47 2022 And the way we get that
is first capturing and second analyzing the
ngbrels of our HC3 axial ngbs.

:198]

:197]

:196]
:195]

:194]

:193]

:192]


:191]

:190]

:189]
:188]

:187]

:186]
:185]
:184]

:183]

:182]

:181]

:180]
:179]

:178]

:177]

:176]

:175]
[199:

Thu Oct  6 01:38:13 2022 OK goddammit I have to
make a picture of all this half-baked emerging and
get some clarity about what it all is and what
should go where.

So. Right now, as of the last build, focusing on
the key classes, we have:

  | COMPONENTS of DiamondSequencerState <4> (951 bits/7241 unused):
  | 0	| 63	| mAxialNgbs	| QHCAxialNgbs <102>
  | 63	| 77	| mPUInfos	| ProcUnitInfos <104>
  | 140	| 810	| super	| QHardCellState <3>
 ..
  | COMPONENTS of QHardCellState <3> (811 bits/7381 unused):
  | 0	| 809	| mHC3State	| HC3State <99>
  | 809	| 1	| mIsBlocked	| Bool
 ..
  | COMPONENTS of HC3State <99> (809 bits/7383 unused):
  | 0	| 32	| myUpHops	| Unsigned
  | 32	| 32	| myUpHopsGoal	| Unsigned
  | 64	| 32	| minUpHops	| Unsigned
  | 96	| 32	| maxUpHopsGoal	| Unsigned
  | 128	| 680	| mHC3NgbStates[4]	| HC3NgbState <95>
 ..
  | COMPONENTS of HC3NgbState <95> (170 bits/8022 unused):
  | 0	| 4	| mState	| Unsigned(4)
  | 68	| 32	| mNgbCtr	| C2D <59>
  | 100	| 32	| mFoundAt	| C2D <59>
  | 132	| 1	| mFoundInaccessible	| Bool
  | 133	| 1	| mFoundBlockage	| Bool
  | 134	| 1	| mFoundUninit	| Bool
  | 135	| 1	| mFoundUpstream	| Bool
  | 136	| 1	| mFoundDownstream	| Bool
  | 137	| 1	| mFoundFoamWarning	| Bool
  | 138	| 32	| mFoamCount	| Unsigned
 ..
  | COMPONENTS of QHCAxialNgbs <102> (63 bits/8129 unused):
  | 0	| 1	| mInitted	| Bool
  | 1	| 1	| mExamined	| Bool
  | 2	| 60	| mAxialNgbs[4]	| QHCAxialNgb <101>
 ..
  | COMPONENTS of QHCAxialNgb <101> (15 bits/8177 unused):
  | 0	| 2	| mAxis	| Unsigned(2)
  | 2	| 2	| mGap	| Unsigned(2)
  | 4	| 8	| mNgbRels[4]	| Unsigned(2)
  | 12	| 1	| mInitted	| Bool
  | 13	| 1	| mExamined	| Bool
 ..

[200:

Thu Oct  6 03:00:17 2022 Aand we're trying to get
to something like:

IXStatus
 pocketStatusForIX[PocketDir.maxof+1]; // 0..3 nw, ne, se, sw

PocketStatusForIX
 PocketDir mQuadrant
 Bool mIsGood    // pocket square & accessible, 2x2 1x2 or 2x1
 RectIterator mRI
 SN mCodon
 SN mEmpty

and to tell mIsGood in a mQuadrant
we

(1) consult the HC3State.
(2) for each quadrant
    we take the x the prev axialdir
    and the y from the next axialdir

    the ngbrel[next ad] in the prev ad direction
    must equal
    the ngbrel[prev ad] in the next ad direction

    out if not

    both ngbrel must be 1 or 2

    out if not

    otherwise mIsGood

if mIsGood
iterate the pocket and select
 mCodon
 mEmpty

and let's say DONE at that point

the rest is up to the IX somehow.

[201:

Thu Oct  6 07:05:38 2022

Then,

IXROUTE src dst cnd suc fail

src: [IOTX]|+IMM|-IMM
dst: [IOTX]
cnd: [
suc: +[<.>]
fail: -[<.>]

[202:

Thu Oct  6 07:31:35 2022 What if there's only one
instruction - conditional route? Like a CISC
Sheffer stroke?
[203:

Thu Oct  6 12:08:34 2022

IXRIF sadr  src dst cnd suc fail

src: [IOTX]|+IMM|-IMM
dst: [IOTX]
cnd: [
suc: +[<.>]
fail: -[<.>]

[204:

Thu Oct  6 12:14:12 2022

  | COMPONENTS of Codon <44> (27 bits/37 unused):

Maybe let's trying imagining 32 bits per
instruction.

(The sequencer is a lot tighter:

  | COMPONENTS of DiamondSequencer <73> (61 bits/10 unused):
)

How about 8 bit 'addresses'? That's some room to
work in.. Three address machine?

What about embrace self-modifying code right off
the bat?

Use cases we'd like to express:
 - src is an immediate value
 - src/dest is a quadrant full atom
 - src/dest is a quadrant class data member
 - dest is a quadrant empty site
 - src/dest is a DS status field
 - src/dest is a DS grip

that's 6 'modes'?
immediate  00xxxxxxxx  x = value
quad full  01qq000000  qq = quad
quad key   01qqkkkkkk  qq = quad, k = .get/.set src/dest
DS status  10ssssssss  ss = status map




:204]
:203]
:202]

:201]

:200]

:199]
[205:

Fri Oct  7 14:50:56 2022 We are getting very very
close to executing an instruction, here, but now
have a little designo popping up:

We're working in LX.ulam with the LX API that I
set up god knows back when, and it specifies:

  //// LX API
  /** \returns true if changes; false if blocked
   */
  virtual Bool perform(LXState & lxst) ;

which seemed (at the time) like the standard way
we go about these things these days.

But: Where is that LXState & supposed to come
from? We're all-in, here, on saying that it's the
DS that actually runs the instructions, which
means all we're really going to have is a
DiamondSequencerState &, and the LX API needs to
reflect that.

But there is some quarter-baked stuff in LXState
at the moment..

How baked is it really?[206:

Fri Oct  7 14:55:42 2022 Not very. Let's leave it
in, for the moment, but change LX over to DSS.
[207:

Fri Oct  7 15:07:35 2022 And there, finlly finally
finally, it is:

    20221007150713-3551: 130AEPS [7D2D82F7]MSG: print: "DSTX14"
    20221007150713-3552: 130AEPS [7D2D82F7]MSG: print: "LXRESET10"

coming from

    element LXReset : LX {
      //// LX API
      virtual Bool perform(DiamondSequencerState & dss) {
        print("LXRESET10");
        return true;
      }

We have our very first 'executed instruction'.

Taking a break.

[208:

Sat Oct  8 00:20:54 2022 OK push on Push ON!

Possibilities:

 - What should a (full) reset do? It's a natural
   place to start a sequential instruction set


 - But if our t2sup TITLE is "ONE SPELL TO RULE
   THEM ALL" we'd optimally want (some level of)
   reset to be merely a use of the ONE SPELL

[209:

Sat Oct  8 00:51:08 2022

Let's think about RIF

 - suppose we had a bitmap of destinations?
   suppose you could copy multiple places at once?

bitmap sources: 4b
bitmap dests:   4b

or

bitmap src1:   4b
bitmap src2:   4b
bitmap dsts:   4b

plus

Unsigned(4?)  reduceop


[210:

Sat Oct  8 02:16:47 2022 Godammit stop it no more
goddamn generalizing here just implement some
ABSOLUTELY SPECIFIC THING DAMMIT NOW NOW NOW.

How about 'SEARCH q, classid' just that much?
[211:

Sat Oct  8 05:35:46 2022 OK so we have LXReset
going as far as killing the REG and OUT loops, and
now we want to init those loops, and: What should
we init them to? SeedLoop currently uses a Demo
and a ShapeShifter, and it's time to move past the
Demo.

An EC and a Sf? Let's give it a try.
[212:

Sat Oct  8 05:55:07 2022 OK having an issue with
Sf grow getting interrupted because EC is choosing
to swap with an Sf right after Sf deployed Fc. How
is EC supposed to know not to do that?[213:

Sat Oct  8 05:58:13 2022 OK, the EC in question is
mDSType=2, meaning it's a 'downbound temp'.

It discovers it has a downstream mate.

And hey it asks the foggen downstream if it's
isSwappable(..), so what's the problem?

Fast break for cat's breakfast...
[214:

Sat Oct  8 06:15:54 2022 OK so didn't Sf say no to
isSwappable? [215:

Sat Oct  8 06:17:00 2022 Hmm:

    element ShapeShifter : PocketChainTQ + DiamondTypes {
 ..
      //// PocketChain API
      //  virtual Bool isSwappable(PocketChainState & ds) { return false; }

Don't we want something a little more subtle than
that? Like depending on the current intention,
perhaps?

[216:

Sat Oct  8 06:20:22 2022 Trying

      virtual Bool isSwappable(PocketChainState & ds) {
        return
          mIntentionIndex != cIIDX_WAIT1 &&
          mIntentionIndex != cIIDX_WAIT2;
      }
[217:

Sat Oct  8 06:31:16 2022 OK that seems okay but
now the issue is we have two PUs (OUT and REG)
with cDSTATUS_DNWD and it never seems to be
resolving. I think Codon.stabilize(..) may need
more cases? In its cEXCT_PASV case

In particular, if we are a Down temp with an X
downstream, should perhaps turn into an Up temp or
something?

But, nap time.[218:

Sat Oct  8 12:46:43 2022 OK so (at least part of)
that problem was that the 'RS' LXReset atoms were
being initted as cDS_DUMB, so they refused to
move.

But when we change that to cDS_NORM, then they
slide right out of their DS quadrant without being
told to move. We need to have cDS_NORM say
'swappable except when in a DS quadrant'? That
seems like a pretty disgusting hack.
[219:

Sat Oct  8 13:26:07 2022 So, the API is
PocketChain.isSwappable(PocketChainState&) and
that's a problem because PocketChainState doesn't
know squat about DiamondSequencer. It would take a
whole other virtual call for like

  Bool PocketChainState.isSwappable(PocketChain&)

or perhaps a name modified to be less confusing..

[220:

Sat Oct  8 14:35:45 2022 OK have been knocking
things around; current issue is: We got ourselves
to cDSTATUS_IDLE on the INS quadrant, while
there's an EC there, so we hit this code:

        if (ins.mIsEmptyCodon)
          return false;             // EmptyCodon does not execute (by definition)

and bail out. So nothing happens. The EC doesn't
move on its own, because it's not isSwappable now,
now that it knows it's in a DS pocket.

It sort of seems like we want a special case in DS
saying that if we're otherwise ready to execute,
but there's an EC in INS, we should change status
to roll INS all on our own..

If the loop consists of nothing but ECs (as the
current INS loop does, DS should just keep it
rolling rolling rolling, along..

Let's see if it's at all clean to say we want to
do that.[221:

Sat Oct  8 15:43:26 2022 So I tried adding 'rules'
saying we could do [U] -> [D] and vv, hoping that
would get things unstuck, but it doesn't and I
think it's because nothing 'spontaneous' is going
to happen in the DS pockets now.

So now I'm thinking that instead of changing the
temp direction, we should

(1) Set it to the dir DS wants it to go, and
(2) manually kick the thing that way.

The point is we want the thing to swap its way
around the loop after we kick it once, so we want
to put it at the start of the direction it wants.

How do we do this?[222:

Sat Oct  8 15:59:00 2022 What if we make our new
CodonState.isSwappableInContext a little smarter?
It's not SwIC if there's a DS, *unless* the DS
says we're in a q with with an appropriate
ProcStatus?

Like if we're a temp down and the quadrant is
cDSTATUS_UPWD or we're a temp up and q is
cDSTATUS_DNWD..

And how do we do the swap?
[223:

Sat Oct  8 16:42:21 2022 Well, went to:

      Bool CodonState.isSwappableInContext(PocketChain & pc) {
        if (!hasDS()) return super.isSwappableInContext(pc);
        if (!mInQuadrant) return super.isSwappableInContext(pc); // ??

        if (mOurPS == cDSTATUS_UPWD && pc.mDSType == cDS_DOWN)
          return true;
        if (mOurPS == cDSTATUS_DNWD && pc.mDSType == cDS_UP)
          return true;

        return false;
      }

and things do seen to be getting unstuck more.

I want to make an LXAnchor or LXTag or LXLabel or
something, that can serve as an initial non-EC and
get used perhaps as a marker to return the loop
to.

Or something like that.

[224:

Sun Oct  9 00:25:20 2022 OK we found a case where
a 'MK' LXMarker was moved out of the IX pocket by
an EC ngb, and ran that down to our beautiful
abstract ChainRule.ulam with its cCPAT_EC and
cCPAT_X. In particular, ChainRule.isCodeAt(..)
returned true for X when a non-temp was in a DS
pocket.

Made Bool ChainRule.isX(..) to include the more
subtle analysis, which required refactoring the
whole thing to take PocketChainState& instead of
the SegmentState& it had been using.

Now, what exactly is the desired semantics for Y?

[225:

Sun Oct  9 01:48:23 2022 The existing predicate
says

    case cCPAT_Y:  { return p.mDSType == c.cDS_DUMB || p.mDSType == c.cDS_NORM; }

which you'd think would need to be changed
to use the isX(..) or something like it.. But in
the rules we have, it appears that Y never
actually gets moved - it's king of an anchor for
pattern matching or something.[226:

Sun Oct  9 01:59:48 2022 Well, leaving Y case as
above there, for now. I can't find a rule that
moves a Y, ATM..
[227:

Sun Oct  9 02:10:39 2022 Aaaand that all doesn't
work. Haven't instrumented it fully but the guess
is PocketCh.. wait, this is completely
incoherent. We passed in a PocketChainState& pcs
so isX could ask if Codon &c is swappable, but in
a rule like

/** CHAINRULE: COMPACT10: X -> [EC0] -> EC1  ==>  EC0 -> [X] -> EC1 */


that pcs was developed for a Codon {EC0} that's in
a DIFFERENT POCKET from the Codon &c {X}.

[228:

Sun Oct  9 02:17:16 2022 Gah. So it seems like

(1) We need to pull the 'in DS Pocket' predicate
    inward into the Codon itself.

(2) The obvious idea is bite the bullet and switch
    non-temps to cDS_DUMB while they're in a DSP.

(3) But there's a race: Whenever we swap
    PocketChain links, one (or both) or them might
    end up in a DSP without being able to know
    that atomically.

So we can't leave them cDS_NORM because they might
be in a DSP, but we can't make them cDS_DUMB right
away, because they might not be.

So, it seems, we'd have to make a new state - like
cDS_INCOMING or cDS_ARRIVED or cDS_UNSETTLED or
something - and assign that to any PocketChain
that's moving away from ew[0]. Or just take off
and assign it to all moving PocketChains.

But then, when those PocketChain& get an event,
and determine whether or not they're in a DSP,
what drive status do they switch to? DUMB if in
DSP or NORM if not? Is that safe?

Does any/all of this apply to temps? Do we need to
pin temps in DSPs? Well yeah kinda, you'd think:
If the last ProcStatus op cDSTATUS_TEMP, and we
cleared it when a temp arrived, we really do want
that temp to stay there until IX can deal with it.

So UNSETTLED starts to feel like a whole nother
damn bit next to the DriveStatusCode, ugh.

Whenever a PocketChain changes pockets, we set
UNSETTLED. Whenever a PocketChain has an event,
pretty early on - as part of PocketChain.stabilize
perhaps? - once we know if we're in DSP, we clear
UNSETTLED while going to DUMB if in DSP.

I guess we'd only have to set UNSETTLED if the
moving thing wasn't already DUMB.

But, another bit...[229:

Sun Oct  9 03:30:17 2022 The general issue is we
want pretty strong stability and control in the
DSPs, so we can produce reasonably reliable but
increasingly high-order values as the sequence
progresses. But we also want lots of slip joints
in the surrounding and supplying structures.

Well I'm thinking another bit. And I'm thinking go
to Sequencer19 before trying that.
[230:

Sun Oct  9 04:01:13 2022 Urgh here we are in
Sequencer19.[231:

Sun Oct  9 11:27:07 2022 So what might be the plan
here?

[232:

Sun Oct  9 13:16:05 2022 Opps got sidetracked
making the DEWLine renderGraphics more
discreet. (Ended up ditching the center box
entirely.) The high-frequency chatter from the
axis marks suffice.

We should try to 'finish' RS.
[233:

Sun Oct  9 14:13:57 2022 Well, now we're have RS
make a pair of 'anchored' SeedLoops in OUT and REG
once all the codons have been killed. We still
need it to then change the grip to roll itself out
of there, though - but in any case, we've got bugs
that cause it to roll back in and so forth, so
it's all quite the mess at this point.

Also, since SL isn't a Codon, RS will go ahead and
stick another SL into a pocket that's already got
one, and of course hilarity ensues.

[234:

Sun Oct  9 14:16:36 2022 But the bigger picture
for me right now is: Can we make a fake,
first-cut, phony 'Loader' to spew out some
'arbitrary' sequence of instructions? Like, a MK
followed by a Zn (for flavor) followed by a RS
(for punch).

If we could, we could start this crazy thing on
the grid and let it fire off loops then kill them.

Let's try to change the grip first, though.
[235:

Sun Oct  9 14:40:17 2022 Uhoh:

    20221009143344-3452: 6468AEPS [79BAF017]MSG: T[0,0]@S[47,74]: behave() failed at /data/ackley/PART4/code/E/MFM/src/core/include/UlamRef.tcc:440: STALE_ATOM_REF (site type 0x003F)
    20221009143344-3453: 6468AEPS [79BAF017]MSG: BACKTRACE  ->  0: MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::CheckEffectiveSelf() const + 0x11B
     ->  1: MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::GetEffectiveSelf() const + 0x1C
     ->  2: MFM::Ue_102619216DiamondSequencer10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_9212tryExecution(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Un_r10413359221DiamondSequencerState10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0xE2A
     ->  3: MFM::Un_10413359221DiamondSequencerState10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_3act(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Uq_r10118Intender10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) + 0x665
     ->  4: MFM::Un_1011919Intention10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_6pursue(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&, MFM::Ui_Uq_r10118Intender10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0x48C
     ->  5: MFM::Uq_10118Intender10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_9215pursueIntention(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0xAB7
     ->  6: MFM::Ue_102619216DiamondSequencer10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_6behave(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) + 0x85

Whatever it was, it killed the DS (and now the
spawned Demo loops are growing out of control.)
[236:

Sun Oct  9 16:04:21 2022 Well so far haven't been
able to catch another instance of that.

But encountered a different thing: Spawned loops
growing across quadrant boundaries and clogging up
a different quadrant. So I've now:

(1) Made PocketHC3.mDiamondSequencerCount so it's
    easy to tell if you're in a DSP, and
(2) Made Fc and Fs fail deploy if in a DSP

[237:

Sun Oct  9 16:07:39 2022 Now it's going again, and
I'm watching it while thinking about a Loader
codon.

Idea could be:

  LXLoader sits in INS. When it gets an event, it
  checks that it has two different ECs up and down
  stream of itself. If not, it waits. If so, it
  injects the next codon of the program its
  loading downstream of itself.

  When it has injected the last codon of the
  program, it grips for roll up (or whichever
  direction brings in the first codon loaded) and
  decays into an EC.

[238:

Sun Oct  9 22:28:14 2022 Trying to write the
'insert next instruction' section of Loader and
realized we have the reverse problem: Since we're
running during a DS event, we typically won't have
access to (either let alone) both our up- and
down-stream ngbs, so how do we check if they're
both ECs?

It seems like we need to do the loading while
we're cEXCT_PASV, and the ew is centered on us,
and then maybe just set a flag or something for
one IX when we're done?
[239:

Mon Oct 10 00:55:38 2022 Loader just loaded its
first instruction ever.

[240:

Mon Oct 10 01:21:13 2022 And then the rest of the
program, such as it is at the moment.

However, we haven't implemented the loader erasing
itself at the end! Let's go go go!
[241:

Mon Oct 10 01:55:49 2022 We're watching and
watching.. the program is loaded, and we're just
waiting for the Ld to reach IX, at which point
it's supposed to erase itself.. but the layout
heading downstream from INS is

 -> (EC) -> RS -> Ld ->

and it's never changing.

And the reason it.. RS is cDS_DUMB, so it will not
move when it's out-of-pocket..

And, why is the RS in cDS_DUMB?

I.. Don't.. Know.. Why... [242: Mon Oct 10 02:00:40 2022
Yes.. I.. Do.. Know.. Why..

Well, so here we are at last. We have achieved:

             THE FIRST BUG IN LX CODE
          IN THE HISTORY OF THE UNIVERSE

Yay us.

The instruction-to-be-loaded, in this case, is

    local constant LXReset  cINS13 = { .mDestUnit = DTypes.cPUNIT_INS };

which looks 'fine' as far as it goes.. 'mDestUnit'
is a currently unused data member that I initted
just to have something to check if we actually got
the loaded instruction, vs a new instance of
LXReset.

What's wrong with that instruction? Well, compare
it to the Zong instruction immediately prior:

    local constant Zong     cINS12 = { .mDSType = DTypes.cDS_NORM };

Hmm, the Zong got explicitly set to cDS_NORM. Oh
yeah, because the default value of mDSType is 0u,
which.. is.. cDS_DUMB.

Let's try this:

    local constant LXReset  cINS13 = {
      .mDSType = DTypes.cDS_NORM,
      .mDestUnit = DTypes.cPUNIT_INS };

and see how we do.
[246:

Mon Oct 10 03:22:36 2022 OK, started
recording..[247:

Mon Oct 10 03:59:52 2022 Well, had another bug -
made an Empty instead of an EmptyCodon when I
flushed the Ld doh - but then things started
'working', and I had a second recording going when
that happened.

So there's a ton ton ton still wrong with this,
but I'm going to push it to the keymaster anyway
and get a build going there. Oh god I'm going to
have to pull and rebuild MFM and ULAM there too,
and push a new MFM cdm as well as the physics?

It's going to take forever! And doh I could have
been doing the ULAM and MFM rebuilds HOURS AGO
DOH.
[248:

Mon Oct 10 04:04:20 2022 OK MFM build on keymaster
started. [249:

Mon Oct 10 04:14:24 2022 Still going. Think I
should headp off for a nap as soon as I start the
ULAM build..[250:

Mon Oct 10 04:28:52 2022 MFM build finished!
Starting ULAM.[251:

Mon Oct 10 04:29:41 2022 Oh crap. The keymaster
pulls from my D repos, not the E repos. Going to
have to pull to D, then FOGGEN START OVER.[252:

Mon Oct 10 04:33:58 2022 Starting over with
MFM.[255:

Mon Oct 10 05:06:36 2022 Keymaster MFM build
finished a bit ago; starting ULAM.[257:

Mon Oct 10 07:00:06 2022 Crap KM ULAM build ran
out of disk space. Cleared a bunch of old physics
dirs and going again.
[258:

Mon Oct 10 08:12:19 2022 It's run out of space a
couple more times now gah. Not sure what changed.

Switching the CFLAGS in ULAM/Makefile from -g2 to
-O99.[259:

Mon Oct 10 08:13:14 2022 Building Sequencer19 with
ulam -g2 took 8:13:07 - 8:09:35 ~= 3.5 min. Let's
try it with ulam -O99
[260:

Mon Oct 10 09:10:43 2022 Grand just grand grand
grand: Compiling ulam with -O99 causes g++ to
generate spurious array bounds warnings in MFM's
BitVector.h

I eventually got rid of the errors by doing

    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
          m_bits[idx] = (m_bits[idx] & ~mask) | ((value << shift) & mask);
    #pragma GCC diagnostic pop

in BitVector.h, and fuck you very much for that,
Mr Gcc.


[261:

Mon Oct 10 09:17:46 2022

It did make ulam a little faster:

09:12:40 - 09:09:37 ~= 3 min (vs ~3.5)

but that wasn't even the main point. The main
point was that ULAM's -g2 binaries on the
keymaster are so huge they keep blowing out the
disk


:261]
:260]

:259]

:258]
:257]

:255] Taking a nap now..[253:

Mon Oct 10 04:50:51 2022 Well, brain still kind of
running here.

 - SeedLoop11 (or whatever we're using here)
   should check the pocket properly and then
   diffuse w/in the pocket properly. Right now the
   OUT DSP won't seed a loop until after the
   diamond has moved west at least once, to get
   the SL11 into position where it can see its
   whole west pocket - because it's not diffusing,
   because it was doing stupid diffusion and could
   accidentally wander out of the DSP entirely.

 - Why can't we 'throw off' the mUpHopContour
   computation by one in the Y direction, during
   PocketQuadrant.init()?

[254:

Mon Oct 10 04:59:34 2022 Oh hey, wait a minute. We
were planning on having multiple DS in a single
grid. How's that possibly going to play with
target-quadrant-based loop growth control?

What if we built a short gradient away from the
nearest DS, and used the signs of the gradient
values to determine the quadrant RELATIVE TO THE
NEAREST DS?

HardCellG has 14 bits to burn, at the moment. If
we took 8 of them for

 Int(4) mDSOff[2];

[256:

Mon Oct 10 05:07:05 2022 we could have +-7 in X
and Y. I guess the problem is: When you have
conflicting saturated values coming at you in
multiple directions, how do you label yourself?

Maybe you don't label yourself, and you call that
space No Man's Land? Or Any Man's Land? And let
anybody grow there if they want to?

Now maybe nap.

:256]

:254]

:253]

:252]

:251]

:250]

:249]

:248]

:247]

:246]
[243:

Mon Oct 10 02:27:47 2022 Dammit I was going to use
obs to record mfms + my audio of this next trial,
since I think there's a chance it will 'work' (for
the very broken notion of 'work' I'm currently
using), but now obs seems all screwed up and I
think I have to reboot - even though Software
Updater is not saying 'You also need to reboot to
finish applying updates'.

But since we're under 36 hours to air, I think one
could say we really do need obs to work at this
point.

So, putting off the next loader trial until after
a reboot..
[244:

Mon Oct 10 03:06:39 2022 OK, rebooted and
re-set-up and obs appears happy again.[245:

Mon Oct 10 03:21:23 2022 And we checked and
corrected a bit of our audio routing and now just
tested that we have the mic and desktop audio and
clips all on different audio tracks in our
recording.

So let's try this..

:245]

:244]
:243]
:242]


:241]

:240]

:239]
:238]
:237]
:236]
:235]

:234]

:233]

:232]
:231]

:230]
:229]

:228]

:227]

:226]

:225]

:224]

:223]
:222]

:221]

:220]

:219]
:218]


:217]

:216]

:215]

:214]

:213]

:212]

:211]

:210]


:209]

:208]

:207]

:206]

:205]
[262:

Mon Oct 10 11:28:50 2022 OK, well, pushing
Sequencer19 to the keymaster to be the new af
physics.. We shall see.

:262]
[263:

Wed Oct 12 02:05:16 2022 So we're past t2sup3131
and I have some thoughts:

 - If we do the "mini-gradient-around-DS" idea, it
   seems like that could solve not only the
   "target quadrant slop" problem but also the
   "erroneously swapped while in a DSP" problem.

 - So the Quadrature.ulam stuff, which is just
   started, and not hooked-up to anything, could
   remove the need for Bool PocketChain.mArrived,
   which is also just started.

[264:

Wed Oct 12 03:05:35 2022 Although to be fair there
is a distinction: We could solve the "DSP
visibility" problem with just a 1D hop count, but
the "target quadrant" problem needs a 2D
coord.

But what about the trick of deriving quadrant from
multiple hop counts? We're already doing that for
the root.

So suppose we did like

  typdef Unsigned(3) DSHops;
  DSHops mHopsToDS;

? Having a say distance 6 exclusion zone around a
DS seems like plenty for target quadrant and DSP
visibility purposes.

Also seems like we really might be happy with a
refactoring to bring the existing mHops code under
a common support framework.

Something like:

 /** Base class to implement if you participate in
     any QHops gradients */
 quark QHoppers {
   //// QHoppers API
   virtual Bool hopsThisWay(ClassUtils.ClassId class) {
     return false;
   }
   virtual QHops & getQHops(ClassUtils.ClassId class) ;

   //// QHoppers SERVICES
   // TO COME: QHopsIterator
 }

 /** Base class of all single gradients */
 quark QHops {
   //// QHops API
   virtual Unsigned getHops() ;
   virtual Unsigned getMaxHops() ;

   //// QHops SERVICES
 }

 /** Base class for a single QHops data member */
 quark QHopsDM(Unsigned(5) cHOP_BITS) : QHops {
   typedef Unsigned(cHOP_BITS) HopCount;
   constant cMAX_HOPS = HopCount.maxof;
   HopCount mHopCount;

   //// QHops API
   @Override
   virtual Unsigned getHops() { return mHopCount; }

   @Override
   virtual Unsigned getMaxHops() { return cMAX_HOPS; }
 }

[265:

Wed Oct 12 04:22:39 2022 Hmm well that got pretty
complicated. But does it even work in principle?
We want concrete classes to be able to participate
in multiple QHops, but given the all-bases-shared
ulam inheritance design, that means that
individual distinct QHops have to be implemented
as data members. And that seems plausible:

quark QHopsFoo : QHopsDM(3u) { .. }
quark QHopsBar : QHopsDM(6u) { .. }

element MultiHops : QHoppers + Fail {
  QHopsFoo mFooHops;
  QHopsBar mBarHops;
  //// QHoppers API
  virtual Bool hopsThisWay(ClassUtils.ClassId class) {
    return class == QHopsFoo.classidof || class == QHopsBar.classidof;
  }
  virtual QHops & getQHops(ClassUtils.ClassId class) {
    if (class == QHopsFoo.classidof) return mFooHops;
    if (class != QHopsBar.classidof) fail(__FILE__,__LINE__);
    return mBarHops;
  }
}

but now how do we get mFooHops and mBarHops
actually updated?

[266:

Wed Oct 12 05:05:48 2022 So we want it to happen
like during stabilize (I imagine, pushing off to
another day any possible stabilization ordering
problems due to gradient interactions).

So it's like

element MultiHops : QHoppers + Codon /*, say*/ + Fail {
  @Override
  virtual ClassId getIntentionClass() { return MultiHopsState.classidof; }
..
}

transient MultiHopsState : CodonState {
 ..
  @Override
  virtual Bool stabilize(Intender & in) {
    if (super.stabilize(in)) return true;
    MultiHops & mh = (MultiHops&) in;
    if (in.mFooHops.stabilize(self)) return true;
    if (in.mBarHops.stabilize(self)) return true;
    return false;
  }
}

and I guess QMHopsDM needs some stuff like

..
 quark QHopsDM(Unsigned(5) cHOP_BITS) : QHops {
   typedef Unsigned(cHOP_BITS) HopCount;
   constant cMAX_HOPS = HopCount.maxof;
   HopCount mHopCount;

   Bool stabilize(QHopsState & qhs) {
    ..
   }

But wouldn't we rather want to centralize the
stabilization? In particular, so we could do one
ew iteration and have everybody do their minning
or maxing or however their particular gradient
propagates?

With this scheme every hop count is going to
reenumerate the ew during their own private
stabilize?

I guess that means we'd have to break it down to
some kind of visitor pattern:

  QHoppers.stabilize(..) {
    QHopIterator qhi;

    // INIT QHOPSDMS
    qhi.init(..);
    while (qhi.hasNext()) {
      QHopsDM & qhd = qhi.next(); // need to be QHopsDMState?
      qhd.init(..);
    }
    for (SN sn : ) {
      Atom & a = ew[sn];
      if (a as QHoppers) {
        // VISIT QHOPSDMS
        qhi.init(..);
        while (qhi.hasNext()) {
          QHopsDM & qhd = qhi.next();
          qhd.visit(.., a);
        }
      }
    }

    // UPDATE QHOPSDMS
    qhi.finish(..);
    while (qhi.hasNext()) {
      QHopsDM & qhd = qhi.next();
      qhd.update(..);
    }
  }

[267:

Wed Oct 12 15:31:05 2022 I guess we'd want like

 /** Base class to implement if you participate in
     any QHops gradients */
 quark QHoppers {
  ..
  //// QHoppers SERVICES

 }

 transient QHoppersState : ?? + Intention {
   //// Intention API
   Bool stabilize(Intender & in) {
   }

 }

  }

[268:

Thu Oct 13 00:26:35 2022 Well, I guess it's not
(yet) clear how or if we should be able to merge
hop counts for say PocketChain with say HardCellG.

That would mean abstracting over site visiting as
well as gradient visiting. And do we think we
could get that clean and functional with the
time and language tools available?

So what if we focus just on hardcellg for now?
That's our immediate use case: Supporting multiple
gradients with different semantics simultanousely
within HC3.

So what does that mean we can assume?

 - All gradients are over and betwee HC3 ngbs

 - We'll update all gradients in parallel
   spreading out from ew[0]

 - We'll derive an 8-wind compass rose based on on
   direction to local min?

 - We'll derive 4 quadrants + none from that
   = Or, four overlapping quadrants w/<= and >=?

[269:

Thu Oct 13 00:51:30 2022 Do we get to assume
they're all hop-count-based? Meaning minngb+1?

Will this system be initially applied to mHops
itself? With all the tweaks like down-settled-hops
and everything? That's a terrifying prospect.

So if not, that means one separate ew iteration to
do all the QHops gradients, in addition to the ew
iteration that just does mHops?
[270:

Thu Oct 13 01:11:14 2022 I guess so. I'm certainly
not breaking into QHardCell.update(QHCS&) without
a tried and true alternative already in hand.

[271:

Thu Oct 13 03:19:05 2022 (So I turned off custom
graphics on the t2 grid and it appears things are
running visibly faster. Going to accumulate some
data to see it in the timelapse but I'm betting
that's a main issue.)
[273:

Sat Oct 15 01:39:40 2022 I('m pretty sure I) found
the actual issue with the custom graphics display!
I had this:

      void SDLI::onTimeout(TimeQueue& srcTQ) {
        insert(srcTQ, REDISPLAY_MS,0);
        checkInput();
        redisplay();
      }

but it really wanted to be this:

      void SDLI::onTimeout(TimeQueue& srcTQ) {
        checkInput();
        redisplay();
        insert(srcTQ, REDISPLAY_MS,0);
      }

so that we don't hog the priority queue if
redisplay() takes more than REDISPLAY_MS.

And we really really don't care about getting a
tight tolerance on the timing of the redisplay()
calls!

I also went from this

  static const double REDISPLAY_HZ = 6;
  static const u32 REDISPLAY_MS = (u32) (1000/REDISPLAY_HZ);

to this:

  static const double REDISPLAY_HZ = 3;
  static const u32 REDISPLAY_MS = (u32) (1000/REDISPLAY_HZ);

because that shows signs of life frequently
enough, and:

We only grab one image every five seconds anyway!

:273]
:271]

:270]
:269]

:268]


:267]:266]

:265]
:264]

:263]
[272:

Sat Oct 15 01:39:05 2022 Starting Sequencer210 to
do a gradient around DS for targetting and
settling.
[274:

Sat Oct 15 01:46:28 2022 And I'm just going to
implement it directly by hand. No QHopper no
subclass iterators no nothing.

DO WE HAVE THREE BITS TO STEAL IN DS?
[275:

Sat Oct 15 02:28:22 2022 WE DO.

(Got side-tracked pulling changes from the
keymaster back into the T2Demos repo, here.)

We're currently at:

      | COMPONENTS of DiamondSequencer <77> (61 bits/10 unused):
      |
      | Pos	| Bits	| Name	| Type <classid>
      | 0	| 8	| mProcUnitMap	| QProcUnitMap <78>
      | 8	| 8	| mDirStatusMap	| QDirStatusMap <79>
      | 16	| 28	| super	| QHardCellG <97>
      | 44	| 0	| base	| Fail <45>
      | 44	| 0	| base	| UrSelf <0>
      | 44	| 8	| base	| DEWLine <86>
      | 52	| 0	| base	| DTypes <43>
      | 52	| 8	| base	| QHardCell <100>
      | 60	| 0	| base	| Intender <80>
      | 60	| 1	| base	| QDebugUtils <44>
      |___________________________________________________

and QHardCellG is at

      | COMPONENTS of QHardCellG <97> (45 bits/19 unused):
      |
      | Pos	| Bits	| Name	| Type <classid>
      | 0	| 4	| mHardCellWatchdog	| XTimer(4,10u,250u) <56>
      | 4	| 5	| mMaxHops	| Unsigned(5)
      | 9	| 5	| mUpHops	| Unsigned(5)
      | 14	| 5	| mSettledDownHops	| Unsigned(5)
      | 19	| 9	| mColor[3]	| Unsigned(3)
      | 28	| 8	| super	| QHardCell <100>
      | 36	| 0	| base	| UrSelf <0>
      | 36	| 8	| base	| DEWLine <86>
      | 44	| 0	| base	| DTypes <43>
      | 44	| 0	| base	| Intender <80>
      | 44	| 1	| base	| QDebugUtils <44>
      |___________________________________________________


so we could kill mColor and get nine more bits if
we wanted.

So we're going to make

 typdef Unsigned(3) DSHops;
 DSHops mDSHops;

in QHardCellG.
[276:

Sat Oct 15 03:02:20 2022 OK now it's

  | COMPONENTS of QHardCellG <97> (48 bits/16 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 4	| mHardCellWatchdog	| XTimer(4,10u,250u) <56>
  | 4	| 5	| mMaxHops	| Unsigned(5)
  | 9	| 5	| mUpHops	| Unsigned(5)
  | 14	| 5	| mSettledDownHops	| Unsigned(5)
  | 19	| 3	| mDSHops	| Unsigned(3)
  | 22	| 9	| mColor[3]	| Unsigned(3)
  | 31	| 8	| super	| QHardCell <100>
  | 39	| 0	| base	| UrSelf <0>
  | 39	| 8	| base	| DEWLine <86>
  | 47	| 0	| base	| DTypes <43>
  | 47	| 0	| base	| Intender <80>
  | 47	| 1	| base	| QDebugUtils <44>
  |___________________________________________________


[277:

Sat Oct 15 07:17:30 2022 OK implemento let's GO

:277]

:276]
:275]
:274]
:272]
[278:

Sat Oct 15 07:49:21 2022 Putting it in
PocketChain.updateGradients(..). Going ahead of
the existing stuff to avoid figuring out its
exits, I guess.

[279:

Sat Oct 15 07:52:10 2022 Oh wait that's not right!
PocketChain is 1D doh mDSHops is about HC3. Jeez.

So the point is there's no pulled-out
gradient-named method for the hc3 gradients. [280:

Sat Oct 15 07:54:22 2022 OK now we're starting to
clue up sheesh: Make new fields like

 HC3State

Unsigned HC3NgbState.mDSHops = Unsigned.maxof;

[281:

Sat Oct 15 09:53:03 2022 OK debugging mDSHops
propagation. Have DS 0-ing it and others
propagating it.. except the root was also 0.
[282:

Sat Oct 15 09:55:23 2022 OK root != 0
  dshops..[283:

Sat Oct 15 10:12:49 2022 OK all seems to be
updating okay. Can we put in a color mod to see
this gradient a little?
[284:

Sat Oct 15 10:55:01 2022 Well I tried to put in a
blue shift for DS proximity, on Atom #2, but with
all the minsettleddown flashing it's hard to
really detect the DS. But the DS gradient exists,
and I've used a new MakeDS element to put multiple
DS in a single diamond, and the interacting
gradients look fine.

So.

Can we move target quadrants over to the DS
gradient? That should be a good next step.
[285:

Sun Oct 16 00:54:14 2022 OK current issue is we
need to start deciding what to do when the DSHops
gradient runs out. I could imagine callers might
want to not grow, or grow wildly, under such
conditions, but the current code has no provision
for reporting the distinction between not having a
quadrant due to out of range (the new case) vs
bent pocket or whatever (old cases).
[286:

Sun Oct 16 01:41:44 2022 OK, right now it looks
like Fc and Fs are unwilling to grow outside of
target quadrant range, which makes sense.. Can we
switch it to they can always grow outside TQR and
see how it looks?

[287:

Sun Oct 16 01:44:57 2022 Seems like only a change
in SfCorner, at least given the development so
far. Not sure it's likely or 'possible' for Sf and
Fc both to be in the TW but Fs not.. We'll see.

:287]

:286]
:285]
:284]

:283]

:282]

:281]
:280]

:279]

:278]
[288:

Sun Oct 16 11:24:43 2022 OK, so I think it's about
time to move on to redoing like isSwappable to
take mDSHops into consideration, and see what's
what!
[289:

Sun Oct 16 13:21:19 2022 OK, so I made
PocketChain.isSwappableInContext(..) consider
mDSHopContour:

      virtual Bool isSwappableInContext(PocketChain & pc) {
        PocketHC3 & p = mPocket;
        PocketQuadrant & pq = p.mPocketQuadrant;
        Bool indspocket = pq.mDSHopContour == 1u;
        return !indspocket;
      }

and now none of the streams are growing. Which is
mostly a problem for IX, since failure to grow
there means the loader can't load.[290:

Sun Oct 16 13:28:36 2022 There's an issue about
asking whether we ourselves are swappable when the
problem is the thing we're considering swapping
with. We could infer if our ngb is in a pocket
from our mDSHopContour + the pocket dir to ngb, I
suppose.. [291:

Mon Oct 17 01:31:18 2022 OK now thinking the
entire isSwappable concept is broken. Don't we
really have to be asking whether a PAIR
isSwappable, not a single Codon? Or at least we
have to say whether we mean to swap upstream or
downstream.

Maybe that's the way.

  virtual Bool PocketChain.isSwappable(PocketChainState & ds, Bool upstream)

  virtual Bool PocketChainState.isSwappableInContext(PocketChain & pc, Bool upstream)

[292:

Mon Oct 17 05:39:44 2022 Urgh started implementing
that but the code is really set on having
swappability be a property of a single Codon. Is
it really the way?

[293:

Mon Oct 17 06:29:03 2022 It's kind of a mess
because swappability kind of is a single codon
property even in a DSP, but we confidently assess
the mDSHopsContour only for the 'self' pocket of
an event.

[294:

Mon Oct 17 06:51:07 2022 How many places are using
isSwappable?

ChainRule.ulam: isX
SfCorner.ulam, SfSide.ulam: declare self unswappable
ShapeShifter.ulam: decay if can't adv due to downstream unswappabilitiy
ShapeShifter.ulam: declare self unswappable during WAIT intentions
PocketChain.ulam: check mDSType cDS_DUMB
PocketChain.ulam: updateGradient says unswappability -> anchor
PocketChain.ulam: actMovingSeg checks ngb.isSwappable(ds)
                  before swapping <- with ngb NOT ew[0]

[295:

Mon Oct 17 07:08:37 2022 That appears to be
  it.[296:

Mon Oct 17 09:28:09 2022 I guess if we were
willing to check the underlying SN of a
PocketChain&, we could:

(1) Determine if it's in ew[0]. If so, then use
    the mDSHopContour to determine swappability
(2) Otherwise it's in ew[sn]. Use

[297:

Mon Oct 17 12:17:16 2022 OK come on. Suppose we go
by PocketPtr, like:

  Bool PocketHC3.isDSP(PocketPtr ptr)

[298:

Mon Oct 17 14:15:22 2022 Well, we made that and
got back to runnability, but we're not calling it
anywhere yet. Current issue, which I think will
persist even when we do call it, is Sf doesn't
seem willing to spawn when the ngb is in DSP?
[299:

Tue Oct 18 06:32:14 2022 OK well going to nap, but
current status is:

 - As we tighten up controls on the DSPs, it
   becomes unclear, and necessary to clarify,
   exactly how we plan to boot loops.

Right now, we put in an initial Sf, but it decays
without even trying to spawn, and we're left with

  EC <=> X

(for X = {LD, MK} depending on DSP) and nothing is
forthcoming.
[300:

Tue Oct 18 11:36:45 2022 So, how do we boot loops?
Maybe instead of trying to use Sf, which is a
general roving grower, we should have like a
LoopBuilder inverse of the LoopKiller, that
actually extends as a strand instead of a loop,
but which we can guide to come back around and
close on itself if we want.

What's the status of our SwapWorm-ish code? All
long rotted I'm sure, but..[301:

Tue Oct 18 12:04:49 2022 Well, SwapWormHC3.ulam
exists, and we can plop down an instance of it in
a pocket, but it seems to just sit there..[302:

Tue Oct 18 12:05:58 2022 So, QSwapWormHC3 inherits
from.. nothing.. that's how old that code is.[303:

Tue Oct 18 12:06:43 2022 Aha, it appears SW only
wants to go west. But indeed I stuck it in a
pocket whose west is open..[304:

Tue Oct 18 12:09:12 2022 Well, now it's bouncing
around between like two or three pockets, without
leaving anything behind or just heading west or
anything.. so I think this SW is an obsoleted WIP
at best..
[306:

Wed Oct 19 02:09:55 2022 Let's make a more modern,
from-scratch SwapWormHC3 to get going here.

[307:

Wed Oct 19 12:19:29 2022 So we made four SW3
states:

      typedef Unsigned(2) SWST;
      constant SWST cSWST_ALONE =  0u; // have neither body_down and _up
      constant SWST cSWST_MIDDLE = 1u; // have body_down and _up
      constant SWST cSWST_TAIL =   2u;   // have only body_up
      constant SWST cSWST_HEAD =   3u;   // have only body_down
      SWST mSWST;

and what-all do we think about with them?

 - do RingO sync between head and tail

 - send commands from tail to head

 - and return status from head to tail?

but do we even need RingO if it's 1-1 all the way?
Just copy upstream bits upstream and downstream
bits downstream, and let head set the downstream
bits and tail set the upstream bits.

So what are the bits?

    SHRINK      // by one segment
    DIE         // all the way back to nothing

    GROW axialdir
or
    GROW axialdirmap

    BECOME codontype // replace self preserving links
    REPLACE elementtype // shrink and deposit

[309:

Thu Oct 20 08:07:39 2022 Well, so implementing
SW3Packet.execute(..) and running into some thinko
issues. In particular:

(1) The first command I'm doing is 'DIE' all the
    way back to nothing.

(2) I was triggering execute(..) calls when
    upsignal (to head) or downsignal (to tail)
    changes were encountered.

(3) But when head erases itself on a DIE, there
    seems to be no clean way to get the downstream
    (the newly-anointed head) to trigger on the
    DIE in turn, because its upsignal isn't
    changing.

So I'm thinking maybe we shouldn't be triggering
on (single) signal changes. To be
self-stabilizing, we should trigger on the current
relationship between upsignal, downsignal, and
head/tail status, regardless of how they came to
be. Then the new head could respond properly to
DIE when it becomes the new head - at least if the
old head sets its downsignal appropriately, which
at least is kind of its business.

[310:

Thu Oct 20 08:24:13 2022 So this may prove to be a
pink bathtub ring strategy, but let's push down
this road.
[311:

Thu Oct 20 08:41:04 2022 The idea I'm guessing is
to exploit the so-far-unused SW3Packet.mCmdStatus
field. The difference between cCMST_DO and any of
the other three states.. When a signal arrives
it'll (at least typically) be cCMST_DO - meaning
it is a command, in that context. When a head
reacts to a rising _DO, it will set its downsignal
to _DID, _TRYING, or _CANT as appropriate to the
situation.

And if head's up and down signal are identical
except for the mCmdStatus, I guess that's stable?

I guess maybe like early on, during
stabilization?, head copies the signal and sets
_TRYING, but then later during act (even in the
same event) it tries to accomplish the command,
possibly changing to _DID or _CANT as appropriate
to its findings, or remaining in _TRYING so that
it will go again next time.
[313:

Thu Oct 20 13:07:10 2022 OK, well made a
disgusting hack in SW3Packet.killSeg(..) to push
the (dying) head's upsignal down to the (about to
be become) head.. and then our two-SW3 chain
responded to cSW3C_DIE as desired.

:313]
[312:

Thu Oct 20 08:58:00 2022 About to head out for
events of the day, but there's a remaining
question of what if a rising signal is not _DO? We
can ignore them for now, I guess, or fail, for
that matter, but it does seem that going to
_TRYING is a response to _DO and nothing else.

If one day we get to bidirectional command and
response, we'll deal with it then.

:312]

:311]

:310]


:309]
[308:

Wed Oct 19 16:28:45 2022 I think we have plenty of
bits at the moment --

      | COMPONENTS of SwapWormHC3 <164> (30 bits/41 unused):
      |
      | Pos	| Bits	| Name	| Type <classid>
      | 0	| 1	| mUpStatus	| Bool
      | 1	| 1	| mDownStatus	| Bool
      | 2	| 0	| super	| Codon <49>
      | 2	| 0	| base	| UrSelf <0>
      | 2	| 0	| base	| DTypes <45>
      | 2	| 0	| base	| Intender <83>
      | 2	| 19	| base	| PocketChain <10>
      | 21	| 2	| base	| PocketChainTQ <134>
      | 23	| 0	| base	| Pocketable <142>
      | 23	| 1	| base	| QDebugUtils <46>
      | 24	| 6	| base	| Segment <51>
      | 30	| 0	| base	| Sequenceable <85>
      |___________________________________________________


so what about like 16 up and 16 down?


:308]

 :307]
:306][305:

Tue Oct 18 13:10:46 2022 Moving the flag.

:305]

:304]

:303]

:302]

:301]

:300]

:299]

:298]

:297]

:296]

:295]

:294]

:293]

:292]

:291]

:290]

:289]
:288]
[314:

Fri Oct 21 15:52:32 2022 So: I think we're up to
implementing some more operations for the
SWHC3. What do we have on the list?

DONE  constant Cmd cSW3C_NOOP =    0u; //< successfully do nothing
[323: Sat Oct 22 01:38:10 2022
DONE :323]      constant Cmd cSW3C_SHRINK =  1u; //< delete current head
      constant Cmd cSW3C_GROW =    2u; //< ?
      constant Cmd cSW3C_BECOME =  3u; //< ?
      constant Cmd cSW3C_REPLACE = 4u; //< ?
DONE  constant Cmd cSW3C_DIE =     5u; //< delete whole SW from the head

Let's try SHRINK. That should be like DIE but
easier.. [315:

Fri Oct 21 15:55:21 2022 Well, I think we already
did SHRINK, we just didn't make an injector for
it. So now trying an I1 injector for shrink (after
renaming the die injector to I5 to track its op#).
[316:

Fri Oct 21 15:59:23 2022 OK here's an issue to
fix: Neither I1 nor I5 work when the SW is a
single atom.
[317:

Fri Oct 21 16:29:33 2022 OK it seems the issue is,
when we inject the thing directly into upsignal,
it's in CmdStatus _DO, but we don't actually
execute it unless it's in _TRYING. But as the
head, it should figure that out, and copy to
downsignal with state _TRYING, right?[318:

Fri Oct 21 16:32:11 2022 OK, both places that set
_TRYING only do it if there's an up or down
link, as part of copying a signal. They don't do
it as a standing thing.

But maybe they could? Whether or not we copy the
signals, we could then check for

   ishead+up_DO->up_TRYING
and
   istail+down_DO->down_TRYING

?
[319:

Fri Oct 21 16:35:40 2022 OK trying that.[320:

Fri Oct 21 16:47:50 2022 Oops, when orig head does
shrink it has to mark it DONE in the new head, or
else shrink is the same as die.[321:

Fri Oct 21 16:56:48 2022 OK looks like _SHRINK
might be working. Hmm is _DIE still okay?[322:

Fri Oct 21 16:57:41 2022 Yup, _DIE still seems
okay. Time to break for cooking..

:322]

:321]

:320]

:319]
:318]

:317]
:316]

:315]

:314]
[324:

Sat Oct 22 04:17:05 2022 OK we've got some thinkos
here still, in signal propagation stuff.[325:

Sat Oct 22 04:20:32 2022 We copy mUpSignal from
downstream unconditionally, during
SwapWormHC3State.stabilize(..). Then later it's

  SwapWormHC3State.act(..) ->
  SwapWormHC3.actUp(..) ->
  mUpSignal -> SW3Packet ->
  SW3Packet.execute(..)

and those last two lines can't be right, because
it goes to execution based solely on the
upSignal.

We thought it was going to be like:

 in head,
  if upsignal is _DO then
    if downsignal matches upsignal
       except it's
         _TRYING -> try it
         _DID    -> ignore it
         _CANT   -> ignore it
    else // downsignal doesn't match upsignal
      down = up
      down = _TRYING
      (do the above)

[326:

Sat Oct 22 05:34:11 2022 Redo:

 in head,
  if upsignal.mCmdStatus == _DO then
    if !downsignal.matchCore(upsignal)
      down = up
      down = _TRYING
    // now downsignal.matchCore(upsignal)
    which (down.mCmdStatus) {
       _TRYING -> try it (& maybe chg to _DID or _CANT)
       _DID    -> ignore it
       _CANT   -> ignore it
    }

[327:

Sat Oct 22 09:48:18 2022 OK, redid along those
lines and _GROW is starting to work, and be
incremental and so on. But _SHRINK has turned back
into _DIE so let's look at that now.
[328:

Sat Oct 22 11:06:34 2022 Oraitee: _GROW, _SHRINK,
and _DIE all look plausible. Let's go for _PLACE
[329:

Sat Oct 22 11:28:03 2022 Wow, so _PLACE kind of
worked first time. We're only placing Walls atm.

[330:

Sat Oct 22 11:34:43 2022 Seems like it may be time
to switch to debugging/rethinking the loader
growth situation, so we might have a shot at
programming one of these things.

[331:

Sat Oct 22 11:39:55 2022 Also, while I'm thinking
about it, what something that runs down an SW3
chain. Except if the thing did the running itself
that ties up its function.. What if we had like a

  cSW3C_CONVEY

command or something that took a classid and
everybody in the chain that finds that classid in
their pocket tries to move it upstream?

or both
  cSW3C_DELIVER
  cSW3C_RETURN

to send arbitrary stuff up or downstream? Now, the
'stuff' needs enough clue not to leave the pocket
in transit, but maybe that's not a horrible
restriction.

[332:

Sat Oct 22 11:57:03 2022 But anyway, let's try to
bring fresh eyes to the Ld/Sf situation..
[333:

Sat Oct 22 12:01:20 2022 Where are we, there?[334:

Sat Oct 22 12:01:42 2022 heh :300: above goes from
the Sf problem straight to SwapWorm in one note..

So let's ask again: How Do We Boot A Loop?

Desired features:

 - Grow to at least size three (which means four)
   and have two ECs before loop-booting is done

 - Be able to include a single non-EC in a booted
   loop

 - Be clean and cute like kittens in sunshine
[335:

Sat Oct 22 15:28:40 2022 What if we draft a flag
for Sf meaning 'first mover' or something? That
would have basically one meaning: Don't decay if
you can't advance. The idea would be to circumvent
the decay-is-okay-since-respawn assumption build
into Sf.

Or go the other way? Have a rule that will spawn
an Sf from a single EC if that EC is doubly-linked
to a DUMB codon?

[336:

Sat Oct 22 15:45:15 2022 Looks like Sf *will* swap
out an X in a DSP? Didn't trace that down, but it
was a lifeline after the only EC got into a DSP.
[337:

Sat Oct 22 16:56:28 2022 Yikes it appears that
Pocketable.findAvailables is/was no longer getting
called on the Sf execution path? So all the
mPocketIterable[]s are false and etc etc? That
could account for a lot of bad behavior..

Stuck

    Bool fa = findAvailables();
    print(fa);

into ShSfState.init(..). We'll see.
[338:

Sat Oct 22 17:03:24 2022 Still no big change.. But
there's this currently intermittent thing where
the target quadrant ends up 0 when it should be 2,
and that's what's happening in this last test.

Break for evening but that's where we pick
  up.[339:

Sat Oct 22 20:02:10 2022 When L1s diffuse, they
lose their target quadrant? That's what I'm
seeing?[340:

Sun Oct 23 07:48:09 2022 Well, I think as my
likely last real go before t2sday, I'm going to
just completely tear out isSwappableInContext,
see what breaks, and then start putting in more
focused stuff based on PocketHC3.isDSP(PocketPtr)
and see how far I can get.

Moving on to Sequencer212/

[341:

Sun Oct 23 07:53:42 2022 And here we are in
Sequencer212/.[342:

Sun Oct 23 08:01:13 2022 And isSwappableInContext
is now cut or commented
throughout. Building..[343:

Sun Oct 23 08:10:29 2022 Well, to first order,
things are working, and 'working better' in the
sense that we have our program getting loaded
again, although of course it's as messy as we
remember (and have been watching on the grid).

[344:

Sun Oct 23 08:51:19 2022 OK let's start it again
and find the first thing -- as far as movement in
or out of a DSP -- that we don't like.[345:

Sun Oct 23 08:52:32 2022 OK, first thing is: When
the L1 in the X DSP pops, it puts an Sf in the
pocket and the Ld not. If we were going to try to
control the Ld position right from the start,
that's not what we want, right?
[347:

Sun Oct 23 09:02:53 2022 So, for the record:

 - L1 is SeedLoop11, and
 - it has mClassId to specify what to build, and
 - mSeedDir, to specify which direction to extend.
 - and a linear Unsigned(3) counter to delay.

it goes to attemptMakeLoop .. ah and the key is
attemptMakeLoop leaves modifying ew[0] up to the
caller, and just makes the given classid off in
the mSeedDir side pocket.

Then L1 goes to cvtECToSf(ctrsn), changing the (in
this case) DSP codon to an Sf.

We could reverse all that, one would think. We
could have attemptMakeLoop always make two ECs,
and return both SNs affected - one in the caller's
pocket and one in the mSeedDir side pocket. And
then caller transmutes either or both of them
however caller wants.

Let's do that, to get us going here if nothing
else.
[348:

Sun Oct 23 09:42:13 2022 Building that..[349:

Sun Oct 23 09:47:39 2022 OK, that looked pretty
good. The Sf was in the outpocket, and it spawned
and we got a 3 EC + Ld loop with the Ld still in
the X DSP.

And then the Ld swapped itself out of that
position.. Why did it do that?

Now, one question is what proc status does the DS
get created in? Now that we're starting to control
stuff that's clearly going to matter during a DS
bootseq.[350:

Sun Oct 23 09:52:20 2022 Yeah, like I thought:

    element SeedSeq : XTimer(3u,6u,4u) + DTypes + QDebugUtils {
 ..
        DiamondSequencer ds;
        ds.mDirStatusMap.randomizeIdles();
 ..

ding ding ding..[351:

Sun Oct 23 09:58:17 2022 OK took that out, and now
we're starting up 'clean' in procstatus.

In the test run, it was a downstream EC that
swapped the Ld out of the X DSP. And that's just
the sort of thing that we want isDSP(..) to
affect.

So I guess, let's see another instance of this,
and track down exactly where that swap decision is
getting made?[352:

Sun Oct 23 10:06:53 2022 OK got one
instruprinted.

First stop: CodonState.freeStab(Codon&) found a
match. Working backward.[353:

Sun Oct 23 10:11:08 2022 OK, so

    20221023100646-3754: 52AEPS [E600A257]MSG: print: "CRFPM11"
    20221023100646-3755: 52AEPS [E600A257]MSG: print: Unsigned: 3

CodonState.pickMatch() chose rule 3 (from among
however many rules matched.

How did rule 3 get matched?

[354:

Sun Oct 23 10:12:55 2022
ChainRulesFreeStab.matchAll iterated through its
rules, starting thusly:

    20221023100646-3450: 52AEPS [E600A257]MSG: print: "CRFMA10"
    20221023100646-3451: 52AEPS [E600A257]MSG: print: "CRFMA11"
    20221023100646-3452: 52AEPS [E600A257]MSG: print: Unsigned: 0

. The first rule (index 0) failed:

    20221023100646-3508: 52AEPS [E600A257]MSG: print: "CRFMA1110"
    20221023100646-3509: 52AEPS [E600A257]MSG: print: Unsigned: 0
    20221023100646-3510: 52AEPS [E600A257]MSG: print: Bool(3) 0x0 (false)

. So did index 1:

    20221023100646-3568: 52AEPS [E600A257]MSG: print: "CRFMA1110"
    20221023100646-3569: 52AEPS [E600A257]MSG: print: Unsigned: 1
    20221023100646-3570: 52AEPS [E600A257]MSG: print: Bool(3) 0x0 (false)

and 2

    20221023100646-3628: 52AEPS [E600A257]MSG: print: "CRFMA1110"
    20221023100646-3629: 52AEPS [E600A257]MSG: print: Unsigned: 2
    20221023100646-3630: 52AEPS [E600A257]MSG: print: Bool(3) 0x0 (false)

. But index 3 matched:

    20221023100646-3688: 52AEPS [E600A257]MSG: print: "CRFMA1110"
    20221023100646-3689: 52AEPS [E600A257]MSG: print: Unsigned: 3
    20221023100646-3690: 52AEPS [E600A257]MSG: print: Bool(3) 0x7 (true)

. And index 4 did not match, fwiw, so 3 was our
unique winner here. And what is rule 3 here?

      ChainRule_SPREAD10 s10;
      ChainRule_SPREAD11 s11;
      ChainRule_COMPACT10 c10;
      ChainRule_COMPACT11 c11;
      ChainRule_LONEEMPTY l10;
      ChainRule & getRule(Unsigned i) {
        if (i >= crms.lengthof) fail(__FILE__,__LINE__);
        which (i) {
          case 0u: { return s10; }
          case 1u: { return s11; }
          case 2u: { return c10; }
          case 3u: { return c11; } <<<<<

It's ChainRule_COMPACT11.[355:

Sun Oct 23 10:21:01 2022 Which says in part:

    /** CHAINRULE: COMPACT11: EC0 -> [EC1] -> X  ==>  EC0 -> [X] -> EC1 */
    transient ChainRule_COMPACT11 : ChainRule {

which, if we're to believe the comment, is that if
we're EC and we have an upstream EC and a
downstream X, we should swap with the downstream
X. Is that happened in this case?
[356:

Sun Oct 23 10:23:00 2022 No, it appears what we
had was:

    Ld -> EC1 -> EC2
to
    EC1 -> Ld -> EC2

where '->' means 'points downstream'. Is that what
I meant it to mean? Maybe it means 'point
upstream'? Checking..[357:

Sun Oct 23 10:27:08 2022 So the discussion in
:227:-:228: above is totally relevant. Some
points:

(1) It's discussing COMPACT10 the very rule we're
    looking at now.
(2) I can't immediately tell if it was assuming
    '->' means downstream or not.
(3) It highlights the need for isDSP to work in
    terms of a pocketptr rather than a Codon& or
    the like.
(4) Given a rule, we're going to have to interpret
    the pattern codes in terms of their pocketptr
    directions relative to the match [center], and
    somehow ask isDSP on those pocketptr
    directions.

Continuing back in time on '->' interpretation
though.
[358:

Sun Oct 23 10:33:24 2022 :158: above brings up the
same issue about DSP and COMPACT.[359:

Sun Oct 23 10:41:52 2022 OK shifted to searching
for '->' from the top, and in :77: we get to this:

     FOR cDSTATUS_UPWD: //< Needs roll toward body up (temp down)
          (1) if reachable layout is   T -> [X] -> Y
              switch to                X -> [Y] -> D
              and set _IDLE

which suggests -> is pointing upstream, not
down. From the point of the DSP, its content
shifts from X to Y. If that's a movement 'toward
body up', that means Y is upstream of X, right?

(:82: above uses same approach, consistent with
'->' meaning 'points upstream'.)

[360:

Sun Oct 23 10:48:10 2022 OK. So. How do we rework
the plumbing to get isDSP awareness into the
matching?

First question: In matching, does the pattern
center always and necessarily correspond to the
cPP_SELF pocket?[361:

Sun Oct 23 11:00:42 2022 Apparently a ChainRule
pattern always consists of three
MatchCodePositions, in order:

  constant MatchCodePosition cMCP_PREV = 0u;
  constant MatchCodePosition cMCP_HERE = 1u;
  constant MatchCodePosition cMCP_NEXT = 2u;

but hmm, in ChainRule.codeAt(..) there's this
disturbing comment:

    case cMCP_HERE: {
      print("CRMCDAT12");
      sn = ss.mEWSNSegment; // WON'T BE 0 ON INDIRECT ACTION
    }

but sitting here now, we're wondering if that

 - currently ever happens
 - really needs to happen
 - is always in cPP_SELF even if it does happen

Suppose we put a fail in there for now.[362:

Sun Oct 23 11:17:42 2022 Did that to no
immediately apparent change.

So, leaving the code like this for now:

      sn = ss.mEWSNSegment; // WON'T BE 0 ON INDIRECT ACTION
      if (sn != 0u) fail(__FILE__,__LINE__); // CHECK THAT ^^ COMMENT

and we're going to assume that cMCP_HERE is

(1) Always referring to cPP_SELF, and
(2) If it matters, specifically it's ew[0];
[363:

Sun Oct 23 11:23:56 2022 So, that
ChainRule.codeAt(..) is referring to
SegmentState.mEWSNMate[..] and
SegmentStae.mEWSNSegment, which require its
.findMates to have succeeded (which makes sense
for chain matching), so we have all that at our
disposal.

Question now is: Is there a place we can (or do)
store either the relevant pocketptrs, or perhaps
the resulting DSP status itself, to standardize
checking it downstream?[364:

Sun Oct 23 11:32:02 2022 Ah well, there's already

 PocketPtr SegmentState.mPocketWithMate[Segment.cBODY_DOWN+1u]

which appears to be exactly the former there, that
findMates appears to set up.

[365:

Sun Oct 23 11:35:23 2022 OK pop pop. ChainMatches
might be a place to store that information,
possibly? [366:

Sun Oct 23 11:36:00 2022 Ah, no, ChainMatches is
just a typedef for SN[3]: No room at that inn.

And ChainPattern is ChainType[3].

[367:

Sun Oct 23 11:38:33 2022

Bool ChainRule.matches(PocketChainState & ss, ChainPattern pat, ChainMatches & m)

does the main work (unless overidden, I
guess..). I suppose we could make a

  typedef Bool ChainDSPs[3];

and add that to the args..[369:

Sun Oct 23 11:43:58 2022 We could pass a 'Bool
isDSP' to isCodeAt(..) and check it somewhere(s)
appropriate. [370:

Sun Oct 23 11:46:16 2022 Breaking for brunch but
there's still a whole issue about

  Bool PocketChain.isSwappable(PCS& pcs, Bool up)

which is

 - currently called maybe a dozen places and
 - takes a Bool upstream (I think) it never looks at
 - and is still kind of bankrupt because it's a
   single-sided comparison..

After brunch let's look at the isSwappable(..)
uses and see what we think.

[371:

Sun Oct 23 12:15:00 2022 OK, isSwappable
inventory:

 - PocketChain.updateGradients calls it twice and
   uses false return values to signal 'anchors' in
   the m{Segs|Temps}{Up|Down} gradients.

   -> (But nobody uses any of those gradients, at
      present.)

 - PocketChain.actMovingSeg(..) uses it as part of
   propagating temps (mDSType == cDS_UP or
   cDS_DOWN) through the chain. If isSwappable(..)
   returns false, the swap is blocked.

   -> It always passes true to Bool upstream.

   -> That case would appear to be relevant to
      both cDS_DUMB Codons and inDSP(..) ones, if
      it could be arranged.

 - ChainRule.isX uses it

   -> It also always passes true to Bool upstream.

   -> isX says X is anything that's cSD_NORM and
      is swappable. inDSP would appear to be
      relevant there.

   -> -> But isX does not get told which MCP is
      being queried, so it couldn't easily access
      our new inDSP. Maybe isX should be ditched.

 - NuSide (deprecated) overrides isSwappable to
   say always false.

 - SfCorner (in use) does the same

 - ShSfIWormMid.act(..) (never/not yet in use)
   calls isSwappable to decide if it can move.

   -> It always passes false to Bool upstream.

 - element ShapeShifter overrides isSwappable to
   say in isn't swappable while in wait states,
   but is otherwise.

   -> Except, ugh, ShapeShifter.isSwappable didn't
      declare @Override, and has only one
      argument, so I suspect it's now unrelated to
      PocketChain.isSwappable(PCS&,Bool), ugh.


 - element SfSide also failed to use @Override
   ugh.

[372:

Sun Oct 23 12:32:17 2022 And that's the end of the
inventory. Let's rebuild with the @Overrides and
confirm..[373:

Sun Oct 23 12:33:02 2022 Yup:

    ./SfSide.ulam:112:16: ERROR: @Override flag fails virtual function: Bool isSwappable(PocketChainState& ds).
    ./ShapeShifter.ulam:649:16: ERROR: @Override flag fails virtual function: Bool isSwappable(PocketChainState& ds).

ugh ugh.

So, what does that tell us?
[374:

Sun Oct 23 12:49:51 2022 Well, commented them out
and nothing seems to've changed.

So what's left in inventory?

 - PocketChain.actMovingSeg(..) ?

 - ChainRule.isX

Perhaps after nap we could explore when might be
enough to replace those uses with inDSP somehow,
(and then maybe head towards ditching isSwappable
altogether.) [375:

Sun Oct 23 15:47:46 2022 So I feel like isX(..) is
the easier case because it's inside the ChainRule
structures where we have explicit
MatchCodePositions. actMovingSeg is generalized
wrt body direction -

      BodyDir movedir =
        (mDSType == cDS_UP) ? Segment.cBODY_UP : Segment.cBODY_DOWN;
      BodyDir backdir = (BodyDir) (1u - movedir);

buut is that really such a problem? We need to map
between BodyDir and MCP, is that it?

 Segment.cBODY_UP   =~= MatchCodePosition.cMCP_NEXT
 Segment.cBODY_DOWN =~= MatchCodePosition.cMCP_PREV
 ??? (self?)        =~= MatchCodePosition.cMCP_HERE

[376:

Sun Oct 23 17:02:24 2022 OK, so both
ChainRule.isX(..) and PocketChain.actMovingSeg(..)
take a PocketChainState &. So could we declare like

  Bool mInDSP[MatchCodePosition.maxof + 1u];

and develop it in PCS.observe(..) after findMates
succeeds? Then both isX and actMovingSeg could
find it?[377:

Sun Oct 23 17:25:59 2022 OK trying to set that
up. Where is mDSHopContour set up, again?[378:

Sun Oct 23 17:26:58 2022 In PocketQuadrant..

which lives in a PocketHC3..
which lives in a PocketableState..
which is a base class of SegmentState..
which is a base class of PocketChainState..
OK.
[379:

Sun Oct 23 17:37:12 2022 OK we did the inDSP logic
somewhere already, right? How does that go, again?

[380:

Sun Oct 23 17:38:55 2022 Looks like it's
PocketHC3.isDSP(PocketPtr). [381:

Sun Oct 23 17:43:10 2022 So the new stuff just
amounts to

    mInDSP[cMCP_PREV] = p.isDSP(mPocketWithMate[cBODY_DOWN]);
    mInDSP[cMCP_HERE] = p.isDSP(cPP_SELF);
    mInDSP[cMCP_NEXT] = p.isDSP(mPocketWithMate[cBODY_UP]);
    mInDSPValid = true;

? Let's try to build it.[382:

Sun Oct 23 17:46:29 2022 Hmm build taking too long for
simple code problems.. what's the next step in
hooking this up?[383:

Sun Oct 23 17:47:48 2022 OK it's running as
before.

To hook this up we need it in isX and
actMovingSeg.

Let's try actMovingSeg first..[384:

Sun Oct 23 17:52:02 2022 Well building a first cut
at that..[385:

Sun Oct 23 17:56:28 2022 Well it's running, and it
kind of looks like the O stream is actually now
pinning an EC.. There's a MK, an EC/up, and an
EC/down flopping around outside the O DSP, but in
the pocket it's always an EC/down.

And by tagging it with mDebugOutputEnabled, it
appears it's always the same bein in the O DSP.

Progress, perhaps!

Dinnertime!
[386:

Sun Oct 23 19:48:39 2022 OK, after a yum Paola's
Non and then GoT s6e7, here we are again. Can we
fix up isX and see where that takes us?

[387:

Sun Oct 23 20:19:04 2022 Well, seems like the I
stream now has pinned its DSP occupant. Which I
thought wasn't supposed to be an EC, but maybe I'm
misremembering.

In any case, I see that Sf has no compunction
about swapping into (at least) an X DSP while
advancing. Let's take a look at that.[388:

Sun Oct 23 20:21:19 2022 OK that code currently
looks like:

    if (downIsProvider || /*!isSwappableInContext(ng,false) ||*/ qc is ShapeShifter) {

so.. not surprising. Changing it to

    if (downIsProvider || isInDSP(cMCP_PREV) || qc is ShapeShifter) {

. Building.
[389:

Sun Oct 23 20:28:47 2022 OK, now it's EC appears
to have no problem swapping Ld out of the X DSP.
Tracing.[390:

Sun Oct 23 20:30:08 2022 Appears to be rule 3 of
ChainRulesFreeStab: ChainRule_COMPACT10. Which
says:

    /** CHAINRULE: COMPACT10: X -> [EC0] -> EC1  ==>  EC0 -> [X] -> EC1 */
    transient ChainRule_COMPACT10 : ChainRule {

with

    ChainPattern p = { cCPAT_X, cCPAT_EC, cCPAT_EC };

so we'd've thought our isX modifications would
apply here..[391:

Sun Oct 23 20:36:39 2022 I suspect I picked a DOWN
for PREV that actually wants to be an UP..[392:

Sun Oct 23 20:47:15 2022 Well, but
ChainRule.codeAt associates PREV and DOWN

    case cMCP_PREV: {
      print("CRMCDAT11");
      sn = ss.mEWSNMate[Segment.cBODY_DOWN];

which seems to go along with PocketChainState
doing

    mInDSP[cMCP_PREV] = p.isDSP(mPocketWithMate[cBODY_DOWN]);

[393:

Sun Oct 23 21:02:03 2022 Well it is seeming
screwed up, with BODY_UP being considered PREV of
SELF. Like the 'natural flow' is downstream, so
NEXT is further downstream. Which isn't insane but
now we're in flippo-floppita land. Trying

    mInDSP[cMCP_PREV] = p.isDSP(mPocketWithMate[cBODY_UP]);

and analogous..[394:

Sun Oct 23 21:06:03 2022 Aand that seems to break Sf.
[395:

Sun Oct 23 21:14:20 2022 Upps, and it looks like I
might have messed up actMovingSeg from the outset?
PCS.isInDSP takes a MatchCodePosition, but aMS is
giving it a body dir
  ..
      BodyDir movedir =
        (mDSType == cDS_UP) ? Segment.cBODY_UP : Segment.cBODY_DOWN;
  ..
            !ds.isInDSP(movedir)) {  // not in DSP, it's swappable

[396:

Mon Oct 24 00:03:22 2022 Well, I'm pretty sure I
messed up PocketHC3.isDSP(PocketPtr), so, going
again.. And we probably now have a bunch of other
busted crap that we did just flailing around the
last few hours, gah.
[397:

Mon Oct 24 01:03:10 2022 OK, we seem finally to be
holding the Ld in the X DSP, and that's causing
the next problem: The LOADER_LOAD rule isn't
matching, because it's like

    /** CHAINRULE: LOADER_LOAD: EC0 -> [X0] -> EC1  ==>  EC0 -> [X0] -> X1 */

and we just contorted ourselves so that X doesn't
match in a DSP. So that's fair enough. How do we
want to express this rule? We don't really want to
use [X] since we're not going to move the center.
[398:

Mon Oct 24 01:12:08 2022 Well we gave 4 bits to
ChainType but have only used 8 so we can certainly
have another if we want. But in this particular
case, what if we go with [Y]? That allows DUMB and
NORM, and we're saying it doesn't care about DSP
status.. [399:

Mon Oct 24 01:25:04 2022 OK, made a bunch more
progress, and now at the kind of issue I was
expecting to get to oh a few weeks ago, say. Ld is
pinned to the DSP, and Sf generates an initial
loop, and Ld begins to populate it.

Eventually there's only one EC left, and it ends
up just upstream of the DSP Ld.

Eventually ChainRule_LONEEMPTY fires on the EC,
and it makes an Sf. All good.

But if the Sf cannot spawn there (which I think,
usually, it cannot) the Sf then wants to advance
downstream - and downstream only.

But we know that won't work, because we know the
Ld is downstream. So the Sf decays immediately,
never even having had a chance to tour the loop.

And the loading thus stalls, in livelock.

Could we have some rule that occasional flips
cDS_DOWN into cDS_UP, and vv, to help break such
loops? Didn't we even make such a thing already?


:399]

:398]
:397]
:396]
:395]
:394]

:393]
:392]

:391]


:390]

:389]

:388]

:387]

:386]

:385]

:384]

:383]

:382]

:381]

:380]

:379]
:378]

:377]

:376]
:375]


:374]
:373]

:372]

:371]

:370]

:369]

[368: Sun Oct 23 11:42:32 2022 (We do have several
overrides of ChainRule.matches(..) but they all go
through super.matches(..) first.)  :368]

:367]

:366]

:365]

 :364]

:363]

:362]

:361]

:360]

:359]

:358]

:357]


:356]

:355]

:354]
:353]

:352]

:351]

:350]

:349]

:348]

:347]
[346:

Sun Oct 23 09:01:25 2022 (Conceivably we might
want the Ld to work its way to the DSP and then
'latch' itself there? Might be a way to let the
initial loop grow?)

:346]

:345]

:344]

:343]

:342]

:341]

:340]

:339]

:338]

:337]
:336]

:335]
:334]

:333]

:332]

:331]

:330]

:329]

:328]
:327]

:326]

:325]

:324]
[400:

Mon Oct 24 02:09:02 2022 Yikes, it appears we're
actually facing a genuine instruction semantics
issue foggen finally! (And we just hit :400:
here.)

So with a mod to ChainRule_LONEEMPTY to switch
tempdirs sometimes, the loader actually finished
loading! And then it erased itself - via a DS
instruction execution! And eventually the 0xDABE
Marker arrived in X DSP! And now it's just sitting
there clogging everything up, because it never
says it's done!

[401:

Mon Oct 24 02:28:38 2022 Hmm, seems like
markCurrentInstructionForRotation ain't working at
this point. The Loader didn't use it really; it
just erased itself.
[402:

Mon Oct 24 02:31:12 2022 So I guess technically it
did work, since its job is job to update the X
stream of the mDirStatusMap, and it did that. The
failure is in Mk, or its bases, for not doing what
the map says. How is that supposed to happen?[403:

Mon Oct 24 02:33:41 2022 Looks like it's supposed
to be part of CodonState.stabilize(..) ?

Let's let MK have a debug event and tell us what
it's thinking..[404:

Mon Oct 24 02:36:12 2022 It correctly detects it's
in a DSP and its PREV and NEXT are not..[405:

Mon Oct 24 02:39:18 2022 Ruh roh: Are we inside a
perform(..) call, here? No, we're not: procstatus
responses are handled by the Codons
themselves.[406:

Mon Oct 24 02:42:51 2022 So, what intention class
does LXMarker request? Where is that
specified?[407:

Mon Oct 24 02:44:47 2022 Looks like it's maybe
PocketChainState? And we need it to be at least
CodonState to do procstatus processing.

Let's report the intention to confirm. But we
suspect Codon should override getIntentionClass
but it currently isn't?[408:

Mon Oct 24 02:51:27 2022 Yeah, it's
PocketChainState. [409:

Mon Oct 24 03:07:46 2022 OK! We're kind of really
working here! Exciting!

So far the only issue I see is:

    20221024030602-3307: 743AEPS [1CA02D27]MSG: s[43,40] t[0,0]: LXMarker<2541>
    20221024030602-3308: 744AEPS [1CA02D27]MSG: s[43,40] t[0,0]: LXMarker<DABE>
    20221024030608-3309: 801AEPS [1CA02D27]MSG: s[44,40] t[0,0]: LXMarker<2541>
>>  20221024030613-3310: 841AEPS [1CA02D27]MSG: s[46,40] t[0,0]: LXMarker<2541>
    20221024030615-3311: 860AEPS [1CA02D27]MSG: s[47,40] t[0,0]: LXMarker<DABE>
    20221024030637-3312: 1066AEPS [1CA02D27]MSG: s[52,37] t[0,0]: LXMarker<2541>
    20221024030640-3313: 1092AEPS [1CA02D27]MSG: s[53,37] t[0,0]: LXMarker<DABE>
    20221024030653-3314: 1220AEPS [1CA02D27]MSG: s[58,37] t[0,0]: LXMarker<2541>
    20221024030656-3315: 1239AEPS [1CA02D27]MSG: s[57,37] t[0,0]: LXMarker<DABE>
    20221024030712-3316: 1385AEPS [1CA02D27]MSG: s[65,37] t[0,0]: LXMarker<2541>
    20221024030716-3317: 1421AEPS [1CA02D27]MSG: s[67,37] t[0,0]: LXMarker<DABE>
    20221024030734-3318: 1599AEPS [1CA02D27]MSG: s[73,37] t[0,0]: LXMarker<2541>
    20221024030736-3319: 1620AEPS [1CA02D27]MSG: s[72,37] t[0,0]: LXMarker<DABE>
    20221024030752-3320: 1779AEPS [1CA02D27]MSG: print: "GROWBOMB!"
    20221024030752-3321: 1779AEPS [1CA02D27]MSG: print: Unsigned: 5
    20221024030752-3322: 1779AEPS [1CA02D27]MSG: print: Unsigned: 6
    20221024030753-3323: 1795AEPS [1CA02D27]MSG: s[69,33] t[0,0]: LXMarker<2541>
    20221024030755-3324: 1806AEPS [1CA02D27]MSG: s[69,33] t[0,0]: LXMarker<DABE>
    20221024030805-3325: 1897AEPS [1CA02D27]MSG: s[69,35] t[0,0]: LXMarker<2541>
    20221024030806-3326: 1903AEPS [1CA02D27]MSG: s[69,35] t[0,0]: LXMarker<DABE>

If the program is properly rolling forward as
intended, we should see a strict alternation of
the two markers.. as we mostly do.[410:

Mon Oct 24 03:21:56 2022 Now up to:

    20221024030832-3327: 2134AEPS [1CA02D27]MSG: s[68,44] t[0,0]: LXMarker<2541>
    20221024030838-3328: 2180AEPS [1CA02D27]MSG: s[68,46] t[0,0]: LXMarker<DABE>
    20221024030900-3329: 2368AEPS [1CA02D27]MSG: s[68,55] t[0,0]: LXMarker<2541>
    20221024030911-3330: 2465AEPS [1CA02D27]MSG: s[68,60] t[0,0]: LXMarker<DABE>
    20221024030944-3331: 2745AEPS [1CA02D27]MSG: s[67,67] t[0,0]: LXMarker<2541>
    20221024030952-3332: 2799AEPS [1CA02D27]MSG: s[70,67] t[0,0]: LXMarker<DABE>
    20221024031034-3333: 3130AEPS [1CA02D27]MSG: s[70,56] t[0,0]: LXMarker<2541>
    20221024031034-3334: 3134AEPS [1CA02D27]MSG: s[70,56] t[0,0]: LXMarker<DABE>
    20221024031055-3335: 3296AEPS [1CA02D27]MSG: s[70,57] t[0,0]: LXMarker<2541>
    20221024031104-3336: 3368AEPS [1CA02D27]MSG: s[70,55] t[0,0]: LXMarker<DABE>
    20221024031130-3337: 3584AEPS [1CA02D27]MSG: s[70,53] t[0,0]: LXMarker<2541>
    20221024031133-3338: 3608AEPS [1CA02D27]MSG: s[70,52] t[0,0]: LXMarker<DABE>
    20221024031201-3339: 3841AEPS [1CA02D27]MSG: s[69,48] t[0,0]: LXMarker<2541>
    20221024031206-3340: 3884AEPS [1CA02D27]MSG: s[68,47] t[0,0]: LXMarker<DABE>
    20221024031237-3341: 4146AEPS [1CA02D27]MSG: s[68,41] t[0,0]: LXMarker<2541>
    20221024031254-3342: 4291AEPS [1CA02D27]MSG: s[68,38] t[0,0]: LXMarker<DABE>
    20221024031308-3343: 4409AEPS [1CA02D27]MSG: print: "GROWBOMB!"
    20221024031308-3344: 4409AEPS [1CA02D27]MSG: print: Unsigned: 6
    20221024031308-3345: 4409AEPS [1CA02D27]MSG: print: Unsigned: 7
    20221024031310-3346: 4425AEPS [1CA02D27]MSG: s[68,36] t[0,0]: LXMarker<2541>
    20221024031314-3347: 4461AEPS [1CA02D27]MSG: s[68,36] t[0,0]: LXMarker<DABE>
    20221024031335-3348: 4610AEPS [1CA02D27]MSG: s[68,39] t[0,0]: LXMarker<2541>
    20221024031342-3349: 4661AEPS [1CA02D27]MSG: s[68,37] t[0,0]: LXMarker<DABE>
    20221024031436-3350: 5064AEPS [1CA02D27]MSG: s[68,36] t[0,0]: LXMarker<2541>
    20221024031457-3351: 5226AEPS [1CA02D27]MSG: s[68,35] t[0,0]: LXMarker<DABE>
    20221024031546-3352: 5588AEPS [1CA02D27]MSG: s[65,34] t[0,0]: LXMarker<2541>
    20221024031604-3353: 5720AEPS [1CA02D27]MSG: s[65,34] t[0,0]: LXMarker<DABE>
    20221024031621-3354: 5842AEPS [1CA02D27]MSG: print: "GROWBOMB!"
    20221024031621-3355: 5842AEPS [1CA02D27]MSG: print: Unsigned: 7
    20221024031621-3356: 5842AEPS [1CA02D27]MSG: print: Unsigned: 8
    20221024031633-3357: 5929AEPS [1CA02D27]MSG: s[65,33] t[0,0]: LXMarker<2541>
    20221024031637-3358: 5958AEPS [1CA02D27]MSG: s[65,33] t[0,0]: LXMarker<DABE>
    20221024031739-3359: 6415AEPS [1CA02D27]MSG: s[61,43] t[0,0]: LXMarker<2541>
    20221024031749-3360: 6489AEPS [1CA02D27]MSG: s[61,44] t[0,0]: LXMarker<DABE>
    20221024031759-3361: 6566AEPS [1CA02D27]MSG: print: "GROWBOMB!"
    20221024031759-3362: 6566AEPS [1CA02D27]MSG: print: Unsigned: 8
    20221024031759-3363: 6566AEPS [1CA02D27]MSG: print: Unsigned: 9
    20221024031811-3364: 6653AEPS [1CA02D27]MSG: s[61,44] t[0,0]: LXMarker<2541>
    20221024031812-3365: 6655AEPS [1CA02D27]MSG: s[61,44] t[0,0]: LXMarker<DABE>
    20221024031829-3366: 6780AEPS [1CA02D27]MSG: s[61,44] t[0,0]: LXMarker<2541>
    20221024031831-3367: 6795AEPS [1CA02D27]MSG: s[61,44] t[0,0]: LXMarker<DABE>
    20221024031908-3368: 7044AEPS [1CA02D27]MSG: s[62,40] t[0,0]: LXMarker<2541>
    20221024031924-3369: 7146AEPS [1CA02D27]MSG: s[62,40] t[0,0]: LXMarker<DABE>
    20221024032052-3370: 7695AEPS [1CA02D27]MSG: s[62,53] t[0,0]: LXMarker<2541>
    20221024032115-3371: 7846AEPS [1CA02D27]MSG: s[62,55] t[0,0]: LXMarker<DABE>

and still no more failures.

Nap time. Leaving it running. It'll punch out after
it fills the tile and jams up. (Leaving mfms
running but whatever, for now.)
[411:

Mon Oct 24 09:09:49 2022 Final log segment:

    20221024032318-3372: 8639AEPS [1CA02D27]MSG: s[58,50] t[0,0]: LXMarker<2541>
    Screen resize: 1918 x 996
    Screen resize: 3840 x 2133
    20221024032336-3373: 8714AEPS [1CA02D27]MSG: s[58,47] t[0,0]: LXMarker<DABE>
    20221024032933-3374: 10589AEPS [1CA02D27]MSG: print: "GROWBOMB!"
    20221024032933-3375: 10589AEPS [1CA02D27]MSG: print: Unsigned: 9
    20221024032933-3376: 10589AEPS [1CA02D27]MSG: print: Unsigned: 10
    20221024032956-3377: 10704AEPS [1CA02D27]MSG: s[56,41] t[0,0]: LXMarker<2541>
    20221024032956-3378: 10708AEPS [1CA02D27]MSG: s[56,41] t[0,0]: LXMarker<DABE>
    20221024033327-3379: 11754AEPS [1CA02D27]MSG: s[54,39] t[0,0]: LXMarker<2541>
    20221024033415-3380: 11987AEPS [1CA02D27]MSG: s[48,37] t[0,0]: LXMarker<DABE>
    20221024034337-3381: 14627AEPS [1CA02D27]MSG: s[45,55] t[0,0]: LXMarker<2541>
    20221024034425-3382: 14858AEPS [1CA02D27]MSG: s[38,55] t[0,0]: LXMarker<DABE>
    20221024034900-3383: 16098AEPS [1CA02D27]MSG: s[45,54] t[0,0]: LXMarker<2541>
    20221024034904-3384: 16113AEPS [1CA02D27]MSG: print: "GROWBOMB!"
    20221024034904-3385: 16113AEPS [1CA02D27]MSG: print: Unsigned: 10
    20221024034904-3386: 16113AEPS [1CA02D27]MSG: print: Unsigned: 11
    20221024034907-3387: 16130AEPS [1CA02D27]MSG: s[45,54] t[0,0]: LXMarker<DABE>
    20221024035439-3388: 17524AEPS [1CA02D27]MSG: print: "GROWBOMB!"
    20221024035439-3389: 17524AEPS [1CA02D27]MSG: print: Unsigned: 11
    20221024035439-3390: 17524AEPS [1CA02D27]MSG: print: Unsigned: 12
    20221024035518-3391: 17680AEPS [1CA02D27]MSG: s[47,47] t[0,0]: LXMarker<2541>
    20221024035654-3392: 18058AEPS [1CA02D27]MSG: s[45,45] t[0,0]: LXMarker<DABE>
    20221024040902-3393: 20896AEPS [1CA02D27]MSG: s[45,45] t[0,0]: LXMarker<2541>
    20221024041152-3394: 21578AEPS [1CA02D27]MSG: s[45,47] t[0,0]: LXMarker<DABE>
    20221024041434-3395: 22188AEPS [1CA02D27]MSG: print: "GROWBOMB!"
    20221024041434-3396: 22188AEPS [1CA02D27]MSG: print: Unsigned: 12
    20221024041434-3397: 22188AEPS [1CA02D27]MSG: print: Unsigned: 13
    20221024042138-3398: 23800AEPS [1CA02D27]MSG: s[51,45] t[0,0]: LXMarker<2541>
    20221024042428-3399: 24479AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024042635-3400: 24952AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024042638-3401: 24964AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024042946-3402: 25615AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024042958-3403: 25659AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024043308-3404: 26320AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024043320-3405: 26364AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024043816-3406: 27348AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024043824-3407: 27376AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024044054-3408: 27892AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024044126-3409: 28000AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024044325-3410: 28402AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024044402-3411: 28533AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024044554-3412: 28917AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024044607-3413: 28959AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024044800-3414: 29355AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024044858-3415: 29554AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024045534-3416: 30943AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024045630-3417: 31201AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024045840-3418: 31783AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024045914-3419: 31942AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024050315-3420: 32980AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024050359-3421: 33173AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024050823-3422: 34334AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024051013-3423: 34798AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024051143-3424: 35189AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<2541>
    20221024051201-3425: 35263AEPS [1CA02D27]MSG: s[49,46] t[0,0]: LXMarker<DABE>
    20221024051358-3426: 35773AEPS [1CA02D27]MSG: print: "vvv DYING vvv"
    20221024051358-3427: 35773AEPS [1CA02D27]MSG: print: "PocketChain: Too open pocket"
 ..etc, death throes..

[412:

Mon Oct 24 09:18:02 2022 OK, going again.
[413:

Mon Oct 24 09:24:07 2022 Looking at the 2541
glitch now. I'm thinking it's likely due to my
randomizing of temp directions - I suspect the
last instruction got pulled into the DSP by a
'backward' temp in the DSP.

But that shouldn't be possible, right? The
procstatus function should be controlling
operations there. We shall see.
[414:

Mon Oct 24 09:32:21 2022 So, yeah, event sequence:

 - Loader executes in X DSP, decays to EC/D
 - MK/2541 executes, swaps with EC/D, lands in the
   X DSP
 - (MK/2541 updates its mSegsDown)
 - MK/2541 incorrectly executes in X DSP

Question is why the second step?

Ah and answer is, we think: Because the rule
(SPREAD something?) that MK ran didn't check if
the **EC** was in the DSP. Who checks about the
status of ECs? But indeed we need to.

Checking.[415:

Mon Oct 24 09:47:24 2022 It was:

    20221024094712-3854: 418AEPS [923156A7]MSG: print: "CRFAR1110"
    20221024094712-3855: 418AEPS [923156A7]MSG: print: "ChainRule_SPREAD11"

which says

/** CHAINRULE: SPREAD11: EC -> [X] -> Y  ==>  X -> [EC] -> Y */

and we wonder how we want to fix this? A separate
match code to distinguish 'an EC to move' vs 'an
EC to just sit there'? How about cCPAT_FE for
'fixed empty'? Or make cCPAT_EC be fixed, and have
cCPAT_SEC for 'swappable EC' or something?

[416:

Mon Oct 24 13:46:06 2022 OK, we made

  constant ChainType cCPAT_FC = 1u; //< A EmptyCodon that will not be swapped

and things seem to be pretty rock-solid at the
moment.

I'm thinking we need to reduce LXReset to just
clearing crap out, and leave the O and R DSP
empty. Then we can make some more instructions to
do some more stuff.

But I'm thinking we need to start conserving
element types.. Maybe we should make a single
element that represents a 'core instruction set'?
With cases within it..

[417:

Mon Oct 24 14:21:33 2022 Hmm yeah:

    20221024142118-3254: 1AEPS [A8EF867]MSG: s[48,36] t[0,0]: [[S STARTUP: Max Class Id: 194]]

So we'd like to conserve classids a bit if we
could.

But on the other hand, if we're conserving them in
an attempt to make SW3Packet's cSW3C_PLACE
operation as useful as possible, we have to
remember that's always going to place a DEFAULT
INSTANCE of the given classid. We won't be able to
choose which 'subinstruction' we want the PLACEd
atom to have.

No Foggen Free Lunch.

:417]:416]

:415]

:414]
:413]
:412]

:411]
:410]

:409]

:408]

:407]

:406]

:405]

:404]

:403]

:402]
:401]

:400]
[418:

Mon Oct 24 20:33:15 2022 So, I've made
LXControlArm trying to get programmable control of
a SwapWorm. In effect I'm doing self-modifying
code, because I'm storing the 'program counter'
inside the control arm atom. Which I didn't want
to do but here we are on a T2sday eve. "Just have
to remember to reset before moving on."

In any case, for this demo we're using a String to
hold the program, so we need a mapping from ASCII
to control codes. Quick quick, what shall it be?

[nsew] -> grow [NSEW]
-      -> shrink
W      -> place W

:418]
[419:

Thu Oct 27 02:21:54 2022 Moving to Sequencer213
for post-t2sup3132 development.
[420:

Thu Oct 27 02:23:22 2022 And here we are.

[421:

Thu Oct 27 02:24:26 2022 Updated S.ulam.

First goal, here, is get the damn mPC indexing
working properly in LXCtorArm.ulam..
[422:

Thu Oct 27 09:22:35 2022 And how do we do that
exactly? What currently happens?

 - During init (mPC == mPC.maxof), kill I & R
   = Once killed, seed SW in R AND SET mPC = 0
   = That says modify PC at end of atomic?

 - Otherwise, if mPC >= mProgram.length
   = markCIFR
   = Should we reset mPC at this point? To make
     the instruction 'externally stateless' though
     neither atomic nor truly idempotent
     - Oo-ooo do we also need to reset mSeqNo we
       do don't we.. or not now necessarily but
       that needs to happen during reset
     - But, we might want CA programs that don't
       reset the arm. but then we just init mPC to
       0 instead of max?

 - Otherwise, mPC >= 0 && mPC < mProgram.length
   = And I guess perhaps the distinction to be
     careful with is
     - About to inject instruction at mPC vs
     - Injected mPC instruction, waiting for
       result

Maybe we want '.' and '!', or ',' and '.'. With
one meaning

',' - pause: just roll to next instruction, vs

'.' - stop: set to reset and then roll

and use end-of-string as a stop.

And could have all sorts of within-instruction
control ops, like parens for grouping for skip and
repeat and so forth.

I guess if we're chaining segments we'd want to
reset our mPC to 0 when rolling to next
instruction, so if someone rolls back to us we'll
pick up at the beginning.[423:

Thu Oct 27 12:48:20 2022 So if we made an
'embedded program' LXCtorArm, we could

 - Take away mProgram for +20b
 - Reduce mPC to Unsigned(5) or (4), for +3-4b
 - Use existing unused for +11b

and end up with at least 32b for embedded
ops. Could we make four bit opcodes for up to 8
ins per atom? Or maybe say 7 ins + a 4b reg? But
does the reg value carry between program chunks?

[nsew] +4 ops
..maybe 6 bit ops..

[mode] +2b
[arg]  +4b

[424:

Thu Oct 27 13:10:49 2022 For comparison, SW3Packet
has
  mCmd +4b
  mArg +8b

and that's not including the command status +2b
and the sequence number +4b

[mode=00:grow][arg=dirmap]
[mode=01:pfx1][arg=value 4b]
[mode=10:ops1][arg=op]
              op=0000 stop
                 0001 suspend
                 0010 grow w
                 0011 grow n
                 0100 grow s
                 0101 grow e
                 0111 withdraw
                 1000 place reg
                 1001 become reg

[425:

Fri Oct 28 01:09:49 2022 So let's cool our
generalization jets a bit here and try to
consolidate on a plan of some kind. Original
question was when do we update mPC..

I guess the theory is increment when we first see
the result from the arm? Vs when we just inject an
instruction into the arm?

                                         implied
  state     condition       transition   newstate

  RESET     killPUs true    seed SW3,    (DISPATCH)
                            mPC = 0,
                            seqno =
                             sw.seqNo

  DISPATCH  mPC>=len                     (EXIT)

            p[mPC] local    <handle>     DISPATCH
                            mPC++

            p[mPC] remote   inject(p[mPC]) BLOCK
                            ++seqNo

  BLOCK     sw.seqno ==     mPC++        DISPATCH
            seqno

  EXIT

And the states are defined stigmergically as

 RESET:    mPC == mPC.maxof
 DISPATCH: mPC < p.lengthof && seqno == sw.seqno
 BLOCK:    mPC < p.lengthof && seqno > sw.seqno
 EXIT:     mPC >= p.lengthof && mPC < mPC.maxof

[426:

Fri Oct 28 02:08:17 2022 Well that seems almost
plausible. Could we make it so?
[427:

Fri Oct 28 03:42:58 2022 Been hacking it. Seems
like we need to ++mPC at the time we inject the
command, because that's us making an atomic
transition.

If we want to wait until the arm responds, we have
no easy way to know if it's our first event since
the arm responded? We wake up and discover seqnos
match, but we've never actually injected an
instruction yet. But if we increment on injection,
then we'll see EOS immediately on the next
event. The whole stigmergic state machine is
predicated on mPC being the current instruction?

But then we need to get from reset to injection
without checking seqnos.
[428:

Fri Oct 28 04:20:43 2022 Which our current scheme
does. I don't think there's really a problem
here. We 'just' need to go from RESET to DISPATCH
to inject in a single event.

Is the point that we need to do ++mPC at the
*beginning* of DISPATCH, EXCEPT when coming from
RESET?

We're saying DISPATCH means: We've just detected
previous instruction completion (via seqno match),
so it's time to advance to the next instruction
and inject it? How will we ever do jumps?

Maybe distinguish prevPC from mPC? Gah, it'd have
to be persistent to be worth anything and that we
don't want to pay.

We could have a separate step where we ask the
now-just-known-to-be-finished op where it wants to
go, defaulting to mPC+1.

[429:

Fri Oct 28 05:01:43 2022 What if we left mPC at
.maxof even after RESET, so DISPATCH could see it
as a special case too?

RESET
  if (mPC == mPC.maxof) {
    if (killPUs(..) {
      SW3 h;
      ew[..] = h.atomof;
      // FALL THROUGH
    }

DISPATCH
  if (seqno == sw3.seqno) {
    if (mPC == mPC.maxof) mPC = 0;
    else mPC = next(p[mPC]);

    if (mPC < p.lengthof) {
      ASCII b = p[mPC];
      if (dispatchLocal(dss, b)) return true;
      if (dispatchRemote(dss, b)) return true;
      print("bad dispatch");
      return false;
    }
    // fall through
  }

BLOCK
  if (mPC < p.lengthof && seqno > sw3.seqno)
    return true; // blocking

EXIT
  if (mPC >= p.lengthof && mPC < mPC.maxof) {
    doExit();
    return true;
  }

print("Bad state");
doExit(); //??
return true;

[430:

Fri Oct 28 10:23:58 2022 Duuuuh-ohhhh: If we don't
change mPC after killPUs returns true and we seed
the SW3, we just kill it the next time around.
[431:

Fri Oct 28 10:55:16 2022 And double duh: But the
whole point was that we're going to go from
completing RESET to initting DISPATCH in a single
event, so we can just have a local Bool justReset;
and check that with no persistent storage cost.

Thing seems to be working again. As a test, can we
get rid of the final "." in the program, now?
[433:

Fri Oct 28 12:17:25 2022 'Unrelated' issue: I'm
trying to clean up SeedSeq by creating the entire
initial configuration - HG root, DS, and the
initial four loops - in a single go. But the
problem is, since the DS now exists before most of
the grid, it gets copied all over the place when
the grid grows. I think we need to be more nazi
about only creating HGs during grid construction
and repair, and leaving more exotic HG variants to
special creation tasks as they need.[434:

Fri Oct 28 12:58:52 2022 OK a challenge there is
that initializing a new spawn by copying the
QHardCell fields does almost nothing, because all
QHardCell owns is the NgbRels and the DEWLine. So
all the hops and maxhops and what-not don't get
copied with QHardCell &.

I guess we need our new 'Atom toSpawn()' method to
do some copying on its own.[435:

Sat Oct 29 02:25:15 2022 So I've been working in
ClassUtils.ulam and _native, and a new
BaseClassUtils.ulam, trying to get a generic

  Int BaseClassUtils.copySharedData(Atom & fromelt, Atom & toelt)

method going. Lots of problems and progress
ultimately leading up to this: For the life of me,
trying to get mDSHops copied via the above method
kept failing.

Because: It turns out there's two different
mDSHops in the foggen code base. Genius.

    ./HardCellG.ulam 153:  DSHops mDSHops;

in quark QHardCellG, and

    ./HardCell.ulam 18:  DSHops mDSHops;

in element HardCell.

Now, the reason for this genius, IIRC, is that at
one point I was trying to make it possible for
DiamondSequencer not to allocate any bits for an
mDSHops, since by definition it was going to be
0. But something went wrong along the way, there,
and now DiamondSequencer inherits from QHardCellG
which means it is burning space for a modifiable
mDSHops. [436:

Sat Oct 29 03:25:31 2022 OK, made QDSHops for the
get/set and QDSHopsStg to add storage, and now DS
has three more bits available and
BaseClassUtils.copySharedData works, I think, as
expected. [437:

Sat Oct 29 03:30:09 2022 Goal will be to merge

  Int copyClassDataMembers(ClassId bci, Atom & fromelt, Atom & toelt)
  Int copySharedData(Atom & fromelt, Atom & toelt)

into ClassUtils.ulam for ulam 6, after ulam can
deal with element data members.

INNNN THE MEANTIMMMMMME, pop pop pop..[438:

Sat Oct 29 04:04:23 2022 OK so we were redoing the
LXCtorArm state machine, and we subgoaled to
improve the reliability of SeedSeq, and that led
to yak shaving in ClassUtils. Now we're back to
the LXCtorArm state machine, and the new version
has bugs. For example, it appears to be skipping
the first instruction.

Pick up there after nap.[439:

Sat Oct 29 09:17:27 2022 OK so the first problem
is - because we were doing a lot in one event, to
exploit its atomicity - we failed to update our
ProcUnitInfo when we created the SW and set
justReset. That caused later code to fail out of
that event, so the fact of justReset was for
naught.

So now we have that fixed, but it appears we're
racing somehow while blocking for command
completions, because we're seeing various shrunken
and incomplete boxes being produced.

So let's run that down now.
[440:

Sat Oct 29 10:44:32 2022 OK it was a failure to
check the cmdStatus for TRYING - in addition to
matching seqnos - before dispatching an
instruction. And now that's fixed and we're back
to making our raggedy-ass boxes.

pop pop pop

What next?

Does DIEPL work now? Can we simplify the program
that way and get rid of the Ws?[441:

Sat Oct 29 10:59:53 2022 OK, DIEPL kind of works,
but since it completely consumes the SW, the CA
then stalls because it can't find the SW to
determine command completion. We'd need another
special case to get something to run in that case..

[442:

Sat Oct 29 23:28:45 2022 Actually we already had a
special case for DIE to avoid killing the last
SW3; now extended that to DIEPL. That gives us our
'box' - but now with an 'ear' because we Wall up
the second-to-last SW2. The advantage of the unary
Ws representation is we can stop wherever we like.

How about passing a count with a DIE/DIEPL and
subsuming SHRINK as just a 1DIE?

Was thinking also: What about placing a 'joint' in
the arm, that acted like a bridge for SW3Packets
but didn't connect in a PocketChain sense[443:

Sun Oct 30 04:29:17 2022 Pulled ULAM and cleaned
up BaseClassUtils.ulam a bit.

:443]

:442]
:441]

:440]
:439]

:438]

:437]

:436]

:435]

:434]

:433]
[432:

Fri Oct 28 11:10:32 2022 I'm really tempted to
make a LoaderUtils.ulam with some native code to
access some special single file, so we can start
modifying the ancestor code without always
rebuilding the loader.

So it would be LoaderUtils that maps between
whatever byte codes we want to use and the current
set of ulam classids and element types. If we want
we can make a perl script to convert from
'assembly' to the LoaderUtils-format byte codes.

Could we rope in the perl crypto framework and
actually sign the byte codes? That would be a
small downpayment against the giant hole we're
having designing LoaderUtils to open.

We'd just have to have LoaderUtils check the sig,
which could be a fair pain

:432]
:431]

:430]

:429]

:428]
:427]
:426]

:425]
:424]

:423]

:422]

:421]

:420]
:419]
[444:

Mon Oct 31 02:16:21 2022 So, we added

    case 'S': { p.mCmd = SW3Packet.cSW3C_HC3CTL; p.mArg = (SW3Packet.Arg) (1u<<2u); /* NW corner to _MAKEDS*/ }
    case 'H': { p.mCmd = SW3Packet.cSW3C_HC3CTL; p.mArg = (SW3Packet.Arg) (0u<<2u); /* NW corner to _MAKEHG*/ }

to convert a NW corner to a DS or (back) to an HG,
and have been trying this program:

  .mProgram = "nwwwsssS."};

to spawn a second DS, and that appears to be
working. Now I'd like to somehow get a copy
program downloaded to that DS, and then regrip DS2
so that incoming Codons get copied to a new loop
there. How many more components will we need to
get to that?

 - Some kind of 'LXCopy <optcount> <opttag> <src> <dst>'
   instruction
 - Some kind of 'move next and regrip' instruction

[445:

Mon Oct 31 02:30:45 2022 What is that instruction?

If unflagged, then
 - Copy me from PA=<SRCDSP> to PB=<DSTDSP>, and
 - Flag the copy, and
 - Mark <PA> to roll forward
 - Regrip to swap <SA> and <SB> (leaving
   pocket status alone.)

else /* flagged */ then
 - Mark <PA> to roll forward
 - Replace self with front of <PA>

[446:

Mon Oct 31 03:38:07 2022 And this is like LXFork?

  LXFork <SDST>

not really fork. It's more like quote or
something. But the replace-self aspect makes it
more than quote.

  LXQuote <SDST>

followed by
  LXCopy <SSRC> <SDST> <COUNT-OR-LABEL>

followed by, like, the whole genome

or is it LXCall, maybe?

Nap time.
[447:

Mon Oct 31 11:19:22 2022 Well, the first-ever
execution of LXDo just worked.. albeit at the
wrong DS. Need an instruction to place a Do at the
end of the construction arm, instead of a literal
LXDo in the ancestor code.

But it appears that the Do pretty much worked
fully as intended:

 - The regrip worked: INS is now SW and OUT is SE
 - The roll worked, and we've got a MK in the OUT
   DSP, which is the next insn after the Do


[448:

Mon Oct 31 11:44:48 2022 Actually I'm wondering if
having a Do at the original DS might be a fine way
to copy instructions down to the second DS - with
a second Do there to receive them.

I think we need a SW3 op to convert an entire ctor
arm to downbound ECs, so we can start pumping full
codons through it.
[449:

Mon Oct 31 14:23:43 2022 So the current
organization of LXCtorArm.perform(DSS&) is a
little unfortunate: It says that unless its in
state RESET or state EXIT, there must be an SW3
arm with which to communicate, or it cuts
out. That means we don't get to state DISPATCH,
which means we don't call dispatchLocal(..), even
though 'local' instructions are arguably exactly
what we'd want to do without an arm.

[450:

Mon Oct 31 23:46:29 2022 OK so the current scheme
for implemented 'BECOME' bottom-up the SW3 isn't
going to work because we don't even try to execute
the packet except at the head. (There's
commented-out code to also try executing at the
tail, but that's it. Middle: nothing.)

So if we're going to get this extra flexibility,
we're going to have to refactor. Maybe have some
SW3Packet Bool map saying where this particular
mCmd is active. Then do pkt.execute(..) in
SwapWormHC3.act(..) rather than down in actUp()
or actDown().

[451:

Tue Nov  1 16:46:22 2022 OK, working on SW3CmdInfo
to provide extra API so SW3Packet mCmd's will be
able to describe what contexts they run in.[452:

Wed Nov  2 00:36:18 2022 Leads up to an ulam
request for enhancement to allow { } in a
struct initializer meaning 'use all default
values'. ATM empty braces are an error.

:452][453:

Wed Nov  2 00:42:36 2022 So what are some ground
rules for this all-dancing instruction execution
scheme?

 - Every SW3Packet propagates all the way to the
   head no matter what codon(s) it executes
   at. That's to keep the seqnos sane

 - There needs to be some rule (per mCmd?) for
   combining mCmdStatus values when an insn
   executes in multiple places. Possibilities:
   = Upstream overrides downstream - detects farthest result
   = US CANT overrides DS DID/TRYING - detects any failure
   = US DID overrides DS CANT/TRYING - detects any success
   = US TRYING overrides DS CANT/DID - detects any pending

[454:

Wed Nov  2 02:16:47 2022 And which would we want
for our only current use-case 'convert to ECs'? I
guess US TRYING overrides DS CANT/DID?

Tell me again why we needed to do all-EC (via
BECOME) from the back forward?

Because we won't detect isHead after there's an EC
ahead of us?

          T         M         H
          S3   ->   S3   ->   S3
op/sts    3/TRY

          S3   ->   S3   ->   S3
          3/TRY     3/TRY

          S3   ->   S3   ->   S3
          3/TRY     3/TRY     3/TRY

          S3   ->   S3   ->   EC
          3/TRY     3/TRY

          S3   ->   EC   ->   EC
          3/TRY

          EC   ->   EC   ->   EC

if we have an 'extended head' concept, where a
'head' can have non-null upstream as long as it's
not pointing at an S3.. then this just works with
none of this complex half-built where-to-execute
flags?

I guess it would really be

          S3   ->   S3   ->   S3
 up       3/DO

          S3   ->   S3   ->   S3
          3/DO      3/DO

          S3   ->   S3   ->   S3
          3/DO      3/DO      3/DO

          S3   ->   S3   ->   EC
          3/DO      3/DO

          S3   ->   EC   ->   EC
          3/DO

          EC   ->   EC   ->   EC

[455:

Wed Nov  2 02:34:16 2022 Is it really this easy?
[456:

Wed Nov  2 09:06:10 2022 OK no, it's not really
that easy. Although the main issues we're seeing
at first are about EC semantics when at the end of
a PocketChain.

Current problem is in Codon.stabilize(..) where if
we're in a DSP that wants us to roll UPWD, but our
mEWSNMate[Segment.cBODY_UP] is 0u, we fail.

And that's a pretty fundamental issue we've signed
up for, what with deploying a DS at the end of a
SW3 arm.

[457:

Wed Nov  2 09:24:51 2022 Well so if we just skip
the sections that deal with an upstream direction
that we don't have, it looks like there's still
moves to be made. I'm wondering if the current
fail is more restrictive than needed.

CodonState.stabilize(..) currently has code like this:

 ..
      // FOR cDSTATUS_UPWD: //< Needs roll toward body up (temp down)

      print("CdnStab15");
      SN upsn = self.mEWSNMate[Segment.cBODY_UP];
>>    if (upsn == 0u || !ew.isAccessible(upsn)) { Fail f; f.fail(__FILE__,__LINE__); }

failing there. And indeed, this ensuing code

      // (1) if reachable layout is   T -> [X]
      //     switch to                X -> [D]
      //     and stay in UPWD

      if (c.isRealMobile()) { // if [X]
        Atom & u = ew[upsn];

, depending on upsn, won't work. But this later
code:

      // (2) if reachable layout is        [D] -> X
      //     switch to                     [X] -> D
      //     and set _IDLE

      if (c.mDSType == c.cDS_DOWN) { // if [D]
        print("CdnStab16");
        SN dnsn = self.mEWSNMate[Segment.cBODY_DOWN];
        if (dnsn == 0u || !ew.isAccessible(dnsn)) { Fail f; f.fail(__FILE__,__LINE__); }
        Atom & d = ew[dnsn];
        if (d as PocketChain) {
          print(d.mDSType);
          if (d.isRealMobile()) {  // and if upstream is X (i.e., mobile nontemp)

could work, and would amount to pulling downstream
insns upstream - which is indeed what we want to
head toward.

And furthermore, all the SW3 in the ctor arm
currently mark themselves as _DUMB, so they'll be
false for isRealMobile(), so we won't go rolling
them upward. (Right? isRealMobile checks that?
Yes: it says 'return mDSType == cDS_NORM'.)

[458:

Wed Nov  2 10:33:24 2022 OK, have to break to deal
with Computing Up and book production, but current
status is this:

 - EC init randomizes from _DUMB to UPWD or DNWD,
   but that causes havoc when not looped

 - EC should probably just sit tight when it's in
   a DSP with cDSTATUS_IDLE? Right now it grows
   and stuff.

(DiamondSequencer.tryExecution(dss) automatically
shifts to cDSTATUS_UPWD if it finds an EC in an X
DSDP.)
[459:

Thu Nov  3 00:14:24 2022 OK, so had another power
failure this afternoon, in which the 9th Symphony
Finale run died, so thanks PNM for that.

:459]
:458]

:457]

:456]

:455]

:454]
:453]

:451]
:450]

:449]
:448]

:447]
:446]

:445]

:444]
[460:

Thu Nov  3 00:28:13 2022 So trying to get
BECOME.EC working (LXCtor op 'E'). Current
question is: What are we supposed to do, on a
dispatchLocal operation, if the operation is
indeed complete?

Overall, it appears dispatchLocal is supposed to
return true if we are doing a local op, and return
false only if we should continue to analyze remote
cases.

Do we just foggen increment mPC, inside
dispatchLocal, once we detect command completion?
Seems out of line on paygrade grounds, but I'm not
sure what else to consider..

[461:

Thu Nov  3 01:11:01 2022 Well, we just did ++mPC
down in dispatchLocal, and now we have

 - a deployed LXDo and
 - a regripped DS and
 - an EC chain reaching all the way to
 - a 2nd DS, which is trying to roll in an insn.

Wow! We're getting pretty close!

Next thing is to get LXDo actually doing something
more than

  Bool performFlagged(DiamondSequencerState & dss) {
    print("DOFL10");
    return false;
  }

[462:

Thu Nov  3 01:15:56 2022 Now, was the theory that
we were going to have LXDo take the next Codon
from its mDstPU, and replace itself with that? And
that was how we were going to get a copy started?

Or how do we control LXDo once it's deployed?

And how do we regrip back once the 'subprocess' is
finished?

Do we grow the loop LXDo is in, and then put the
next insn in the loop with the LXDo, rather than
replacing the LXDo? That sounds right in
spirit. Then that subprocess just calls for next
instruction when it's done, and LXDo comes back in
and does.. who knows what.

And the subprogram we're going to want is
something like

  LXCopy <SSRC> <SDST> <COUNT-OR-LABEL>

as shown back in :446:.

Maybe LXDo could have a COUNT-OR-LABELish type
thing saying how much code it should copy to
itself, like a internal mini loader or something.

But for now let's just say it takes the next insn.
[463:

Thu Nov  3 04:28:22 2022 Hey think of this: We
could take the DS idea, of having HG delegate to
pockets to do chain-related business, and use it
to make Sf suck a whole lot less.

What if we had maybe a three bit field in HG that,
if 1..4, means try calling a special chain method
on a codon in that pocket, and see if there's
something the HG can do for it. Say, only if the
HG grid is relaxed.

Then we could do shapeshifter stuff - both grow
and shrink - atomically. With the HG providing the
simultaneous four pocket access.

Nice.
[464:

Thu Nov  3 08:37:06 2022 Or what if we just called
such a method randomly on Codons from relaxed HGs,
and let the Codons do nothing with it by default?

[465:

Thu Nov  3 08:40:05 2022 But let's focus on LXDo
right now for a little bit.
[466:

Thu Nov  3 09:37:28 2022 OK, the deployed LXDo
just copied the next insn to itself for the first
time. Now the next insn was an LXMarker, which
wasn't very helpful to do that to.. It's time for
LXCopy (which we want eventually to be a stripe of
LXRouteIf natch).
[467:

Thu Nov  3 10:25:54 2022 OK, time to break for
other tasks. Current status:

 - LXCopy is partially implemented, but is mostly
   wrong as a copy of LXDo. LXCopy.perform needs
   to be implemented.
[468:

Fri Nov  4 03:58:56 2022 OK so we got our first
insn copied to the EC chain leading to the second
DS. Yay. But it looks like we will have to
explicitly eject that from the DSP to bring in
another EC to continue the copy.

The 'bring in a temp' function is not very well
tested. Now's the time, I guess.

[469:

Fri Nov  4 04:25:57 2022 OK had some explicit
fails because Codon.stabilize(..) code was
unprepared for open-ended PocketChain.

A bigger, still-pending issue is that when
BECOME/Empty runs down the ctor arm, it creates
all the ECs as _DUMB, and so they all refuse to
swap, so ProcStatus cDSTATUS_TEMP doesn't find
anything to swap with.

What are we supposed to do about that? We're just
passing EmptyCodon.classidof in the BECOME packet;
we can't supply arguments.

Now, EC has an init() method:

      //// EMPTYCODON SERVICES
      Void init() {
        Random random;
        print("ECINIT10");
        print(mDSType);
        mDSType = random.oneIn(2) ? cDS_UP : cDS_DOWN;
        print(mDSType);
      }

which probably would avoid this problem: Down
would head down where we want them, and up would
head up where'd DS#2 would convert them to Down in
the attempt to get a non-EC codon to exectute.

But SW3Packet.tryBecome has no basis to call that.

 ..
    AtomUtils au;
    Int etype = cu.getElementType(classid);
    if (etype < 0) fail(__FILE__,__LINE__);
    Atom a = au.new(etype);
 ..
    ew[s3sn] = a;

Could AtomUtils.new(Int) check if there's a ctor
perhaps, and call that?
[470:

Fri Nov  4 04:44:56 2022 Except our rule in ulam is
you can't define a default ctor, only one with
arguments.

Could we just sleaze it, for now at least, and
have EC initialize itself on first event?[471:

Fri Nov  4 04:48:10 2022 Well, EC is already
initting a giant mTag for itself, so we're now
randomizing cDS_DUMB states in there as
well. Question is whether this will fuck up the
BECOME process by having temps swapping with the
remaining SW3s before the BECOME finished. We
shall see.[472:

Fri Nov  4 05:41:51 2022 Seem to be seeing a
problem with PocketHC3.isDSP(PocketPtr), where
it's claiming true on a pocket that isn't a DSP
pocket (and so it's blocking an EC <=> MK swap I
was expecting to see.)
[473:

Fri Nov  4 06:28:31 2022 OK, so something is
definitely thinkoed. With this layout, say:


            HG5   HG4   HG3   HG2    HG3

                           e2

            HG4   HG3   HG2   HG1    HG2

                     e1

            HG3   HG2   HG1   DS0    HG1


both e1 and e2 decide their
PocketQuadrant.mQuadrant is NW and their
mDSHopContour is 2. And they both seem right.

But, E from e1 IS a DSP, while E from e2 IS NOT a
DSP. But PocketHC3.isDSP(..) says true for both.

And that appears to be why the EC <=> MK swap
isn't going. EC thinks MK is inDSP when it's not.

E from e2 crosses quadrant boundaries while E from
e1 does not, but I see no way to detect that
locally. [474:

Fri Nov  4 07:31:48 2022 If there were two more
HG bits we could store

  Bool isDSXAxis, isDSYAxis;

and then be able to tell when we're crossing an
axis. Would that solve it for us?[476:

Fri Nov  4 07:35:31 2022 It might. But nap
  time.[477:

Fri Nov  4 17:23:16 2022 Well, that took basically
all foggen day - very aggravating - but, pop pop
pop pop, we have a new 'QDSHops' API, with
QDSHopsStg providing storage for both a

  typedef Unsigned(3) DSHops;

and a

  typedef Bool OnDSAxes[2]; // [0] dx==0; [1] dy==0

updated in a messy messy but, finally, apparently
plausible way.

Time to break for cooking but next step is use
this new mOnDSAxes data member to get
PocketHC3.isDSP(..) working more correctly.[478:

Sat Nov  5 00:22:21 2022 OK come on let's fix
inDSP and get closer to seeing a program copy
itself. [479:

Sat Nov  5 00:38:48 2022 So, the hypothesis is
that the isDSP code is workable except (in the key
case) when mDSHopContour == 2u. The code currently
does cases based on the direction the ptr points,
and we want to add a clause inside each of them to
check whether we're pointing across a DS axis. If
we are, we return false, otherwise we return true.

We guess.

[480:

Sat Nov  5 04:47:13 2022 Well so the program has
copied itself. There's bugs bugs aplenty, but hey:
It copied itself. That's been a long time coming.

Nap time.

:480]

:479]

:478]

:477]

:476]

[475: Fri Nov  4 07:33:55 2022 (HardCellG has 20b
unused)  :475]

:474]

:473]
:472]

:471]

:470]
:469]

:468]
:467]
:466]
:465]
:464]
:463]
:462]

:461]

:460]
[481:

Sat Nov  5 10:44:00 2022 So, OK. Let's list
problems we're currently aware of:

 - Copied program grows MKs beyond 2nd DS

 - Copied program needs to start with a CP for DS2
   deployment?
   = Maybe change Cp to Xr for 'transceiver' to
     better convey it does send and receive?

 - Does anything (e.g., LXMarker) actually execute
   at DS2

 - LXCopy needs to recognize/use flag or a
   generation count?

 - Loops are growing too much in general

 - Really need to implement the new atomic loop
   size change idea - grow and shrink - and start
   getting to know it.

:481]
[482:

Sat Nov  5 14:49:11 2022 So, chili in the oven for
another hour or two: What are we thinking about
magic loop growth?

I guess a natural generalization is like
associating actions with a 2x2 patch of pockets,
all surrounding a single core HC3. We have DS as a
special instance of that, and we want a more
generic access to such EWs for uses that don't
require custom state in the HC3.

For example, suppose we say, for a QHardCell

 - There was nothing else to do earlier in the
   event, and

 - If the local grid is fully relaxed, and

 - We hit a 1/N shot, and

 - There's a Pocketable in at least one pocket

   Bool Pocketable.groupAct(QHardCellState & hcs) ;

or whatever we want to call this 2x2 group of
pockets.

[483:

Sat Nov  5 15:20:12 2022 And we come up with a
matching API tailored to these 2x2 pockets, so we
can express stuff like

 - empty pocket

 - pocketable in pocket

 - cw or ccw chain matching XYZ or whatever

and do loop grows and loop shrinks 'pretty
easily'.

[484:

Sat Nov  5 15:56:15 2022 How about a 'stand'? Call
a 2x2 patch of pockets a stand of pockets?

I guess officially the stand is the trees but the
pockets are more like the ground where the trees
might be. A plot?[485:

Sat Nov  5 16:00:03 2022

bed
patch

I guess 'patch' is pretty good. A patch of
pockets. The existing phrase 'patch pocket'
notwithstanding..

   Bool Pocketable.patchAct(QHardCellState & hcs) ;

hmm.

   Bool Pocketable.updatePatch(QHardCellState & hcs) ;

a bit better.

[486:

Sat Nov  5 16:12:08 2022 Are there any other
purposes we can think of for patches, to perhaps
help intuitions before we commit to an API?

 - loop grow:


       .  |  .           EC ->  EC
          |      ==\      ^  |  |
      ----*----  ==/     -|--*--|-
          |               |  |  v
       A ->  B            A  |  B

 - loop shrink

      EC -> EC            .  |  .
       ^  |  |   ==\         |
      -|--*--|-  ==/     ----*----
       |  |  v               |
       A  |  B            A ->  B


 - loop recorner

       B ->  C            .  |  C
       ^  |      ==\         |  ^
      -|--*----  ==/     ----*--|-
       |  |                  |  |
       A  |  .            A ->  B

 - solo pop

       .  |  .            EC <-  EC
          |       ==\      |  |  ^
      ----*----   ==/     -|--*--|-
          |                v  |  |
     ->A  |  .             A ->  EC
    /   \
    \---/


[487:

Sat Nov  5 16:27:25 2022 I guess those are all
invertible so we should do like

 - grow & shrink:

   NW            NE
       .  |  .           EC ->  EC
          |      /==\     ^  |  |
      ----*----  \==/    -|--*--|-
          |               |  |  v
     ->A ->  B->        ->A  |  B->
   SW            SE


 - recorner

       B ->  C->          .  |  C->
       ^  |      /==\        |  ^
      -|--*----  \==/    ----*--|-
       |  |                  |  |
     ->A  |  .          ->A ->  B

 - inflate & deflate

       .  |  .            EC <-  EC
          |      /==\      |  |  ^
      ----*----  \==/     -|--*--|-
          |                v  |  |
     ->A  |  .             A ->  EC
    /   \
    \---/


[488:

Sat Nov  5 17:11:42 2022 And it could be that
instead of segs up and segs down that we currently
have, we could propate 'tightness' and 'looseness'
values to bias the odds on those ops.

So we might, in effect, be able to say things like
'loosen up this loop for processing' and 'tighten
up this loop for diamond cutting'.

Be cool if we could propagate a max hops value
around the loop, so whatever is controlling it
could check if it will fit in a given diamond
cut. (Maybe, maybe.)

:488]
:487]


:486]

:485]

:484]

:483]

:482]
[489:

Sun Nov  6 01:22:31 2022 So, we have dispatched to
Pocketable.updatePatch(..) for the first time -

 ..
    20221106012002-3316: 22AEPS [54402EA7]MSG: print: "QSUPTC12"
    20221106012002-3317: 22AEPS [54402EA7]MSG: (MB) MBase
     :87FF87800000000000000000
    (
     MBase(
     mDecayTimer=(
       XTimer<4u 8u 1u>(
       time=0
 ..

and got reminded that 'membrane base' is a
  Pocketable..[490:

Sun Nov  6 01:23:56 2022 But hmm, there's two
other Pocketables in the patch but it's always
going to MBase?
[491:

Sun Nov  6 01:24:50 2022 Ah, just luck; seeing the
others now too. OK.

So. Pop pop. Now time to do something with this
marvelous updatePatch opportunity we are being
given. [492:

Sun Nov  6 04:00:43 2022 In the middle of getting
PatchState.init(QHC&) set up, but time for second
sleep. [493:

Sun Nov  6 14:06:49 2022 OK so PatchState.init(..)
is seeming plausible and it gives us a bunch of
info that could be useful.. and it's time to move
on to a rules & matching framework for
PatchStates.. [494:

Sun Nov  6 14:10:10 2022 Well, let's just go at
the :487: patterns above, and make stuff up to
represent them.

Let's say 'A' is always at the PatchState.mPSN.
[495:

Sun Nov  6 14:35:56 2022 We want to distinguish
between pocketptrs that point into vs out of the
patch.

We'd like to find patterns based on connectivity
rather than exact layout.

So one starting point, I guess would be to
linearize the fraction of A's chain that we can
see.

PocketPtr mPSNPath[6]; // or something

mPSNPath[0] : upstream of A, cPP_WEST..cPP_EAST,
              or cPP_POUT if points outside the patch
              or cPP_NULL if none
mPSNPath[1] : downstream of A if mPSNPath[0] in patch
mPSNPath[2] : downstream**2 of A if mPSNPath[1] in patch
mPSNPath[3] : downstream**3 of A if mPSNPath[2] in patch

Let's see if we can do that much in a plausible
way..
[496:

Sun Nov  6 15:12:47 2022 So, in 'pattern' terms,
LHS of grow is

  POUT -> PIN -> POUT

LHS of recorner is

  POUT -> PIN1 -> PIN2 -> POUT

where PIN2 != reverse(PIN1)

[497:

Sun Nov  6 15:15:06 2022 Well but we need to
account for the empties and the ECs also.

I guess we could say all unmentioned pockets must
be empty?

LHS grow (RHS shrink):

 POUT1 [A:Y] PIN1 [B:Y] POUT2

RHS grow (LHS shrink):

 POUT1 [A:Y] PIN1 [1:EC] PIN2 [2:EC] PIN3 [B:Y] POUT2

LHS recorner
 POUT1 [A:Y] PIN1 [B:X] PIN2 [C:Y] POUT2

and hmm RHS recorner is the same, in this rep..

[498:

Sun Nov  6 15:43:01 2022 Feeling an
out-of-control complexity bloom coming on. Shall
we just implement some of these rules directly on
top of PatchStatus, and see how that goes, before
getting too crazy here?

:498]

:497]

:496]

:495]
:494]

:493]

:492]

:491]
:490]

:489]
[499:

Mon Nov  7 05:33:20 2022 Typing on the new Kinesis
Advantage 360 USB. So far all is good except can't
figure a way to remap the left Function Key, so
that's a bummer. Seems to be hints that it might
be possible but not via the onboard remapping, but
so far I haven't found any actual documentation on
what that process might look like or any v-drive
file syntax for that.

But I've got the kbd halves so far apart I can fit
both stream decks side by side in between them,
and it feels pretty natural.

We'll see as it sinks in.

It just works so we'll see.

:499]
[500:

Wed Nov  9 23:26:01 2022 Well I'm not sure what
all I was thinking, but having a separation
between PatchState.mPSN (a Pocketable) and the
values of PatchState.mBody{Up|Down}Ptr (from a
Segment) seems pretty wrong. In particular, the
mPSN is gated by mPCount, which counts over all
four pockets, while the mBody*Ptr values are per
pockets.

I think it should be that mPSN indicates a Segment
rather than merely a Pocketable, and that mPSN
selection should be a subtask of mSegmentSN
selection, so that it's guaranteed that mBody*Ptr
values come from a chosen mPSN.

Given that we only use PatchState when there's no
more than one Pocketable in a pocket (right?), I
don't exactly see how this doesn't all work out
the same.[501:

Wed Nov  9 23:54:35 2022 In any case, I've now
rearranged so that selecting mPSN is a strict
subset of selecting mSegmentSN[pd]. Let's see how
that works now.
[502:

Thu Nov 10 01:37:45 2022 Well, took forever etc,
but MatchPatch_GROWB appears to be working in a
basic sense. (It doesn't respect target quadrants
yet but I think that's its main missing bit.)

Let's try to get GROWA working, and maybe refactor
just a bit between them.[503:

Thu Nov 10 02:03:30 2022 OK, seemed to survive a
first-round cleanup into MatchPatch_Rules. Now
trying to call GROWA as an additional option
alongside GROWB. Which highlights we will soon be
needing some rule ordering and priority
scheme..[504:

Thu Nov 10 03:47:16 2022 OK, sigh. I think we're
at a thinko about the whole patch matching design.
I think we want (at least) to have two link types
in each MatchPatchCodon, like:

quark MatchPatchCodon + DTU {
  PatchLinkType mULT;  // Upstream link type
  ChainType mCT;       // Codon type
  PatchLinkType mDLT;  // Downstream link type
}

so, for example, the GROWA LHS:

       .  |  .
          |
      ----*----
          |
     ->A ->  B->

which is current represented like this:

  // o ->   A   ->   B   ->  o    .
  constant PatchPattern cPATPAT_PC2A  = {
    { .mLT = cPLPAT_O, .mCT = cCPAT_Y }, // o -> A
    { .mLT = cPLPAT_I, .mCT = cCPAT_Y }, //   -> B
    { .mLT = cPLPAT_O, .mCT = cCPAT_N }, //   -> o
    { .mLT = cPLPAT_E },                 //   .
  };

would instead be represented something like this:

  // o ->   A   ->   B   ->  o    .
  constant PatchPattern cPATPAT_PC2A  = {
    { .mULT = cPLPAT_O, .mCT = cCPAT_Y, .mDLT = cPLPAT_I }, // o -> A -> i
    { .mULT = cPLPAT_I, .mCT = cCPAT_Y, .mDLT = cPLPAT_O }, // i -> B -> o
    { .mULT = cPLPAT_E },                 //   .
  };

[505:

Thu Nov 10 04:14:19 2022 Typing it out it doesn't
look as helpful as I was imagining. We still have
to look ahead for a cPLPAT_E, and avoid trying to
dereference the mCT then. And we're still
implicitly assuming we link downstream to move
between MatchPathCodon's. Which is fine as far as
it goes but it also means we can't represent, for
example, necessarily empty quadrants.

[506:

Thu Nov 10 04:37:22 2022 What if we went to an
overtly patch-oriented matching format, instead of
this current pocketchain-oriented format? Always
four patterns exactly, saying what has to appear.

Maybe in a slightly abstracted format, where the
pattern is written assuming we start in the upper
left path, and the other patches are cw and ccw
from there.

    +---+---+
    |   |   |
    +---+---+
    |   |   |
    +---+---+

PatchCodon mPatchRule[4];

quark PatchCodon {
  PatchProperties
    empty - must be empty
    codon - must have one codon
    unchecked - could be anything
  CodonProperties
    ChainType code
  LinkProperties
    NewPatchLinkType upPLT
    NewPatchLinkType downPLT
}

NewPatchLinkType
  out - to outside patch
  cw - next pocket clockwise
  ccw - next pocket counterclockwise
  null - null

:506]

:505]

:504]

:503]

:502]

:501]

:500]
[507:

Thu Nov 10 16:29:31 2022 Moving flag.
[508:

Fri Nov 11 01:46:47 2022 OK let's try to make
a PatchRule do something.
[509:

Fri Nov 11 02:09:34 2022 We're going to say the
layout of a patch follows the quad ordering:

    +---+---+
    | 0 | 1 |
    +---+---+
    | 3 | 2 |
    +---+---+

so we should be able to make routines to map
between 'logical' and 'physical' patch pockets and
directions.

physical

    +---+---+
    | 0 | 1 |
    +---+---+
    | 3 | 2 |
    +---+---+

logical mStart 0, mReverse false
    +---+---+      +---+---+ l->p  if (mReverse) l ^= (l&1)<<1
    | 0 | 1 | l->p | 0 | 1 |       p = (l + mStart) & 3
 l= +---+---+   p= +---+---+
    | 3 | 2 | l<-p | 3 | 2 | l<-p  l = (p + 4 - mStart) & 3
    +---+---+      +---+---+       if (mReverse) l ^= (l&1)<<1

logical mStart 0, mReverse true
    +---+---+      +---+---+ l->p  if (mReverse) l ^= (l&1)<<1
    | 0 | 3 | l->p | 0 | 1 |       p = (l + mStart) & 3
    +---+---+      +---+---+
    | 1 | 2 | l<-p | 3 | 2 | l<-p  l = (p + 4 - mStart) & 3
    +---+---+      +---+---+       if (mReverse) l ^= (l&1)<<1

logical mStart 1, mReverse false
    +---+---+      +---+---+ l->p  if (mReverse) l ^= (l&1)<<1
    | 3 | 0 |      | 0 | 1 |       p = (l + mStart) & 3
    +---+---+      +---+---+
    | 2 | 1 |      | 3 | 2 | l<-p  l = (p + 4 - mStart) & 3
    +---+---+      +---+---+       if (mReverse) l ^= (l&1)<<1

logical mStart 1, mReverse true
    +---+---+      +---+---+ l->p  if (mReverse) l ^= (l&1)<<1
    | 1 | 0 |      | 0 | 1 |       p = (l + mStart) & 3
    +---+---+      +---+---+
    | 2 | 3 |      | 3 | 2 | l<-p  l = (p + 4 - mStart) & 3
    +---+---+      +---+---+       if (mReverse) l ^= (l&1)<<1

logical mStart 3, mReverse false
    +---+---+      +---+---+ l->p  if (mReverse) l ^= (l&1)<<1
    | 1 | 2 |      | 0 | 1 |       p = (l + mStart) & 3
    +---+---+      +---+---+
    | 0 | 3 |      | 3 | 2 | l<-p  l = (p + 4 - mStart) & 3
    +---+---+      +---+---+       if (mReverse) l ^= (l&1)<<1

logical mStart 3, mReverse true
    +---+---+      +---+---+ l->p  if (mReverse) l ^= (l&1)<<1
    | 3 | 2 |      | 0 | 1 |       p = (l + mStart) & 3
    +---+---+      +---+---+
    | 0 | 1 |      | 3 | 2 | l<-p  l = (p + 4 - mStart) & 3
    +---+---+      +---+---+       if (mReverse) l ^= (l&1)<<1

  PocketDir l2pPatchIndex(PocketDir l) {
    if (mReverse && (l % 2u != 0u))  l = (PocketDir) (4u-l);
    return (PocketDir) ((l + mStart) % 4u);
  }

  PocketDir p2lPatchIndex(PocketDir p) {
    PocketDir l = (PocketDir) ((p + 4u - mStart) % 4u);
    if (mReverse && (l % 2u != 0u))  l = (PocketDir) (4u-l);
    return l;
  }
[510:

Fri Nov 11 03:09:39 2022 Well that looks plausible
but took foggen forever.

[511:

Fri Nov 11 04:21:50 2022 OK, that looks plausible
in PatchRulePatternBinding. Do we understand
enough to do PocketPtr mapping, or do we need more
demand for it first?

Let's go for some kind of match service and see
what it needs.[512:

Fri Nov 11 10:37:35 2022 OK so we have first-cut
code at matching PRPocket patterns, and now we
need to create an actual rule in this new
representation.

But first brunch.
[513:

Fri Nov 11 11:55:49 2022 OK getting down to trying
to match actual ChainTypes now, in this new Patch
context. Seeing that lots of service methods like
ChainTypes.isEC(..) and .isX(..) take a
MatchCodePosition as an arg. What is that again?
Do we have it or an analog to it here?[514:

Fri Nov 11 11:57:40 2022 It's supposedly:

      //// LOGICAL POSITIONS ALONG A POCKETCHAIN RELATIVE TO US
      typedef Unary(2) MatchCodePosition;
      constant MatchCodePosition cMCP_PREV = 0u;
      constant MatchCodePosition cMCP_HERE = 1u;
      constant MatchCodePosition cMCP_NEXT = 2u;

aaand what does isX/isEC do with that?[515:

Fri Nov 11 11:58:38 2022 Seems like finally they
pass it to PocketChainState.isInDSP(MCP). What
does it do?

It goes into

  Bool mInDSP[MatchCodePosition.maxof + 1u];

with it. PocketChainState explicitly initializes
in terms of the 'DSPness' of upstream, me, and
downstream pocketchains.

But we don't have a PocketChainState here at all.

So I think we're going to need redone isX-ish
stuff. After nap.[516:

Sat Nov 12 00:08:40 2022 So it 'all comes down' to
how do we compute mCornerDSHops-like info from the
point of view of an HC3 instead of a pocket?

And then I think we want PatchState to do that,
and set up like

  Bool mInDSP[PocketDir.maxof + 1u]; // true if pocket in DSP

Now, we already know that the patch is relaxed and
everything is happy, so let's just take the
easiest case and see how it could go

    +---1---+  +---0---+  +---1---+  0---1---2
    | T | T |  | T | T |  | F | F |  | T | F |
    1---0---1  2---1---2  3---2---3  1---2---3
    | T | T |  | F | F |  | F | F |  | F | F |
    +---1---+  +---2---+  +---3---+  2---3---4

OK the challenge is in the last one. We can't see
the far corner HC3's so we have to infer crap
about them. Because it's really like:

    ?---1---?  ?---0---?  ?---1---?  ?---1---?
    | T | T |  | T | T |  | F | F |  | T | F |
    1---0---1  2---1---2  3---2---3  1---2---3
    | T | T |  | F | F |  | F | F |  | F | F |
    ?---1---?  ?---2---?  ?---3---?  ?---3---?

Is it like if you see a 0 or two 1's, you're
inDSP? Kind of looks that way, hunh? Among the
three HC3's that each pocket can see.

Let's give it a shot.

:516]

:515]

:514]

:513]
:512]

:511]

Now I presume we also will need to map from
logical index + ('cw' | 'ccw') to physical
PocketPtr directions.

Well let's start with logical to logical:

     cw(l) = (l + 1) % 4
    ccw(l) = (l + 3) % 4

that's pocketdir to pocketdir.

[517:

Sat Nov 12 09:29:58 2022 We're up to needing a way
to tell if logical quadrant + logical direction
(out, cw, ccw, null) apply to a given
PatchRulePatternBinding.

[518:

Sat Nov 12 10:46:14 2022 OK so we just plausibly
matched our test patchrulepattern
(PatchRules.cPCHRUL_GROWA) for the first
time. Which took forever but it's only half the
problem. Now we need to apply the rule somehow.

The presumption is we'll use custom code for the
RHS rather than try anything more magically
descriptive. [519:

Sun Nov 13 00:25:41 2022 OK so it's time to
fogging apply a successful PatchRule match. I'd
think we'd like to express changes in logical
space and have them get mapped to physical space
by the l2p routine(s?) [520:

Sun Nov 13 00:30:37 2022 Maybe we can record some
digested mapping stuff in PatchRulePatternBinding
- like say the matched codon SNs - to help out
these updates now. Or do we already have them
anyway in PatchState, if we just have the wit to
know that?

[521:

Sun Nov 13 01:34:40 2022 So we're trying to apply
a rule like this:

   NW            NE
       .  |  .           EC ->  EC
          |       ==\     ^  |  |
      ----*----   ==/    -|--*--|-
          |               |  |  v
     ->A ->  B->        ->A  |  B->
   SW            SE

except given the logical numbering

    +---+---+
    | 0 | 1 |
    +---+---+
    | 3 | 2 |
    +---+---+

it's really a rule like this

     ->A ->  B->        ->A  |  B->
          |       ==\     |  |  ^
      ----*----   ==/    -|--*--|-
          |               v  |  |
       .  |  .           EC ->  EC


so first up we want to get our hands on A and B as
Codon&s. So we want a routine to do that.

  Codon & l2pGetCodon(PatchState & ps, PocketDir l)
    - fail if not valid etc or l2p not codon
    - return ew[..]

[522:

Sun Nov 13 02:15:27 2022 OK and we'll need a way
to make logical PocketPtr ptrs into physical
ptrs. Aand that won't depend on the logical
PocketDir, right? A direction is a direction no
matter where we start. So it's like

  PocketPtr l2pGetPocketPtr(PocketPtr l)

? That doesn't seem like enough. Does the mapping
depend on mReverse, for example? Well but wait, we
don't really have NSEW PocketPtrs at the logical
level, we have PLTypes

  constant PLType cPLTYPE_OUT  = 0u; //< Link must head out of patch
  constant PLType cPLTYPE_CW   = 1u; //< Link must head clockwise around patch
  constant PLType cPLTYPE_CCW  = 2u; //< Link must head counter-clockwise around patch
  constant PLType cPLTYPE_NULL = 3u; //< Link must be null

and mapping those to physical PocketPtrs clearly
depends on mStart and mReverse and, for _OUT, on
the actual underlying codon ptrs?

But for creating new EC's (for example) we'll want
l2p absolute directions too.

     ->A ->  B->        ->A  |  B->
          |       ==\     |  |  ^
      ----*----   ==/    -|--*--|-
          |               v  |  |
       .  |  .           EC ->  EC

we want to say cPP_WEST for the EC -> EC and get
the right thing to stick in there.
[523:

Sun Nov 13 09:18:23 2022 OK, so the new magic
GROWA rule is finally starting to work.

Oritee then.

It grows like crazy once it gets started, because
it's got sensitivity to neither target quadrant
nor density, but that's as expected so far.

Step by step.

Let's try a shrink rule, and try to see something
that ShapeShifter has never yet done..
[524:

Sun Nov 13 09:23:42 2022 So now we want:

     ->A  |  B->        ->A ->  B->
       |  |  ^    ==\        |
      -|--*--|-   ==/    ----*----
       v  |  |               |
      EC ->  EC           .  |  .

[525:

Sun Nov 13 10:19:30 2022 Ooh there's an issue:
PatchRule_GROWA just stuck a couple EC's in the
middle of a SW construction arm and fucked it
up.

Now, the SW atoms are all marked cDS_DUMB, so they
can't be moved.. but the GROWA rule didn't move
them, it just stuck EC's in between. How are we
supposed to say that's bad?

For now, changing GROWA to match with cCPAT_X
instead of _Y.

[526:

Mon Nov 14 00:04:07 2022 OK let's try to stop
making Sf's at all, and see how much we need to do
to get back to something like working..[527:

Mon Nov 14 00:35:48 2022 We need a rule like

       A <-> B            A ->  B
          |       ==\     ^  |  |
      ----*----   ==/    -|--*--|-
          |               |  |  v
       .  |  .           EC <-  EC

maybe call it GROWB in this new code regime.

:527]

:526]

:525]
:524]
:523]
:522]

:521]


:520]

:519]

:518]

:517]

:510]
:509]

:508]
:507]
[528:

Mon Nov 14 01:25:49 2022 We're back where we
started! Except ShapeShifter is gone! Yay!

POP POP POP

Let's clean up a little and commit a WIP, come
on.
[529:

Mon Nov 14 04:06:00 2022 OK pushed
Sequencer213.

Nap time.

Then need to switch over to writing the foreword
for the book.

:529]

:528]
[530:

Mon Nov 14 11:35:11 2022 Opps well I feel
compelled to rewrite the loop killer so that it
works on open chains as well as loops, while
preserving its 'the original LK is the last to go'
property.

[531:

Tue Nov 15 23:27:38 2022 OK well did that, then
branched off to book stuff. Which I'll have to do
again in a few hours. But let's try to stay fresh
by flipping back here for a task or two.

OK how about taking on something in here:

 - A structure for collecting and selecting among
   the rules. That's all a huge hack right now.

   = Think roulette selection possibly? Or maybe
     some O(1) stochasto hack instead of the
     'true' O(n) odds.

 - Respecting targetquadrant (at least in growth
   rules)

 - Optimizing against some desired mDSHops

 - Replacement for tempsdown/segsdown aimed at
   specifying desired loop density (and perhaps
   other properties).

[532:

Wed Nov 16 00:36:29 2022 What if we had a map of
quadrants and a map (interval? scalar?) of desired
distances? We also need a desired density? Or we
do that implicitly by spatial constraints?

How many bits are we talking about maybe?[533:

Wed Nov 16 00:40:19 2022 Without increasing the
current PocketChain size, we got at least 16 bits
freed up by ditching m{Segs|Temps}{Up|Down}. 17 if
we toss the currently unused mArrived.

Suppose:

 - 4 bits for tq map
 - 4 bits for 'size ranges', like maybe
    0 0-3
    1 4-7
    2 8-11
    3 12+
[535: Or

    0 0-1
    1 2-7
    2 8-15
    3 16+

?

  :535]

x 2 for {Up|Down}

and suppose we have some scoring function that
measures the penalties of a given layout, or more
operationally, the delta penalty of a given rule
application.
[534:

Wed Nov 16 01:18:54 2022 Could we have a return
path, like a wire-OR, to detect if there's any
violations of the current mapping? Maybe that's
what mArrived could be repurposed to.

Anchors set mOoB to false.. We're going to need
mOoBUp and mOoBDown if we're not guaranteed to
have a loop.

But it's another contact warning concept. If it's
cPP_NULL beyond, or a designated anchor, then
originate mOoB at that point. Otherwise, propagate
in the specified directions, incorporating your
own constraint violations if any.

[536:

Wed Nov 16 02:30:33 2022 And then one anchor can
agree to loop the signal around to one end, if
they want a single decision point. Or they could,
if they wanted, control the up and down
configurations independently, and ask patch rules
to compute up and down separately, and sum them up
or something.
[537:

Thu Nov 17 00:43:47 2022 Let's try to set up
structure for these signals. Goal is to replace

  | 0	| 4	| mSegsDown	| Unsigned(4)
  | 4	| 4	| mTempsDown	| Unsigned(4)
  | 8	| 4	| mSegsUp	| Unsigned(4)
  | 12	| 4	| mTempsUp	| Unsigned(4)
..
  | 18	| 1	| mArrived	| Bool

with like

quark ChainCtl {
  typedef Bits(4) TQMap; //< Target Quadrant Map
  TQMap mTQMap; //< currently acceptable target quadrants

  typedef Unsigned(2) SizeRange;
  constant SizeRange cSZRG_S = 0u; //< small
  constant SizeRange cSZRG_M = 1u; //< medium
  constant SizeRange cSZRG_L = 2u; //< large
  constant SizeRange cSZRG_X = 3u; //< extra large / rest

  typedef Bits(4) ASRMap; //< Allowable Size Range Map
  ASRMap mSRMap; //< current acceptable size ranges
  constant ASRMap cASR_S = 1u << cSZRG_S;
  constant ASRMap cASR_M = 1u << cSZRG_M;
  constant ASRMap cASR_L = 1u << cSZRG_L;
  constant ASRMap cASR_X = 1u << cSZRG_X;

  Bool mViolation; //< Map violation return signal
}

and then in PocketChain, probably:

 ..
  ChainCtl mChainCtlUp;
  ChainCtl mChainCtlDn;
 ..

and in PocketChainState.stabilize(..)

 Bool upc = mChainCtlUp.stabilize(..);
 Bool dnc = mChainCtlDn.stabilize(..);
 if (upc || dnc) return true

and some ChainCtl API to get the current local
violations, which ChainCtl.stabilize(..) will call.
[538:

Thu Nov 17 10:03:49 2022 OK, well,
PocketChain.mChainControlUp and Down are in but
not yet in use, and m{Segs|Temps}{Up|Down} are
diked out, and stuff still seems to work.

We're going to need some kind of plan to get the
ChainControl stuff going.

[539: Fri Nov 18 01:50:54 2022 Made a cut
DONE :539] - Propagation
   Bool takeFrom(ChainControl & source)

 - Local evaluation
   Int violations(PocketChainState & pcs, PocketPtr ptr)

 - Root detection
   Bool isRoot(PocketChainState & pcs) ?

 - Root update ?

[540:

Fri Nov 18 08:42:26 2022 So I guess it's not even
clear to me at the moment how we know what target
quadrant we're in, during an HC3/Patch event?

Hmm: What if we repurpose the
PocketChainTQ.mTargetQuadrant bits to represent
not the target quadrant, but the quadrant we're
currently occupying? After all, we have moved the
actual targeting info to ChainControl.mTQMap, so
it would be a net zero shift beyond that.

I guess main worry is: But then how do we evaluate
the target quadrant of empty patch pockets? Try to
infer it from the non-empty ones? That doesn't
seem like much fun. Burn more bits in the HC3?
That undercuts our still-clung-to-tho-unsure-why
goal of not having 2D coord info explicitly
represented in the grid.


[541:

Fri Nov 18 09:14:31 2022

        0  1  2
           |
        7--*--3
           |
        6  5  4

Could be three bits, with evens representing
target quadrant (*2) and odds representing on-axis
in the four (-y, +x, +y, -x) dirs.

And that's partly redundant with the DSHops info -
but not completely - and has the advantage that we
could determine tq out to arbitrary distance.

[542:

Fri Nov 18 09:24:48 2022 Buut I guess it all goes
to crap if the grid isn't solid? Because once
we're off-axis we don't know how far off-axis we
are, so we can never re-infer 'on-axis' once
lost.

But I guess we're long since committed to that
anyway. If we have gaps in the grid all kinds of
stuff becomes untrustworthy?

So maybe it could be okay?
[543:

Fri Nov 18 09:45:24 2022 So the idea would be:

 - Add 'typedef Unsigned(3) DTU.Heading' or
   something? 'Zone'? With constant defs

 - Add like Zone QDSHops.getZone() ;

..wait.. DTU/QDSHops already has

  typedef Bool OnDSAxes[2];

is anybody using that?[544:


Fri Nov 18 11:25:32 2022 Yes people are using it -
in particular, PocketHC3.isDSP(PocketPtr) is using
it to determine if the ptr is pointing across a ds
axis, which affects the inDSP determination.

So, two questions:

(1) Can OnDSAxes do our HC3 DSQuadrant question?
(2) Can our 'Zone' concept do the OnDSAxes work?
[545:

Fri Nov 18 16:29:02 2022 I guess part of the
answer to (2) is that, since nobody except the DS
itself can be on two DSAxes at once, the Zone
concept can do the OnDSAxes work if we build
support for it into QDShops/QDSHopsStg.

Suggesting maybe try the Zone with a shim to
provide OnDSAxes?

:545]

:544]

:543]
:542]

:541]



:540]
:538]
:537]

:536]

:534]
:533]

:532]

:531]

:530]
[546:

Sat Nov 19 02:37:39 2022 OK, how exactly do we
merge ngb's zone into our own?

(1) Ignore them unless their dshops < our dshops
(2) They are at

   C2D off

wrt us, stylized as off.length()==1, and we also
have their

  XZone ngbxzone

(3) If ngbxzone is uninit, ignore them

(4) ngbxzone is initted.

(5) map ngbzone to C2D
    _CT -> (0,0)
    _NT -> (0,-1)
    _NE -> (1,-1)
    etc

(6) if ngbc.length() == 0u (meaning zone root)
    ourzone = zoneFromC2D(off) [done]

(7) if ngbc.length() == 1u (meaning on an axis)

    0,0 -- 1,0  ngbc     +1,0  -- (2,0)
            |   +0,1 off
          (1,1) sum


   ourzone = zoneFromC2D(ngbc + off)
      (where zoneFromC2D takes arb C2D)
   [done]

(8) ngbzone is fully off-axis (length() == 2)

 (0,0) -- (1,0) -- (1,0)
            |
          (1,1)             (   )
            |                 |   [0,-1]
          (1,1) -- (1,1) -- (1,1)

..don't see how this case can come up, with a
solid grid and ignoring if ngbdshops >= ourdshops

so does that imply just ourzone = ngbzone,
regardless of off, in the remaining cases?

Maybe does?

:546]
[547:

Sun Nov 20 08:04:43 2022 OK so I got crap to build
again, but lots of things are torn up. OnDSAxes
half-still-exists but is certainly broken;
Zone and XZone exist in a bunch of places but
isn't plumbed in.
[548:

Sun Nov 20 08:08:02 2022 So the still-seeming
plausible :546: stuff goes in where?
Somewhere in QHardCell.stabilize I guess? Let's go.
[549:

Sun Nov 20 08:13:43 2022 And one issue is that
QHardCell.stabilize mostly just dispatches to
QHC.update(QHCS&), which is ancient hideous
ancient ancient code.[550:

Sun Nov 20 08:15:08 2022 The main source of
elaborated truth in QHardCellState is its
mHC3State data member, which now has stuff like:

      // values from the Intender
 ..
      Unsigned myDSHops;
 ..
      XZone myXZone;

      // reductions from the ngbs
      Unsigned minDSHops;
 ..
      XZone xzone;

with myXZone getting initted via qhc.getXZone(),
and xzone currently not getting initted at all.

There's an incomplete HC3State.updateZone() method
we could be trying to flesh out, which nobody
calls yet.

So,

Q1: Can we do :546:-ish stuff during
    HC3State.init(..)? Do we have enough
    information? Well,

Q2: What information does :546: need?

A2: It needs:
    our dshops vs the ngb's dshops, and to have
    that be already stable.

Q3: Do we have that? Where is the 'our dshops is
    good' made?

A3: One place where we determine that we're
    uninitted, in QHC.update(QHCS&). That's
    clearly later than QHCS.init(..)

    Another place is later in QHC.update(QHCS&),
    if myDSHops != minDSHops + 1.

    Only after that point could we say 'our dshops
    is good'.

[551:

Sun Nov 20 08:45:09 2022 Which might seem like
progress but later in that same hideous update
function we go all the way to deciding whether we
want to move. So it's not like we want to wait
until QHC.update(..) returns before stabilizing
the xzone.

Ugh.

Do we dare think about breaking up QHC.update(..)?

Well, do we, punk?

What kind of chunks could we break it up into?
Certainly get deciding-to-move stuff out of there.

Let's do a little inventory and see how far we
get.. Let's try to route the pieces to

 init
 observe
 stabilize
 act

(0) QHCS.init done before update starts
[554: Sun Nov 20 11:24:29 2022 WD reset moved to
QHCS.init, so
DONE :554](1) Watchdog reset -> QHC or QHCS init
[555: Sun Nov 20 11:26:12 2022 Moved to observe
DONE :555](2) HC3State.examineNbgs
    - does HC3NgbState.init(..)
    - which allegedly sets up HC3NgbState.mXZone
    - and sets up minUpHops and the like
    -> Move this to QHCS.observe(..) ?
[556: Sun Nov 20 11:29:33 2022 Made
      QHCS.initIfNeeded() called from stab, so
DONE :556](3) QHC self init -> stabilize ?
[557: Sun Nov 20 11:33:23 2022 Made
QHCS.stabilizeHopsOrDie for this, so
DONE :557] (4) update goal hops / maxhops -> stabilize ?
[558: and DONE  :558](5) QHC self destruction -> stabilize
[559: and DONE  :559](6) update DSHops -> stabilize ?
[560: and DONE  :560](7) update maxhops -> stabilize
[561: Sun Nov 20 11:37:56 2022 Made
stabilizeContactWarnings,
DONE :561](8) .. refresh settleddownhops -> stabilize
[562: DONE  :562](9) update contactwarnings -> stabilize
[563: Sun Nov 20 15:44:08 2022
DONE :563](10) spawning (grow grid) -> stabilize? act?
[564: Sun Nov 20 15:47:57 2022
DONE :564](11) considerations for grid motion -> act ?
[565: DONE  :565](12) moveEntourage -> act
[566:

Sun Nov 20 15:48:06 2022 OK, well, QHC.update(..)
is 'gone', split into a bunch of more specifically
named functions. Let's see how long it takes to
get back to buildable.[567:

Sun Nov 20 16:11:32 2022 Well, at least getting to
slower build failures now..[568:

Sun Nov 20 16:14:23 2022 Ugh it built. Call
it.. about 25 minutes to buildable.

But that's just the beginning, of course. Let's
see how badly it blows up.[569:

Sun Nov 20 16:15:40 2022 OK, first issue: It's
spawning MB all over the place in the middle of
the grid. That's different. Let's see if they
settle away..[570:

Sun Nov 20 16:17:14 2022 Well, looking like they
do, but they're taking their sweet time about it.
[572:

Sun Nov 20 16:19:26 2022 OK, I see MBase's getting
created in (our shiny new)

  Bool stabilizeSpawning(QHardCell & qc)

in QHCS. It's under

    if (hc3.myUpHops < hc3.myUpHopsGoal - 1u) {
  .. } else {

    make MBase in here

  }
[573:

Sun Nov 20 16:23:08 2022 Hmm, debug output says we
get all the way into act(..) on the same event
that an MB gets spawned..[574:

Sun Nov 20 16:25:20 2022 Well, there was a
commented-out 'return true;' right after spawning
the MB, so that 'explains' that part. I have
reinstated that.. But still not sure why we got to
spawning.. Maybe some other 'return true' earlier
got lost in the new flow.[575:

Sun Nov 20 16:45:25 2022 Ah hmm it seems we're not
bailing after initting ourselves? And that leads
to spawning bogus MB's?[576:

Sun Nov 20 16:46:56 2022 Ah. The problem is, for
some reason, QHCS.block() returns false. That's a
pretty nasty trap given our pretty damn strong
conventions. It sets an mIsBlocked flag and then
returns false. Does anybody look at that
flag?[577:

Sun Nov 20 16:48:10 2022 No. Let's kill it, return
true, and hack back to daylight that way.[578:

Sun Nov 20 16:53:19 2022 OK that seems fine. Next
up: Why don't the grid move? But time for cooking
first.
[579:

Sun Nov 20 17:19:52 2022 Looks like maybe the
grid's not moving because mSettledDownHops never
gets bigger than 1. Why is that?[580:

Sun Nov 20 17:21:42 2022 Ah, perhaps because the
DS has mSettledDownHops == 0u. Why is that?[581:

Sun Nov 20 17:22:58 2022 Well, part of the trouble
is we had

    if (!(self is DiamondSequencer)) {

instead a QHardCellState method. So self was NEVER
going to be a DiamondSequencer. It wanted to be

    if (!(qc is DiamondSequencer)) {
[582:

Sun Nov 20 17:27:56 2022 Aand the grid is moving
again. Step by step.[583:

Sun Nov 20 22:42:36 2022 OK. Let's get zones
working somehow, here.
[584:

Mon Nov 21 00:34:47 2022 So we haven't actually
fired off the zone stuff anywhere yet? Where do we
want to do it, now, in our modern broken-out
world?

:584]
:583]

:582]
:581]

:580]

:579]

:578]

:577]

:576]

:575]

:574]

:573]
:572]
[571:

Sun Nov 20 16:17:47 2022 (Also, second issue: grid
appears to no longer be interested in ever moving.)

:571]

:570]

:569]

:568]

:567]

:566]
[552:

Sun Nov 20 09:42:17 2022 Well that's quite the
list. I'm thinking about pushing on to
Sequencer214 and trying to tear up QHC.update(..)
along those lines.

It's November 20th by the way, Dave. Week and a
half left in 'nanowrimo' just saying.
[553:

Sun Nov 20 09:59:08 2022 Well, I'm calling this
T2Demo 'Ancestor10' instead of
'Sequencer214'. Time to start turning base here.

:553]
:552]

:551]


:550]

:549]
:548]

:547]
[585:

Mon Nov 21 02:15:56 2022 OK, I think HC3 zone
assignments are (finally) looking plausible.

[586:

Mon Nov 21 02:22:06 2022 Eeeeeeeeehhhhhhxcept that
because we only look updshops to find zone info,
and dshops poops out at 7u, the zone info seems to
go wacky at the periphery.. I mean, I know that's
what we signed up for and all, but..
:586]

:585]
[587:

Mon Nov 21 08:17:45 2022 So I had the idea while
snoozing: To 'reposition' the program prior to
cell division, why not move the grid root during
growth, so that the original DS and program gets
farther and farther off-center as the grid
expands?

And I've just been trying a few spikes on this for
the last half hour or so, with these thoughts:

 - Moving the root can work

 - Moving the root and increasing maxhops
   simultaneously means double growth happens on
   the 'leading' edge of the grid and none on the
   trailing edge - but the current membrane scheme
   doesn't claim that much clearance exists. We'd
   have to invent cilia again or something to
   extend the sensor range.

 - Moving the root without increasing maxhops
   means we lose area on the trailing edge of the
   grid - and any pocketchain in the no-longer
   closed pockets gets unhappy.

So all this makes me wonder: What if we did some
or all of the ChainControl SizeRangeLimits in
terms of distance from the edge, from maxhops,
rather than distance from the center?

(Now there may well be confusion between DS root
and grid root, here.. We'd need it to be grid
root, for this scheme, even though I'd been
imagining it as DS root based.)

Maybe, though, we could ditch the S, M, L, XL
approach in favor of more eclectic
categorizations.

 A: Stay within small dshops range (0..3)
 B: Stay within large dshops range (4..7)
 C: Avoid pockets with uphops >= maxhops-1
 D: Avoid pockets with uphops >= maxhops-2 ?

Of course since we only have a single 'violation'
return channel, if we choose inconsistent
categories we'll always see violation. (But I
don't think any of those sample possibilities
are. Oh wait, of course they might be inconsistent
because AB is dshops but CD is uphops.. so if DS
root and grid root are far apart, who knows? Like
A + D could be inconsistent if DS is close to
maxuphops.)

[588:

Mon Nov 21 09:08:08 2022 Maybe we should try a
hack to just try to keep pocketchain out of the
periphery, period just that, and see how it goes?
[589:

Mon Nov 21 10:47:12 2022 Well, I made a hack in
HardCellG.rootBehave that now does two 'grows' and
then one 'root shift' in a cycle. That, plus a hack
in PatchRule.match(..) case cPRPU_EMPTY to keep
from matching unless PatchState.nearUpHopsEdge(..)
returns false, gets things working, without doing
the combined grow-shift that exceeds the membrane
safe zone.

So it's pretty much a hack - and it really delays
completion of of ancestor program loading - but it
does seem to work.

Getting to be time to move the flag, but I think
next up is trying to implement zone restrictions

[590:

Mon Nov 21 10:53:53 2022 'When' we shift to
programmed control of grid growth, we could do
something more sophisticated than just a
grow-grow-shift iteration.

Like, just do grows until loading completes, then
just do a grow-shift iteration (which doesn't
create net new space in the trailing direction)
afterwards.

:590]

:589]
:588]

:587]
[591:

Mon Nov 21 11:03:13 2022 Do we have ChainControl
propagation plumbed-in yet? I can't remember.[592:

Mon Nov 21 11:13:25 2022 Looks like we make and
init PocketChain.

 mChainControlUp and
 mChainControlDown,

but we never propagate anything through them
[593:

Mon Nov 21 11:31:18 2022 I left marks at
PocketChain.ulam:352 and :357 where I thought the
propagation could go (by analogy to the old
segs/temps stuff), but nothing's moving so far.
[595:

Mon Nov 21 16:14:05 2022 And getting into it, I'm
not confident that's the right place/way to
propagate. It's depending on mDSType, which is the
direction a temp wants to move, rather than on
BODY_UP and _DOWN explicitly.[596:

Mon Nov 21 16:18:29 2022 I'm tempted to put in a
separate function for the chain controls and do it
separately. It's not like we're going to need
another ew iteration or anything, right?
[597:

Tue Nov 22 06:29:38 2022 Did it separately. Kind
of working I think. Needs design to send signals,
and react to sent signals, and to report
violations, and respond to reported violations.

 - suppose we have the DSP hold the signal: When
   codons swap in and out of a DSP, the
   chaincontrols do not not swap with them. They
   stay behind. So somebody anybody who can change
   the DSP chaincontrol signals, can have lasting
   effect on that chain regardless of detailed
   motions. 'Having the con' runs with the land,
   not its current occupant.
[598:

Tue Nov 22 10:36:35 2022 Well, I don't
know. There's a whole lotta swappen going on..
feels like it would be hard to control them
all. Could we go the other way, and have
ChainControl.atEnd(PCS&) go out looking for loop
control signals?

Ugh. Feels recurso. And crowded, given we might
have four loops needing ChainControl info all
crammed together at the DS.

And anyway wait: We have managed to keep the DSP
contents stable until we want it to change, so
doesn't that argue we should be able to keep
ChainControl info similarly stable?

Where exactly is the ProcStatus stuff implemented?
[599:

Tue Nov 22 10:57:46 2022 I think it's (at least
mainly) in CodonState.stabilize(..)[600:

Tue Nov 22 10:59:31 2022 Looks like there's maybe
six relevant calls on swapPocketPtrs + doSwap in
various places there. Maybe we could make a
doDSPSwap or something to handle these cases?

:600]

:599]
:598]
:597]
:596]

:595]
:593]


:592]

:591]
[594:

Mon Nov 21 14:02:16 2022 Flag moved.

:594]
[601:

Wed Nov 23 01:12:16 2022 OK, well, one ish
later, it looks like we have DSP holding the
ChainControl values and they get distributed to
the loop.

So now, in theory, anybody with access to the DS
could reconfigure any of its loops, and that
reconfiguration would both persist and propagate
to the loop.

So we need an API for that?

[602:

Wed Nov 23 07:57:57 2022 Which would be in Codon?
Since that's how DS looks at chains..

And I guess we just start with get and set, on a
per pocket basis?

[603:

Wed Nov 23 08:38:14 2022 Well we don't really have
much of a DS pocket abstraction though.. Something
in DiamondSequencerState perhaps?[604:

Wed Nov 23 09:50:08 2022 Well, made

  Bool getChainControlUp(ChainControlUp & dest) ..
  Bool setChainControlUp(ChainControlUp src) ..
  Bool getChainControlDown(ChainControlDown & dest) ..
  Bool setChainControlDown(ChainControlDown src) ..

in ProcUnitInfo, so they could be used, I guess,
like:

    ProcUnitInfo & ins = dss.mPUInfos.mPUInfoAry[cPUNIT_INS];

    ChainControlUp ccu;
    if (ins.getChainControlUp(ccu)) {
      // do stuf to ccu
      if (!ins.setChainControlUp(ccu)) fail(__FILE__,__LINE__);
    }
[605:

Wed Nov 23 16:13:23 2022 OK, well we extended
LXMarker with more data members:

      typedef Bits(4) ControlMap;
      ControlMap mUpMap;
      ControlMap mDownMap;
      ChainControlData mChainControlData;

and changed one of our ancestor instructions to
set them:

    local constant LXMarker cINS10 = {
      .mDSType = DTU.cDS_NORM,
      .mLabel = cMARK_LABEL,
      .mUpMap = 0x3, // set up chain on REG and INP
      .mDownMap = 0x8, // set down chain on INS
      .mChainControlData = {
        .mTQMap = 0x6, // set target quad NE (1<<1) + SE (1<<2)
        .mSRMap = 0x3, // set size ranges _S (1<<0) + _M (1<<1)
      },
    };

and got that to apparently work.

Now changing the default mTQMap and mSRMap values
to 0xf meaning 'all valid', aka 'no constraints'.
[606:

Thu Nov 24 00:45:57 2022 OK, so now PocketChain
are starting up with 0xF/0xF TQMap/SRMap, and the
DABE:LXMarker is successfully changing the down
map to 0x6/0x3 as directed.

Time to actually implement chain controls!

 - evaluate a given pocket for cc penalties

 - set and propagate mViolation appropriately

 - select rule actions that reduce or avoid
   penalties

[607:

Fri Nov 25 00:43:43 2022 OK, so, current issue is,
in target quad mapping, we have a confusion
between a PocketDir meaning a global grid quadrant
and a PocketDir meaning a local patch
direction. Caller knows the latter, typically, but
callee typically wants the former.

[608:

Fri Nov 25 00:53:21 2022 We want something like

 - zone of patch center +

 - PocketDir of patch pocket =

 - global grid PocketDir of that pocket

and the rule is like:

 - If (x)zone is _UN, answer is fail, else

 - If (x)zone is _CT, answer is the given
   PocketDir, else

 - If zone is even, answer is zone/2 for all patch
   pockets,

 - Otherwise zone is on AxialDir ad

[609:

Fri Nov 25 01:39:45 2022 OK, made

  PocketDir xzoneAndPatchDir2TargetQuadrant(XZone xz, PocketDir patchdir)

in DTU; seems plausible if aggravating that it
exists after all the other conversion methods
already written, but... we'll see.[610:

Fri Nov 25 14:41:38 2022 Well, the "EIQ10" segment
I stuck into QHardCell.updatePath(..) is starting
to get some plausible results, so I think it'll be
time to try pushing those 'learnings' into the
rule matching stuff, until we can determine
whether a given applicable rule will make things
better or worse.

It'll be a little tricky because when we consider
moving segments, we're also moving the
ChainControl maps that determine their
goodness. So I think we want something like: What
*would be* the errorInQuad if *this* codon was in
it?

We'll have to do it with custom code I'm pretty
sure.

[611:

Sun Nov 27 02:07:12 2022 OK so I'm trying to go
'top down' within the updatePatch corner of QHC
processing, and Pocketable.updatePatch is now
calling PatchRules.tryRandomRule(..) which is
successfully choosing a random rule (uniformly
weighted, at least for now), and calling
tryRule(..) on it.

tryRule in turn does like

 init
 if (!match) return false
 if (!apply) return false
 return true

and we want to change that to something like

 init
 if (!match) return false
 if (!desirable) return false
 if (!apply) return false
 return true

where desirable means something like

 Int dp = rule.computePenaltyChange(ps);
 return dp <= 0; // for now

and computePenaltyChange has to somehow use
something like ChainControl.chainError(..) to
determine delta penalty.
[612:

Sun Nov 27 02:37:26 2022 I'm not clear at the
moment about how.. [613:

Sun Nov 27 02:46:04 2022 Oh yeah:
PatchState.errorInQuad(pd) takes into
consideration the content of the pocketdir pd. And
it does that via PatchState.mSegmentCount and
related members. So we'll need another method to
call there..[614:

Sun Nov 27 02:49:04 2022 OK I broke out
PatchState.errorOfPocketChainInQuad(pd,pc) that
should allow us to provide a hypothetical quad
content, and get it scored. Next step would be
make some kind of PatchRule.desirable(??) API to
call on successful matches, and start writing code
to sum up the EIQ deltas of the changes for that
rule..

[615:

Sun Nov 27 03:20:16 2022 OK going back to sleep,
but we're currently unbuildable due to most of the
PatchRule's not yet implementing the new

  Int evaluate(..)

that is tasked to return the change-in-penalty
that would occur if this matched rule was
applied.

:615]

:614]

:613]

:612]

:611]

:610]

:609]
:608]

:607]

:606]

:605]
:604]

:603]

:602]

:601]
[616:

Sun Nov 27 08:39:18 2022 OK so at long last patch
rule application is being gated by the
ChainControlData maps in a vaguely plausible way.

So, big fun.

And then, of course, it immediately leads to more
issues, including ones we had lurking in the back
of our minds. First up now is: Setting size ranges
measured from root or DS it's hard to pick a size
that makes root shifting possible without getting
so small that the loader can't load for a
tremendously long time. (I think that's true.)

Lurking response has been: Measure distance from
the edge of the grid instead of any center. So
probably going to do that next.

We also are code incomplete in that we're not
generating mViolation signals yet so we need to do
that too.

Let's try measuring size inward from the edge, and
for now at least, have caller do the mapping..
[617:

Sun Nov 27 09:40:28 2022 Well, did that, and also
changed the default mSRMap from 0xF to 0xE, with
the effect that pocketchains now avoid the
outermost ring of the grid by default.

With that change, the GROW-GROW-SHIFT hack worked
successfully, and we've now run through the end of
our loaded program and kinda sorta need more "user
level" code.

Yow!

Big fun.

:617]
:616]
[618:

Mon Nov 28 03:41:34 2022 So I tried to advance the
ancestor code a bit, and found the/a next issue:

I inserted an LXDo meant for the daughter DS,
followed by an LXCopy. The intention is to set up
a 'catcher' in the daughter, that receives the
incoming codons and recreates the program in the
daughter.

The LXDo successfully regripped the daughter and
set the (was X now) I stream to advance. But the I
stream can't advance, because it's not a loop. So
it doesn't know what to do with the (original)
LXDo sitting in the I DSP.

It seems like we'll need to:
(1) Init an O loop
(2) Have a different kind of LXDo - or have a flag
    on LXDo - that consumes the original LXDo when
    it executes, leaving an EC, which (I believe)
    will draw in the next codon even on an
    unclosed strand.

Or maybe we just do a special 'Daughter init' op
that inits the O loop, copies itself to I, regrips
the DS, and then acts like some foggen LXCopy.

'Programmable' yay.

But, nap now.

:618]
[619:

Mon Nov 28 12:05:50 2022 Have been focused on the
book but tweaking crap in the background
here. Trying to deploy the daughter DS to the SW,
so that we could send the program copy into the
daughter's SE. Currently running into problems
when setting a DS to all XEQ streams, which seems
like at least an isotropic, if dangerous, starting
condition.

Lots of stuff refusing to work if any of the four
PUIs aren't found, though. May have to bail.

:619]
[620:

Thu Dec  1 13:46:54 2022 OK, refactored to pull
QCtorArm out of LXCtorArm, ahead of going for
'biological' ctor arm code. Now apparently working
as before. Committing WIP.[621:

Thu Dec  1 13:57:29 2022 OK committed. Let's go
for 'biocode' and see how we do.
[622:

Thu Dec  1 15:41:19 2022 Well getting there. We've
made 'LXBioCtorArm', with the symbol BC, which can
hold up to seven 'BOpCode' bio-operation
codes. And we've converted the ancestor to use two
BCs instead of one CA (which has been renamed 'SC'
for 'String Constructor'.)

And we've observed the first BC get to XEQ and
start building the arm, but then the second BC
destroyed it as part of its built-in reset/init
operations. So we changed the loader so that the
second BC started with mPC 0u instead of 255u.

And starting at 0 did successfully bypass the ctor
reset operation. But now we're just blocking
because the second BC's .mSeqNo isn't synced to
the existing arm's seqno.

We need, I think, to do the following:
 - Create a local op to do the reset and arm
   creation, on demand

 - Create a local op to sync up with an existing
   arm

 - When mPC is 255, do the second if an arm exists
   and the first if it does not.

Not sure what happens in the first two cases if
there is or isn't an existing arm, respectively.

[623:

Fri Dec  2 08:06:19 2022 Now it's not clear to me
how we'll do the 255 split dynamics, there,
because reset/init is not atomic. Sync-ing with an
existing arm could be dynamic, though, but is that
enough for both?[624:

Fri Dec  2 08:27:36 2022 At the moment we've got 8
full bits for the program counter, but the biggest
program we've written is like 20 instructions or
so. I think we could steal a few more values at
the top, say 251-255 anyway, without a lot of
pain. That way we could have some hardcoded
sequencing during program startup.

255 startup, arm detect: 0 -> 254, 1 -> sync -> 0
254 killing PUs -> 253
253 empty -> init SW3 -> 0
252 rsrv
251 rsrv

[625:

Fri Dec  2 08:44:55 2022 Well that seems almost
plausible. Aaand could we take like 251 as meaning
exit?

I guess cLOP_RST couldn't use this 'address
semantics' since it's in the programmable
sequence, so we'd need access to the killpus+empty
init such some other way as well.

(Right now the killPUs + the empty/init both
complete in a single event, so it's not completely
clear 254 and 253 have to be distinguished.)

[626:

Fri Dec  2 09:08:39 2022 Well let's try this. It's
our third go (at least) through LXCtorArm startup;
I'd like to get it solid for once.

To review (hopefully), how do we distinguish
between entering an instruction and waiting for
instruction completion? We have to initiate the
instruction's action on the same event the mPC
changes? So starting up with a given mPC value
always means we're waiting for getOp(mPC) to
complete?

It would be nicer if we had an mWaiting toggle or
something, so changing mPC would mean

gotoPC(address) {
 mPC = address; mWaiting = false;
}

and then we could quit. On the next event, we
discover we're 'initiating' (since !mWaiting) and
we do whatever it is. If it completes atomically,
like for a localop, we then do gotoPC(nextaddr)
and we're done; if not, we set mWaiting and then
take a separate path next time.
[627:

Fri Dec  2 10:02:35 2022 Well, we added an
mWaiting flag, and now LCBioCtorArm has precisely
0 bits remaining. Let's try to activate all some
of this new stuff..
[628:

Fri Dec  2 10:05:27 2022 Ah so, we did have an
mWaiting-ish mechanism already, doh, without
taking up a bit: If our seqno matches the
arm(down) seqno, we're dispatching a new insn,
otherwise we're blocking until the instruction is
complete.

That works as long as all local ops complete
atomically, so we never need to block. Is that
true? Well, we've now manifested cLOP_LRST, which
would clearly not be atomic..
[629:

Sat Dec  3 03:54:07 2022 OK, QCTorArm execution is
starting to seem plausible, and we have a pair of
(in principle evolvable) LXBioCtorArm atoms in the
loader now successfully doing what the single
(String-based therefore 'physics') LXCtorArm used
to be doing.

Pop pop big fun pop.
[630:

Sat Dec  3 03:58:49 2022 Next up after second
sleep:

 - LXCommandDS: Loader is doing one but it's not
   implemented. Not 100% clear right now what it's
   supposed to do. Figure that out.

 - PatchRules: We need a shrink rule that accepts
   two ECs in any of the four positions and
   collapses it down to just the non-ECs in
   sequence. Shrinking is currently too hard.

[631:

Sat Dec  3 09:17:45 2022 OK so we're once again at
initting the daughter copy inbound process, and we
need new physics for it. We are getting the first
instruction executed in the daughter, but the
problem is: Since that insn isn't part of a loop,
we have no mechanics to rotate it out of the XEQ
DSP. So 'the obvious' thing to do is deploy
something other than the LXDo that we just
deployed - something that does all the setup at
once:

 - inits a 'daughter loader loop' in, say, REG

 - regrips the daughter DS to REG <-> XEQ

 - 'consumes' itself on the inbound line by
   changing it to a downbound temp.
[632:

Sat Dec  3 10:55:56 2022 OK, need to break for
other stuff this aft, so, current status:

 - Making DaughterLoader.ulam patterned on Loader

 - Was thinking I could 'do it all' in
   LX.perform(dss), but I can't, because a DS ew
   can't confirm DaughterLoader has two ECs on
   either side.

 - So need to rewrite. Thinking:

   = perform sets flag when next instruction
     available

   = behave sees flag and searches mSrc pocket to
     consume instruction, clears flag, finishes,
     etc.

[633:

Sun Dec  4 01:15:05 2022 Well, have been
implementing this, but kind of not seeing the
point of 'instruction available' flag. If the
DaughterLoader is in XEQ..

Wait I think I see that basic issues:
(1) DaughterLoader is different from Loader
    because DL loads insns from the ew, while Ld
    plucks insns out of thin air - out of the
    physics. So DL, as currently construed, needs
    to see the source pocket PLUS both its up and
    downstream.. and that's not possible in
    general.

(2) BUT: The reason Ld insisted on seeing two ECs
    was to guarantee there'd be at least one EC
    after loading, to have room to spawn a
    ShapeShifter to grow the loop.

BUT: WE DON'T USE Sf ANYMORE. We don't have to
g'tee an EC for the loop to be growable.

[634:

Sun Dec  4 01:24:25 2022 So we should rethink
DaughterLoader yet again (a third time? fourth?).

We should go back to viewing DL as a version of
LXCopy rather than Loader.

Init DL: When executing an 'unflagged' DL:
(1) Reset REG if necessary
(2) Init loop on OUT if necessary
(3) Copy DL to REG and flag the copy
   (3a) Optionally consume original DL?
(4) Regrip XEQ->INP, REG->XEQ, INP->REG

Run DL: When executing a 'flagged' DL:
(1) Find non EC on INP, rolling if needed
(2) Find EC on OUT, rolling if needed
(3) Copy INP -> OUT, EC -> INP
(4) If terminating marker..

[635:

Sun Dec  4 01:42:52 2022 Opps, if we don't do Ld
style hog-the-DSP, how do we ensure only an EC
rolls into OUT? We can't allow non-EC to pass
through the DSP or we blow the sequence.

Does OUT maintenance already do that somehow?
Accepts ECs from either direction, but only ECs? I
feel like we had a function that was supposed to
do that, but I don't immediately remember ever
implementing that.[636:

Sun Dec  4 01:48:04 2022 Yeah what does
cDSTATUS_TEMP actually do?[637:

Sun Dec  4 01:49:02 2022 Well, we see:

LXCopy.ulam:66:      markDSPForRotation(dss, 0u, mDstPU, cDSTATUS_TEMP);  // ask dst for empty spot

and we have LXCopy deployed so something must kind
of exist..

Also

    markDSPForRotation(dss, 0u, mDstPU, cDSTATUS_TEMP);  // ask dst for empty spot

at LXCopy.ulam:83

[638:

Sun Dec  4 01:50:37 2022 Ah okay: At
Codon.ulam:302-402 we appear to implement
cDSTATUS_TEMP, with cases like:

(1) If OUT has EC, go IDLE
(2) If OUT is any temp (mDSType == cDS_DOWN or cDS_UP)
    replace it with EC and go IDLE
(3) If OUT is mDSType_NORM (mobile nontemp)
    and down is some mDSType == cDS_UP,
    then replace down with an EC,
    then swap OUT with down,
    then go IDLE
(4) If OUT is mDSType_NORM (mobile nontemp)
    and up is some mDSType == cDS_DOWN,
    then replace up with an EC
    then swap OUT with up,
    then go IDLE

And it seems clear that's buggy. That we can't
allow both (3) and (4), right? Because that
implies a real codon might exit upstream or
downstream, depending on circumstances, producing
a shuffled sequence.

The only reason the existing deployment works is
because it's storing into an open chain, not a
loop.

[639:

Sun Dec  4 02:05:58 2022

I think we have to

(1) pick an injection direction,
(2) that is compatible with the existing open
    chain use, and
(3) deimplement whichever (3) or (4) of :638: goes
    in the wrong direction, and
(4) Add a 'convert cDS_UP to cDS_DOWN' (or vv,
    whichever is right) instead of the
    deimplemented operation.

THEN rewrite DaughterLoader yet again.

But nap now.
[640:

Sun Dec  4 07:20:48 2022 OK, it appears that
getting rid of this case in Codon.stabilize(..):

      // (3) if reachable layout is   [X] -> U
      //     switch to                [F] -> X
      //     and set _IDLE

doesn't kill the open-chain LXCopy deployment. So
maybe I think we want, instead, something like:

      // (3) if reachable layout is   [X] -> U
      //     switch to                [X] -> D
      //     and stay in TEMP

to help send temps around the loop to where we
need them.
[641:

Sun Dec  4 07:36:34 2022 OK well that's roughed-in
at least. In a bigger redesign I wonder if we want
the 'get temp' rules to vary systematically across
the ProcUnits. Like:

    Get temp on OUT: Do what we just made
    Get temp on INP: Do reverse of what we just made
    Get temp on REG: Do either one opportunistically
    Get temp on XEQ: (? Act like INP? )

But I'm for sure not going there now. (If we ever
get to fixing the currently-broken the
multi-pockets-same-func stuff, we might think
about adding this then.)

:641]
:640]
:639]
:638]

:637]

:636]

:635]

:634]

:633]

:632]
:631]

:630]
:629]

:628]
:627]
:626]
:625]
:624]

:623]
:622]

:621]

:620]
[642:

Sun Dec  4 07:57:26 2022 OK, I think we're up to
rewriting DaughterLoader again as sketched in
:634: above.

[643:

Sun Dec  4 13:25:02 2022 OK we're getting closer
to seeing DaughterLoader out in the world. I made
this 'Looper' element to pop out a mated pair of
ECs, and was thinking of using it to initialize
the code-receiving loop in the daughter - but
Looper doesn't check (at the moment anyway) for
pockets being DSP, so I was afraid it might pop
out and bridge two DSPs (like L1 does sometimes
way at the beginning) and cause troubles.

But just now I had the idea that I could hack
around that by placing the daughter Loader in the
pocket that Looper might otherwise be tempted to
pop into.

So, right now, the initial daugther DS ends up
gripped like this:

    OUT    XEQ
       dDS
    INP    REG

with codons from the mother arriving in the
NE. Suppose we got it to end up like this:

    REG    INP
       dDS
    XEQ    OUT

by swapping XEQ<->INP and OUT<->REG.

The Looper would be deployed in OUT, but would
have to deploy E or S, since N and W are
occupied. So the (sigh atomic) result of dL's
first execution in the daughter would be

  empty    inbound codons
    REG    INP
       dDS
    XEQ    OUT
    dL      LP
 deployed

[644:

Sun Dec  4 14:52:29 2022 Well a small fly in that
ointment is that we were deploying the LP and then
waiting for it to become ECs before completing
deployment of the DL. So the idea of blocking out
the DSP won't work in that case.

So what about completing deployment atomically,
but then having the deployed DL wait for an EC?

Let's give it a shot.[645:

Sun Dec  4 15:45:30 2022 OK, we've finally got as
far as DL.performDeployed(dss), where we blow up
because it's unimplemented.
[646:

Mon Dec  5 01:24:10 2022 Aaand now we've actually
copied a bunch of code from the mother to the
daughter! (See 20221204202408.mp4 in
3133-20221206!)

[647:

Mon Dec  5 01:30:14 2022 Adding two more w ahead
of daughter DS deployment. Will see how it looks.

But we are very close to needing more ancestor
behavior.

And 'all' my worries are looking ahead to diamond
cutting..  

:647]

:646]

:645]

:644]
:643]
:642]
[648:

Wed Dec  7 00:53:29 2022 OK it's all about diamond
cutting. For the last couple days I've been
thinking about a new 'partition' element just to
help with the cutting: Something that would
replace certain sections of HG, on command, with a
non-HG thing that would

(1) Be seen as an obstacle to move away from, and
(2) Prevent HG from confusing each other from
    across the partition

Deployment of a partition would need to be done
'simultaneously' with deploying a new root on
whichever side lacks one.

My main worry about all that is getting HG not to
deadlock while backing away from something that
deep within it. But I have an idea maybe for
dealing with that.

Maybe. Maybe maybe.

:648]
