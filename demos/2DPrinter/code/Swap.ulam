transient SwapState {
  EventWindow ew;
  Fail f;

  Atom e1;
  Atom e4;
  Atom e12;

  Void init() {
    e1 = ew[1];
    e4 = ew[4];
    e12 = ew[12];
  }

  Void approach(Swap& swap) {
    if (e4 is Periphery) 
      swap.mState = swap.cINTERNAL;   // APPROACH DONE: SP -> Ps

    // APPROACH IN PROGRESS/DONE SX -> XS
    ew[4] = swap.atomof;
    ew[0] = e4;
    return;
  }

  Void internal(Swap& swap) {

    // Periphery and CopyBar blocking
    if (e4 is Periphery || e4 is CopyBar) return;

    // Double internal 'ss' detection
    if (e4 is Swap) {
      Atom & re4 = e4; 
      Swap s4 = (Swap) re4; // XXX WORKAROUND
      if (s4.mState != swap.cINTERNAL) f.fail(-1);
        
      // COPYBAR DESTRUCTION: PssC -> ..TP
      if (e1 is Periphery && e12 is CopyBar) {
        swap.mState = swap.cTRANSFER;
        ew[4] = swap.atomof;
        ew[12] = e1;
        ew[1] = Empty.instanceof;
        ew[0] = Empty.instanceof;
        return;
      }

      // COPYBAR CREATION: ssP -> CPP
      if (e12 is Periphery) {
        ew[0] = CopyBar.instanceof;
        ew[4] = e12;
        return;
      }

      // COLUMN DUPLICATION: XssC -> CXTX
      if (e12 is CopyBar) {

        swap.mState = swap.cTRANSFER;  // I become transfer 
        ew[4] = swap.atomof; // and move right

        ew[1] = e12;         // CopyBar moves behind me
        ew[0] = e1;          // And the new atom copies
        ew[12] = e1;         // surround me.
        return;
      }

      f.fail(-2);
    }

    // INTERNAL IN PROGRESS: sX -> Xs
    ew[4] = swap.atomof;
    ew[0] = e4;
  }

  Void transfer(Swap& swap) {

    // SEPARATION: TPP -> ..c
    if (e4 is Periphery && e12 is Periphery) {
      swap.mState = swap.cCLEANUP;
      ew[12] = swap.atomof;
      ew[0] = Empty.instanceof;
      ew[4] = Empty.instanceof;
      return;
    }

    // TRANSFER DONE: TYP -> PYx
    if (e12 is Periphery) {
      swap.mState = swap.cEXIT;
      ew[12] = swap.atomof;
      ew[0] = e12;
      return;
    }

    // TRANSFER IN PROGRESS: TXY -> YTX
    ew[4] = swap.atomof;
    ew[0] = e12;
    ew[12] = e4;
    return;
  }

  Void exit(Swap& swap) {

    // EXIT DONE: xP -> P.
    if (e4 is Periphery) {
      ew[0] = e4;
      ew[4] = Empty.instanceof;
      return;
    }

    // EXIT IN PROGRESS: xZ -> Zx
    ew[4] = swap.atomof;
    ew[0] = e4;
  }

  Void cleanup(Swap& swap) {

    // CLEANUP DONE: cP -> ..
    if (e4 is Periphery) {
      ew[0] = Empty.instanceof;
      ew[4] = Empty.instanceof;
      return;
    }

    // CLEANUP IN PROGRESS: xZ -> Zx
    ew[4] = swap.atomof;
    ew[0] = e4;
  }

}

/** Swap element for 1D object reproduction spike
    \color #e41
 */
element Swap {
  typedef Unary(4) State;
  constant State cAPPROACH = 0;
  constant State cINTERNAL = 1;
  constant State cTRANSFER = 2;
  constant State cEXIT = 3;
  constant State cCLEANUP = 4;
  State mState;

  Void behave() {
    SwapState ss;
    ss.init();

    if (mState == cAPPROACH)      ss.approach(self);
    else if (mState == cINTERNAL) ss.internal(self);
    else if (mState == cTRANSFER) ss.transfer(self);
    else if (mState == cEXIT)     ss.exit(self);
    else /* mState == cCLEANUP */ ss.cleanup(self);
  }
}
