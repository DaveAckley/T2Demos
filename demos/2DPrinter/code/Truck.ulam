quark TruckBase : Printer + PackedFront {

  Bool truckHereOrBehind(SN sn2or3) {
    C2D chere = md.getSiteCoord(sn2or3);
    C2D behind = chere + C2D.instanceof(1,0);
    return ew[chere] is Self || ew[behind] is Self;
  }

}

element Truck : TruckBase {
  virtual Int priority() { return cTRUCK_PRIORITY; }

  B2D.BCoord mPlateHeight;
  B2D.BCoord mOurRow;
  B2D.BCoord mStepsTilDropoff;
  typedef Bits(2) ReadyOnTheLine;
  constant ReadyOnTheLine cREADY_NORTH = 0x1;  // +1 equals SN
  constant ReadyOnTheLine cREADY_SOUTH = 0x2;  // +1 equals SN
  constant ReadyOnTheLine cREADY_BOTH =  0x3;
  ReadyOnTheLine mReadyBits;

  typedef Unsigned(2) TruckPhase;
  constant TruckPhase cTRUCKPHASE_DEPLOY = 0u; // Deploy the fleet
  constant TruckPhase cTRUCKPHASE_LOAD   = 1u; // Drive to pickup, and load
  constant TruckPhase cTRUCKPHASE_HAUL   = 2u; // Drive to dropoff
  constant TruckPhase cTRUCKPHASE_UNLOAD = 3u; // Unload and vanish
  TruckPhase mTruckPhase;

  Bool mGarbageTruck;

  //// Printer API
  virtual Bool die() { mPlateHeight = mPlateHeight.minof; return true; }
  virtual Bool isDead() { return mPlateHeight == mPlateHeight.minof; }

  Bool hasBackWing() {
    for (SN sn = 2u; sn <= 3u; ++sn) {
      C2D c = md.getSiteCoord(sn);
      Int absrow = mOurRow + c.getY();
      if (absrow > 0 || absrow < mPlateHeight) {
        if (ew[(SN) (sn+5u)] is Self) return true;
      }
    }
    return false;
  }

  // Return false if wing is ready to roll; true if need to wait or died
  Bool checkWing(Bool north) {
    ReadyOnTheLine bit = north ? cREADY_NORTH : cREADY_SOUTH;
    ReadyOnTheLine obit = !north ? cREADY_NORTH : cREADY_SOUTH;
    //du.print("cW10");
    //du.print(north);
    if ((mReadyBits & bit) != 0) return false;  // Known ready
    //du.print("cW11");
    SN sn = north ? 2u : 3u;
    SN behind = (SN) (sn + 5u);
    C2D c = md.getSiteCoord(sn);
    Int absy = mOurRow + c.getY();
    if (absy < 0 || absy > mPlateHeight) {
      //du.print("cW12");
      //du.print(absy);
      mReadyBits |= bit;  // No wing needed
      return false;       // OK in this dir
    }
    //du.print("cW13");
      
    Atom & a = ew[sn];
    if (a as Truck) {
      //du.print("cW14");
      if ((a.mReadyBits & bit) != 0) {  // If they're ready
        mReadyBits |= bit;  // Then we're ready
        return false;       // OK in this dir
      }
      return true;          // Need to wait
    }
    
    //du.print("cW15");
    if (ew[sn] is Plate && ew[behind] is Plate) {
      //du.print("cW16");
      if (!(ew[0] is Truck) || !(ew[4] is UnloadedTrailer))
        return die();
      //du.print("cW17");
      Truck & truck = (Truck&) ew[0];
      UnloadedTrailer & trail = (UnloadedTrailer&) ew[4];

      Truck newt = truck;
      newt.mOurRow += north ? -1 : 1; // Adjust row
      newt.mReadyBits = 0u;  // Find your own readiness

      UnloadedTrailer newut = trail;

      ew[sn] = newt;
      ew[behind] = newut;
      //du.print("cW18");
      return true;            // Need to wait for them
    }
    return die();
  }

  Bool processDeparture() {
    if (!(ew[4] is UnloadedTrailer)) return false; // already loaded (or messed up)
    //du.print("pDep10");
    UnloadedTrailer & ut = (UnloadedTrailer&) ew[4];
    if (ut.mDeparted) return false;                // already underway
    //du.print("pDep11");
    Bool check = random.oneIn(2);                  // Stay isotropic
    if (checkWing(check)) return true;             // Check north and south
    //du.print("pDep12");
    if (checkWing(!check)) return true;            // One way or the other
    //du.print("pDep13");
    ut.mDeparted = true;                           // Ready to roll
    return false;
  }

  Bool cleanOneColumn() {
    if (!ew.isAccessible(1)) return die();
    if (ew[1] is Plate) ew[1] = Empty.instanceof;
    ew.swap(0,1);
    return true;
  }

  Bool driveOneColumn() { // Let's roll!
    if (mGarbageTruck) return cleanOneColumn();
    //du.print("dOC10");
    if (!(ew[4] is Trailer)) return die();       // why you calling
    //du.print("dOC11");
    if (!ew.isAccessible(1)) return die();
    //du.print("dOC12");

    // WARNING!  The swap order here is critical -- because after
    // ew[0] changes, the 'self' reference becomes invalid, so the
    // 'ew' data member can no longer be accessed!  (Using a local
    // variable EventWindow, or doing EventWindow.instanceof.swap(..)s
    // instead, would also avoid the problem.)
    ew.swap(1,4);  // 104 -> 401
    ew.swap(1,0);  // 401 -> 014
    return false;
  }

  Bool processPickup() {
    //du.print("pPick 10");
    if (!(ew[4] is UnloadedTrailer)) return false; // already loaded (or messed up)
    //du.print("pPick 11");
    UnloadedTrailer & ut = (UnloadedTrailer&) ew[4];
    if (mStepsTilDropoff > 0) return false; // haven't reached the pickup point
    //du.print("pPick 12");
    if (mStepsTilDropoff < 0) return die(); // what what
    //du.print("pPick 13");
    // Time to load the trailer!
    Atom topack = ew[1];
    PackedAtom pa;
    LoadedTrailer lt;
    if (!pa.packAtom(topack, self, lt, lt)) return die();
    ew[4] = lt;
    //du.print("pPick 14");
    return true;
  }

  /*
  Bool processArrival() {
    if (!(ew[4] is LoadedTrailer)) return false;   // Not loaded yet (or messed up)
    if (mStepsTilDropoff > 0) return false;        // haven't reached the dropoff point
    if (!mReadyOnTheLeft || !mReadyOnTheRight) return false; // Line not dressed
    // XXXX
    return die();
  }
  */

  Bool checkReadyOnTheLine(ReadyOnTheLine bit) {
    if ((mReadyBits & bit)==0) { // Need to check site

      SN sn = (SN) ((Unsigned) bit+1u);
      C2D c = md.getSiteCoord(sn);
      Int absrow = mOurRow+c.getY();

      if (absrow < 0 || absrow >= mPlateHeight) { // Off plate
        mReadyBits |= bit;                        // so ready that way
      } else {                  // On plate
        Atom a = ew[sn];
        if (a as Self) {
          if ((a.mReadyBits & bit) != 0) // But they're ready in dir
            mReadyBits |= bit;
        }
      }
    }
    return (mReadyBits & bit)!=0;
  }

  /*
  Bool processDropoff() {
    du.print("pDrop 10");
    if (!(ew[4] is LoadedTrailer)) return false;    // Not loaded yet (or messed up)
    du.print("pDrop 11");
    if (mStepsTilDropoff > 0) return false;        // haven't reached the dropoff point
    du.print("pDrop 12");

    Bool readyOnTheLine = true;
    readyOnTheLine = readyOnTheLine && checkReadyOnTheLine(cREADY_NORTH);
    readyOnTheLine = readyOnTheLine && checkReadyOnTheLine(cREADY_SOUTH);
    if (!readyOnTheLine) return false;
    du.print("pDrop 13");

    // Time to unload the trailer!
    LoadedTrailer & lt = (LoadedTrailer&) ew[4];
    PackedAtom pa;
    Atom unpacked = pa.unpackAtom(self,lt,lt);

    if (unpacked as PrintBase) {
      unpacked.helloClone();  // Let it know
    }
    Plate plate;
    plate.helloClone();
    
    ew[1] = unpacked;         // No damn truck, and
    ew[4] = plate;            // No damn trailer
    du.print("pDrop 14");
    return true;
  }
  */

  Bool tooCloseInFront() {
    return
      (ew[1] is Trailer ||
       ew[9] is Trailer);
  }

  Bool deployHereIfNeeded(SN sn2or3) {
    if (truckHereOrBehind((SN)(sn2or3+3u))) return false; // not needed
    C2D c = md.getSiteCoord(sn2or3);
    Int absrow = mOurRow + c.getY();
    if (absrow <= 0 || absrow >= mPlateHeight) return false; // not needed

    Truck newt = self;
    newt.mOurRow = (B2D.BCoord) absrow;
    if (!ew[4] is UnloadedTrailer) return die();
    UnloadedTrailer & trail = (UnloadedTrailer&) ew[4];
    ew[sn2or3] = newt;
    ew[(SN)(sn2or3+5u)] = trail;

    return false;  // Done
  }

  Bool phaseDEPLOY() {
    if (deployHereIfNeeded(2u)) return true;
    if (deployHereIfNeeded(3u)) return true;
    mTruckPhase = cTRUCKPHASE_LOAD;
    return true;
  }

  Bool phaseLOAD() {
    if (!ew[4] is UnloadedTrailer) return die();
    UnloadedTrailer & trail = (UnloadedTrailer&) ew[4];
    if (tooCloseInFront()) return true; // Don't tailgate whether driving or loading
    if (trail.mStepsTilPickup > 0) {
      if (hasBackWing()) return true; // Let them catch up
      --trail.mStepsTilPickup;        // Decrement first!
      driveOneColumn();               // Then drive
      return true;                    // Done whether it worked on not
    }

    // Time to load the trailer!
    Atom topack = ew[1];
    PackedAtom pa;
    LoadedTrailer lt;
    lt.mRot = mRot;
    if (!pa.packAtom(topack, self, lt, lt)) return die();
    ew[4] = lt;
    
    mTruckPhase = cTRUCKPHASE_HAUL;  // And away we go
    return true;
  }

  Bool phaseHAUL() {
    if (mStepsTilDropoff > 0) {
      if (hasBackWing()) return true; // Let them catch up
      if (tooCloseInFront()) return true; // Don't tailgate
      --mStepsTilDropoff;             // Decrement first!
      driveOneColumn();               // Then drive
      return true;                    // Done whether it worked on not
    }

    mTruckPhase = cTRUCKPHASE_UNLOAD; // Ready to unload
    return true;
  }

  Bool phaseUNLOAD() {
    if (!ew[4] is LoadedTrailer) return die();
    if (hasBackWing()) return true; // Let them catch up

    // Time to unload the trailer!
    LoadedTrailer & lt = (LoadedTrailer&) ew[4];
    PackedAtom pa;
    Atom unpacked = pa.unpackAtom(self,lt,lt);

    if (unpacked as PrintBase) 
      unpacked.helloClone();    // Let it know

    Plate plate;
    plate.helloClone();

    // ORDER MATTERS SEE driveOneColumn warning
    ew[4] = plate;              // No damn trailer,
    ew[0] = unpacked;           // No damn truck
    return true;                // This job is finished
  }

  virtual Bool update() {
    if (super.update()) return true;
    if (processDeath()) return true;
    which (mTruckPhase) {
    case cTRUCKPHASE_DEPLOY:  { return phaseDEPLOY(); }
    case cTRUCKPHASE_LOAD:    { return phaseLOAD(); }
    case cTRUCKPHASE_HAUL:    { return phaseHAUL(); }
    case cTRUCKPHASE_UNLOAD:  { return phaseUNLOAD(); }
    }
    return die(); // NOT REACHED
  }

  Void behave() {
    if (update()) return; // Check priority
  }
}
