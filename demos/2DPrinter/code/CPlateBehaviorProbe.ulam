transient CPlateBehaviorProbe : CPlateBehavior {
  typedef UGridContent.S2D S2D;
  typedef S2D.Coord SCoord;

  /*
  Bool advanceRPS(CPlate & cp) {
    if (mCPlateSameSN == 0)  // Anybody on phase?
      return false;          // No..
    if (mCPlateLessSN > 0)   // Anybody still need to phase up?
      return false;          // Yes

    Atom a = ew[mCPlateSameSN];
    CPlate & ngb = (CPlate&) a;

    // Shoot shoot shoot
    Bool theyWin = ngb.u.mCOPY.mSwapState.winsOver(cp.u.mCOPY.mSwapState);
    if (theyWin &&               // If their state beats us, and
        mCPlateRPSLoseSN == 0) { // nobody loses to us (which would beat them)

      cp.progress();
      cp.u.mCOPY.mSwapState.throwThis(ngb.u.mCOPY.mSwapState);    // then we can advance

      return true;
    }
    return false;
  }
  */

  /*
  Bool headEmitSwapLine(CPlate & cp) {
    if (!cp.isHeadCommander() ||   // Not our job
        !(ew[1] is Empty) || // or locs unavailable
        !(ew[9] is Empty) ||
        !cp.u.mCOPY.mSwapState.isScissors() ||       // or it's not our turn
        mCPlateRPSLoseSN != 0) // or still previous turn out there
      return false;

    if (!ew.isAccessible(1) || // or locs unavailable
        !ew.isAccessible(9)) {
      cp.miscarry();
      return false;
    }

    cp.u.mCOPY.mSwapState.throwRock();

    SwapLine sl;
    sl.setMyTag((Content.MyTag) cp.getMyTag());
    sl.setWindowRotation(cp.getWindowRotation());
    sl.mLocation = cp.mLocation;
    sl.mMax = cp.mMax;
    sl.mCopyX = cp.u.mCOPY.mNextCopyColumn;
    --cp.u.mCOPY.mNextCopyColumn;
    ew[1] = sl;

    if (sl.mCopyX >= cp.cORIGIN_X) // No trailer for the reaper
      ew[9] = Trailer.instanceof;

    cp.progress();
    return true;
  }
  */

  /*
  Bool tailReleaseSwapLine(CPlate & cp) {
    // Tail advances rock to paper when the back of a swapline is waiting at 12
    if (!cp.isTailCommander() ||                   // unless not our job
        mCPlateScanner.getSwapLineSN() != 12 || // or no line waiting
        !cp.u.mCOPY.mSwapState.isRock() ||      // or we're not ready
        mCPlateRPSLoseSN != 0) // or a ngb isn't ready
      return false;

    SwapLine sl = (SwapLine) ew[12];
    if (sl.mJustNeedsSalute) {
      cp.u.mCOPY.mSwapState.throwPaper();
      cp.progress();
      return true;
    }
    return false;
  }
  */

  /*
  Bool rootSynchronize(CPlate & cp) {
    // Root advances paper to scissors
    if (cp.mSource != cp.mSource.minof ||
        !cp.u.mCOPY.mSwapState.isPaper() ||
        mCPlateRPSLoseSN != 0)   // no rock out there
      return false;

    cp.u.mCOPY.mSwapState.throwScissors();
    cp.progress();
    return true;
  }
  */

  Bool checkPlateStateChange(CPlate & cp) {
    /// If I'm the head commander and the probe has succeeded, move on
    if (cp.isHeadCommander() &&
        cp.u.mPROBE.mProbeState == cp.u.mPROBE.cPROBE_DONE) { 
      if (cp.boredom() >= 4u) {
        cp.advancePlateState(CPlate.cPLATESTATE_COPY); // GO GO GO
        return true;
      }
      else return false;
    }
    // Otherwise do general plate state change checking
    return super.checkPlateStateChange(cp);
  }

  Bool tryEmit(CPlate & cp) {
    EventWindow ew;
    if (cp.isHeadCommander() && ew[1] is Empty) {
      if (true) {
        Probe emit(cp);
        ew[1] = emit;
        return true;
      } else {
        // XXX SKIP AROUND PROBING FOR DEBUG
        cp.u.mPROBE.mProbeState = cp.u.mPROBE.cPROBE_DONE;
        return false;
      }
    }
    return false;
  }

  Bool updateProbe(CPlate & cp) {
    CStatePROBE & p = cp.asPROBE();
    which (p.mProbeState) {
      case CStatePROBE.cPROBE_EMIT: {
        if (tryEmit(cp)) {
          p.mProbeState = CStatePROBE.cPROBE_WAIT;
        }
        return true; // Emitted or not
      }
      case CStatePROBE.cPROBE_WAIT: {
      }
      case CStatePROBE.cPROBE_DONE: {
      }
    }
    return false;
  }

  virtual Void behave(CPlate & cp) { 
    doScan(cp);
    assessBoredom(cp);
    if (mCPlateLessSN > 0)   // Waiting for somebody to catch up to us
      return;                // Yes
    if (dieWithoutCPlates(cp)) 
      return;
    if (checkPlateStateChange(cp)) 
      return;
    if (updateProbe(cp))
      return;
    /*
    if (cp.isCargo()) 
      return;

    doScan(cp);
    assessBoredom(cp);
    Bool advanced = advanceRPS(cp);
    if (advanced)
      return;
    if (headEmitSwapLine(cp))
      return;
    if (tailReleaseSwapLine(cp))
      return;
    if (rootSynchronize(cp))
      return;
    */
  }

}
