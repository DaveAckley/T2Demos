transient CPlateBehaviorGrow : CPlateBehavior {
  typedef UGridContent.S2D S2D;
  typedef S2D.Coord SCoord;

  Bool checkPlateStateChange(CPlate & cp) {
    /// If I'm the source and a parent, assess global boredom and trigger regime change
    if (cp.mSource==0u && mKidSN > 0) { 
      Random random;
      if (cp.boredom() >= 5u && random.oneIn(10)) {
        cp.advancePlateState(CPlate.cPLATESTATE_PROBE); // GO GO GO
        return true;
      }
    }
    // Otherwise do general plate state change checking
    return super.checkPlateStateChange(cp);
  }

  Bool imprintOnContent(CPlate & cp) {

    // If we're a new source, imprint on any content
    if (cp.mLocation.isOrigin() && cp.mSource==cp.mSource.maxof && mAnyContentSN != 0) {
      Atom a = ew[mAnyContentSN];
      Content & c = (Content&) a;
      cp.globalInit(c);
      return true;
    }
    return false;
  }

  Bool dieWithoutContent(CPlate & cp) {
    // Otherwise, if there's none of our content, we don't want to be here
    if (mOurContentSN == 0) {
      ew[0] = Empty.instanceof; 
      return true;
    }
    return false;
  }

  Bool growNewCPlate(CPlate & cp) {
    
    // If no empty near our content, nothing to do here
    if (mEmptySN == 0) return false;

    C2D emptyC = ew.getCoordRaw(mEmptySN);
    C2D ourContentC = ew.getCoordRaw(mOurContentSN);
    if (emptyC.manhattanDistance(ourContentC) > 2u) 
      return false; // Too far from content

    C2D origin;
    if (emptyC.manhattanDistance(origin) > 2u) 
      return false; // Too far from us

    C2D negC = origin.subtract(emptyC);
    typedef CPlate.SourceSN SourceSN;
    SourceSN reverseSN = (SourceSN) ew.getSiteNumberRaw(negC);
    CPlate s = cp; // Start with a copy of us
    s.mSource = reverseSN;    // This is how you can always find me my son
    s.mLocation.set(cp.cORIGIN_X, cp.cORIGIN_Y);  // And we're all born at the center of our universe
    s.mMax.set(SCoord.minof, SCoord.minof); // You'll find your own bounds data
    ew[mEmptySN] = s.atomof;      // There you go
    cp.progress();
    return true;
  }

  Bool gossipWithNeighbor(CPlate & cp) {

    // Can't gossip if nobody there
    if (mCPlateSameSN == 0) return false;

    // Check tag, consistency, range, origin

    Atom ncp = ew[mCPlateSameSN];
    CPlate& s = (CPlate&) ncp;

    if (s.getMyTag() != cp.getMyTag()) {
      cp.miscarry();             // due to inconsistency, which is..
      cp.progress();             // ..of a sort
      return true;
    }

    C2D pos = ew.getCoordRaw(mCPlateSameSN);

    C2D theirClaimedLocation = s.mLocation.toC2D();
    C2D ourImpliedLocation = theirClaimedLocation.subtract(pos);
    C2D ourBelievedLocation = cp.mLocation.toC2D();

    // Consider the axes separately for origin finding
    Bool change;
    if (ourImpliedLocation.getX() > ourBelievedLocation.getX()) {
      cp.mLocation.setX(ourImpliedLocation.getX());
      change = true;
    }
    if (ourImpliedLocation.getY() > ourBelievedLocation.getY()) {
      cp.mLocation.setY(ourImpliedLocation.getY());
      change = true;
    }

    if (!change) {
      // If not, update stuff

      // If we extend the max, take that
      if (cp.mLocation.getX() > cp.mMax.getX()) {
        cp.mMax.setX(cp.mLocation.getX());
        change = true;
      }
      if (cp.mLocation.getY() > cp.mMax.getY()) {
        cp.mMax.setY(cp.mLocation.getY());
        change = true;
      }

      // Or if they extend the max, take that
      if (s.mMax.getX() > cp.mMax.getX()) {
        cp.mMax.setX(s.mMax.getX());
        change = true;
      }
      if (s.mMax.getY() > cp.mMax.getY()) {
        cp.mMax.setY(s.mMax.getY());
        change = true;
      }
    }

    if (change)  {

      // If origin or max change, forget live corner info
      cp.resetMinHeadRow();
      cp.resetMaxTailRow();

    } else {

      // Update live corners off self
      if (cp.mLocation.getX() == cp.cORIGIN_X && cp.mLocation.getY() < cp.getMinHeadRow()) {
        cp.setMinHeadRow((SCoord) cp.mLocation.getY()); 
        change = true;
      }

      if (cp.mLocation.getX() == cp.mMax.getX() && cp.mLocation.getY() > cp.u.mGROW.mMaxTailRow) {
        cp.setMaxTailRow((SCoord) cp.mLocation.getY()); 
        change = true;
      }
    }

    if (!change && s.mPlateState == cp.cPLATESTATE_GROW) {

      // Update live corners off neighbor
      if (ourImpliedLocation.equals(ourBelievedLocation) &&  // if we agree on the origin 
          cp.getMinHeadRow() > s.getMinHeadRow()) {          // but they've seen a smaller head
        cp.setMinHeadRow((SCoord) s.getMinHeadRow());        // take it
        change = true;
      }

      if (s.mMax.equals(cp.mMax) &&                          // if we agree on the max
          cp.getMaxTailRow() < s.getMaxTailRow()) {          // but they've seen a bigger tail
        cp.setMaxTailRow(s.getMaxTailRow());                 // take it
        change = true;
      } 
    }

    if (change) {
      cp.progress();
      return true;
    }
    return false;
  }

  virtual Void behave(CPlate & cp) { 

    if (sizeHasOverflowed(cp)) {
      cp.emergencyDeath();
      return;
    }

    doScan(cp);
    assessBoredom(cp);
    if (dieWithoutCPlates(cp)) 
      return;
    if (checkPlateStateChange(cp)) 
      return;
    if (imprintOnContent(cp)) 
      return;
    if (dieWithoutContent(cp))
      return;
    if (growNewCPlate(cp))
      return;
    if (gossipWithNeighbor(cp))
      return;
  }

}
