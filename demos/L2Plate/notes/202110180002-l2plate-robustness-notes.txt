{152}  -*-  mode: text; fill-column: 50;  -*-
[0:

Mon Oct 18 00:02:48 2021 So I've been blasting
basic L2Plates (around MyElement) with x-rays just
to see what happens.

From the basic 3x3 L2 plates, I got a 7x3 L2Plate
to grow out the side -- but it was properly
registered to the 3x3 so it amounted to a
legitimate containing plate for the 3x3.

With some further blasting, though, I got to an
L2Plate that claims it's [3,3] on the west but
[7,3] on the east.
[1:

Mon Oct 18 00:12:18 2021 And there's two spots on
the L2 border where the inconsistent
mL2Info.mSizeOfPlate.x values are in adjacent
L2Plate atoms, but the L2Plate code doesn't detect
that.

[2:

Mon Oct 18 00:13:52 2021 Can we go ahead and fix
that?
[3:

Mon Oct 18 00:15:15 2021 Do we not already have a
place to check explicitly for L2 inconsistencies?
Plate.mustBlockOrDie only deals with L1 stuff.
[4:

Mon Oct 18 12:45:45 2021 Yes, we already have
'virtual Bool Plate.fatalInconsistency()', and we
also had 'L2Plate.fatalInconsistency()' already,
so we added a Moore ngb inconsistency check,
wherein if we're on the same L1 plate, then our L2
plate size and position should be the same.
[6:

Mon Oct 18 12:57:46 2021 And that seemed to work
okay.  Now the 'failures' I'm seeing are more
arguable.  For example, I've got some L1 plates
that

(1) got into a nested L1 relationship that jointly
    filled their L2 plate, but
(2) when the L2 plate reseeded its neighbor L2, it
    (naturally) copied the single side-central L1
    atom nearest it, which
(3) recreated the L1 nested plate but not the L1
    plate that had subsumed it.

And I really don't see any easy way to argue about
that, given our current assumptions.  So this
state I'm currently looking at is 'legitimate',
even though it's not the state we first grew.[7:

Mon Oct 18 13:03:03 2021 But ha!  I did some xray
surgery on it and cut out the bad parts, and now
we're all fixed up again!

Let's keep blasting and look for more
  failures..[8:

Mon Oct 18 13:04:53 2021 OK well there's this:

    20211018130447-561651: 24799AEPS [C8CA5127]MSG: T[1,0]@S[13,23]: behave() failed at ../../../src/core/include/UlamRef.tcc:387: INCONSISTENT_ATOM (site type 0x03E0)
    20211018130447-561652: 24799AEPS [C8CA5127]MSG: BACKTRACE  ->  0: MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::LookupUlamElementTypeFromAtom() const + 0x2BE
     ->  1: MFM::Uq_10105Plate10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_9214mustBlockOrDie(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0xBC2
     ->  2: MFM::Ue_102717L2Plate10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_6behave(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) + 0x14D
     ->  3: MFM::UlamElement<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Behavior(MFM::EventWindow<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0x1E1

leading to

    Failure reached top-level! Aborting
    Makefile:32: recipe for target 'run' failed
    make: *** [run] Error 134

    Compilation exited abnormally with code 2 at Mon Oct 18 13:04:47

and we're wondering (once again) how that
happens.  The entire behave() call should be
wrapped in an unwind_protect, right??

[9:

Mon Oct 18 13:14:06 2021 Well, but there's also a
whole bunch of really-REALLY-similar stack traces
immediately before that one, and they don't lead
to the engine shutting down, so we're thinking
maybe the failure in behave() IS caught, and we're
dealing with something else.

Let's rebuild mfms with debugging and see if we
can catch something in the act of dying.

[10:

Tue Oct 19 12:03:27 2021 OK, have tried a bunch of
xraying and what not but so far haven't caught a
fails-to-top occurrence..

:10]
:9]


:8]

:7]

:6]

[5:

Mon Oct 18 12:55:38 2021 (Now running a script to
do a screen shot once per minute at the top of the
minute, to gather up possible 'visual aids' for
next t2sup.  I would like to get our own viz
working again by the next livestream.  But I would
like a lot of things.)

:5]
:4]

:3]
:2]

:1]

:0]
[11:

Wed Oct 20 10:11:34 2021 OK, so we punched up the
MFM codebase a little, to catch failures durihg
painting by setting up an unwind_protect at the
(new) RootPanel level of painting.[12:

Wed Oct 20 10:27:31 2021 Actually, it appears we
already had an unwind_protect in
TileRenderer::PaintTileAtDit, and that was what
was catching our simple deliberate
MyElement.getColor failure.

The actual crash we were struggling to reproduce
must've come outside the actual painting of the
tiles -- like, during the painting of the tool
palette, perhaps.

Hmm maybe I should have left the tool palette
posted during the background write failures
test..

:12]

:11]
[13:

Wed Oct 20 23:48:59 2021 So it looks like a pretty
common failure, now, is ending up with an L1 plate
that is only incompletely surrounded by L2 plate,
which means the L2 border is incomplete and so the
L2 plate can no longer repair in the direction(s)
lacking a border.[14:

Wed Oct 20 23:52:21 2021 In the current case, for
example, the L2 plate is [4,4] while the L1 plate
is [3,3].

So that's another possible consistency check.
It's an inter-L1/L2 consistency check.
[23:

Thu Oct 21 01:19:47 2021 So, could we do that
check?  Where does it happen?[24:

Thu Oct 21 01:20:27 2021
L2Plate.fatalInconsistency, I guess.  If ngb 'a'
is cCONTAINED_BY self, then we ought to have
self.sizeOfPlate == a.sizeOfPlate+(2,2) and
self.positionOnPlate == a.positionOnPlate.. what?
Have to redo the relationTo computation?

Maybe just check the sizes..  With the argument
that the positions have already been checked -- to
some degree anyway -- during
PlateUtils.relationTo.

Let's try it, anyway.[25:

Thu Oct 21 01:27:54 2021 But hmm, do we really
want to insist on L2Plate size == L1Plate.size +
(2,2)?  That would rule out nested structure among
the L1Plate that the L2Plate is surrounding.

Now, on the one hand, failures involving
unintentional creation of nested L1 plates are one
of the remaining 'germline corruptions' that we
are dealing with.

Insisting that L2.size == L1.size + (2,2) would
make those failures unstable.  But it also means
that we couldn't have L1 plate growing inside an
L2Plate, let alone more complex nested L1
structures.

I think, maybe, let's be weaker for now, and just
say L2.size >= L1.size + (2,2).. and see what we
think about that.
[26:

Thu Oct 21 01:37:56 2021 Well, if what we want to
establish is that the L2Plate has a complete
border, just checking relative sizes doesn't
really do it.  We want sort 'strictly contained'
vs 'contained or even with'.  'Bordered by' rather
than just 'contained by'.  Does PlateUtils already
have something that would help with that?[27:

Thu Oct 21 01:45:20 2021 Well, not super
obviously.  We want

 - a.pos.x > 0, and
 - a.pos.y > 0, and
 - self.size.contains(a.size+a.pos)

Does that do it?[31:

Thu Oct 21 01:55:10 2021 I guess the idea is:
assuming we know a is cCONTAINED_BY self, then
those conditions give us self 'borders' a or
something.

:31][30:

Thu Oct 21 01:53:38 2021 OK, back here.  (This
once-a-minute auto-screenshotting eats up a ton of
space over the days!)[32:

Thu Oct 21 02:22:18 2021 And hmm also: Leaving
audacity recording for 11+ hours will eat up some
space toooooo.

:32]

:30]

:27]

:26]
:25]

:24]

:23]
:14]

:13]
[15:

Thu Oct 21 00:44:31 2021 Ooh we finally caught a
non-tile-painting atom access failure -- under
AtomViewPanel::PaintComponent.  Oh!  That makes
sense: Of course an AVP accesses the atom that
it's pointing at, both to get its color and to
examine its guts.  So if an atom goes crazy under
an AVP, failures are absolutely expected.

So okay: There's reason to have both per-tile and
RootPanel unwind_protects.  So be it.[16:

Thu Oct 21 00:49:38 2021 Ooh and we can even take
a picture of what it looks like..[17:

Thu Oct 21 00:50:32 2021 Buuuuut, umm, the display
is no longer redrawing at all? Even though we're
still getting event-related logging?

Beeeeecause we dropped the display thread when we
unwound back to the top? Or something?[18:

Thu Oct 21 00:52:06 2021 Well, not clear: We just
hit the 'failed to root panel' again (even though
nothing is updating on screen..)[19:

Thu Oct 21 00:53:06 2021 Hmm, once I started
interacting with the UI it started redisplaying
again.. Although it also appears we got rid of the
inconsistent atom under the AVP as well, so we're
not sure what's responsible for the drawing
starting to succeed again..[20:

Thu Oct 21 01:08:44 2021 Now we're save/restoring
the drawing rect and the bg/fg colors; let's see
if that improves the post-fail-to-RootPanel
graphics behavior.  It really might: It seems like
it took a window resizing to get things drawing
again. [21:

Thu Oct 21 01:10:43 2021 OK, we forced one
fail-to-rootpanel with xrays, and it recovered
after we continued..[22:

Thu Oct 21 01:11:22 2021 And there were several
more, and the subsequent drawing appeared to
survive..

:22]

:21]

:20]

:19]

:18]

:17]

:16]

:15]
[28:

Thu Oct 21 01:47:27 2021 Whups hey we just got an
actual fail-all-the-way-to-top!  How did that
happen?? [29:

Thu Oct 21 01:48:16 2021 Oh: Ran out of disk
space!  Not that exciting!

:29]

:28]
[33:

Thu Oct 21 09:54:00 2021 Well, so the overnight
run with the extra L2/L1 enforced border
consistency check seems to've helped things out
rather a lot.. We're still at 3x3 for each of our
four test L2Plates, and each 3x3 still looks
legit.

Did see some overextended 'L2 blues' in a couple
cases, but they both seemed to clean themselves up
after not too long.

So!  (And that stuff's all been committed and
pushed..)

So it's time to head forwards perhaps..?

We'd claimed we wanted to take another run at
L2Plate moving.. Could we think of a few steps
that could head us in that direction?

[34:

Thu Oct 21 09:58:04 2021

 - Review L2PlateSequencer status

 - Demonstrate some whole L2Plate sync mechanism

[35:

Thu Oct 21 09:59:22 2021 And I'm thinking we'll
fall back to a hard-coded -- or at least
compiled-in -- mechanism for deciding where the
L2Plate 'commander' is?

[36:

Thu Oct 21 10:18:28 2021 So right now, it appears
that L2PlateSequencer has nothing directly about
interacting with other L2PlateSequencers, whether
on a single L2Plate or between them.

(We need clearer language for talking about a
'single L2Plate' vs a 'whole L2Plate'.  Right now
it's pretty unclear.)

[37:

Thu Oct 21 10:25:59 2021 So, how do we make
L2PlateSequencer command and control any fraction
as robust as the underlying L2plate currently is?

I'm thinking:

 - Hardcode leader, mL2Info.mPosOnPlate == (0,0)

 - Generate a random tag when leader inits, have
   non-leaders always accept seqno/state when
   leader tag changes.
[41: Fri Oct 22 09:12:38 2021

 - Demonstrate communication between L2PSEQ of
   different L2 sites.

:41]
:37]

:36]

:35]

:34]

:33]
[38:

Thu Oct 21 12:46:40 2021 Quite the battle going on
in the central 'M2'-based L2Plate, between an
upper section that thinks it's on row 2, and a
lower section that thinks it's on row 0.

Not clear how it turns out but drives home that
we're still missing consistency checks between
L2Plates.[39:

Thu Oct 21 13:35:39 2021 Ooh, kind of looks like
it's resolved itself back to the original
position.


:39]

I guess perhaps we could say 'L2 site' vs 'L2
Plate', with an L2 site being a single L2Plate
with a surrounding L2 border.  And an L2 plate
being a grid of L2 sites, sized by their L2 info.

:38]
[40:

Thu Oct 21 13:38:31 2021 OK, so all this
background stress testing has been fun, and
useful.

Now it's time to move the flag.

:40]
[42:

Fri Oct 22 09:38:47 2021 So let's review the Plex
situation: What can we do and what are we missing?

 - Define 'arbitrary' transient (L2PlateSequencer)

 - Define Plex subclass to gather and scatter (and
   optionally render) that transient (L2SeqPlex)

 - Have currently BUSTED AND UNUSED attempts to
   let Plex subclasses render themselves spatially
   (as well as via (extended) AtomViewPanel, which
   do kind of work).[43:

Fri Oct 22 09:54:26 2021 Plex.renderPlex gets
called thusly:

  AtomViewPanel::PaintComponent ->
    Plexer.printPlex() ->
      Plexer.printPlexDefault() ->
        Plex.renderPlex(Drawable&) ->
          L2PlateSequencer.renderPlex(Drawable&)

[44:

Fri Oct 22 10:30:40 2021 And L2PS.renderPlex does
do some drawing at locations that are at least
plausible for landing on top of the gathered L1
sites..

EXCEPT the current transform and clip rectangle is
set for the AVP, not the grid.  So the drawn stuff
ends up inside of (and relative to) the AVP, or
clipped by its edges.

And it's really not clear how to avoid that, given
where we are in the drawing hierarchy.  Even if we
change the transform/clip to the grid panel, we've
already cleared the rect holding the AVP.

We'd have, somehow, to arrange to call renderPlex
during the grid rendering, not during AVP
rendering.[45:

Fri Oct 22 11:00:58 2021 Which would probably mean
we should split printPlex() and renderPlex() into
completely separate API accesses..

How hard would it be to call renderPlex from
TileRenderer (assuming that's where it would
be)?[46:

Fri Oct 22 11:06:30 2021 Two obvious
possibilities.  In TileRenderer::PaintTileAtDit,
we call PaintCustom(..) if m_drawCustom, and
we call PaintOverlays(..) unconditionally.

PaintCustom eventually dishes to
CallRenderGraphics, which calls
UrSelf.renderGraphics() .. Could we just use that
instead of renderPlex at all?[47:

Fri Oct 22 11:40:29 2021 But the question is: Who
calls Plex.open(false), before anyone could call
UrSelf.renderGraphics() on it?  I guess it would
be something like

..Plexer..

    Void renderGraphics() {
      super.renderGraphics(); // Draw on top of any other rendering?
      renderGraphicsDefault();
    }

    Void renderGraphicsDefault() {
        Plexer.ClassId classid = self.getPlex();
        ClassUtils cu;
        if (!cu.isBase(classid,Plex.classidof)) return super;

        typedef BitStorageT(8192) BitStorage8K;
        BitStorage8K bs;

        Plex & plex = (Plex &) bs.recast(classid, true);
        if (!plex.open(false)) return;
        UrSelf & urs = plex.get();

        urs.renderGraphics();
    }

[48:

Fri Oct 22 15:44:26 2021 OK, so took a crack at
that and there's just on teensy little problem:
There's no event window during site painting, so
all attempts to gather the plex fail with

    Render failed: UNSUPPORTED_OPERATION (../../../src/core/include/UlamContextRestricted.h:57)

which is pointing at 'GetEventWindow()'

So what do we do about that?  We explicitly gave
an ew to AVP[49:

Sat Oct 23 00:21:47 2021 ..so we do the same here?
We say that having an UNCOMMITABLE event window is
no problem, and rendering code can even write to
it if it wants, but the window won't be written
back to the tile no matter what.

We could insist on relatively undefined behavior
perhaps -- that writes to the ew may or may not be
visible even during while the renderGraphics() (or
whatever) code is running.  Writes might:

(1) Be utterly ignored -- re-read sees original
(2) Fail (waah-ha, so don't do it)
(3) Apparently succeed but never commit

It would be best to make it (2) -- so people don't
get any ideas -- but that also seems the hardest
to implement from where the code stands now?

[50:

Sat Oct 23 00:27:27 2021 There's also possible
leakage via random number consumption.. Is it
worth still NOT presenting access to the RNG even
when granting (read only) access to the whole ew?
Or having a whole separate RNG to use only during
renderGraphics calls?[51:

Sat Oct 23 00:54:22 2021 Well, let's just carry
whatever AVP does during PaintComponent and see
how bad it looks in TileRenderer.

:51]

:50]
:49]

:48]

:47]

:46]

:45]


:44]

:43]

:42]
[52:

Sat Oct 23 09:08:01 2021 Hmm long run seems to
show our PlateUtils.strictlyContains method is
buggy.  It's not flagging any of:

container (5,1)[6,9]  (4,0)[6,9]  (0,0)[6,9]
containee (4,0)[5,7]  (4,0)[5,7]  (0,0)[5,7]

as violations even though there's no west border
on the resulting L2Plate.  Why not?
[54:

Sat Oct 23 09:23:40 2021 Or actually maybe the
deeper errors are a missing eastern border, as in

container (1,0)[6,9]  (5,0)[6,9]  (0,6)[6,9]
containee (0,0)[5,7]  (4,0)[5,7]  (0,5)[5,7]

[55:

Sat Oct 23 09:26:38 2021 Actually it's looking
like both (missing west or east border) are
stable..

:55]

:54]
[53:

Sat Oct 23 09:14:16 2021 Perhaps because rel is
not coming back cCONTAINS_PLATE?  (In which case
strictlyContains won't even be called.)
[56:

Sat Oct 23 09:27:20 2021 Let's follow say

container (1,0)[6,9]
containee (0,0)[5,7]

this one through relationTo.

Let's say ewoffsetl is (0,0), and ewoffsetr is
(0,1).  If they're not, we're fogged.

so we're saying we've got:
relationTo(pl=(1,0)[6,9], ewoffsetl=(0,0),
           pr=(0,0)[5,7], ewoffsetr=(0,1))

L2Plate is Stride1x1FP, and MyElement is B2DPlate4
which is B2DTPlate(4) which is Plate which
defaults to stride {1,1} and phase (0,0), so
stride and phase should match.

Let's pretend inStride(..) returns true too,
although we haven't gone through it.

Except we need the pcdiff that it computes..

Sigh.  So it's like

  inStride(ew1=(0,0), ew2=(0,1), str={1,1}, pcdiff)

so
ewdiff = (0,-1)  and
pcdf = (0,-1)    and
ret = true       and
pcdiff = (0,-1)

So.. back out in relationTo, we get

tbl((6,9), -(1,0))
tbr((5,7), -(0,0) + (0,-1))

so
tbl((6,9), (-1,0))  ->  tbl(mMin = (-1,0), mMax = (-1,0)+(6,9)+(-1,-1))
tbr((5,7), (0,-1))  ->  tbr(mMin = (0,-1), mMax = (0,-1)+(5,7)+(-1,-1)

or

tbl((6,9), (-1,0))  ->  tbl(mMin = (-1,0), mMax = (-2,-1)+(6,9))
tbr((5,7), (0,-1))  ->  tbr(mMin = (0,-1), mMax = (-1,-2)+(5,7))

tbl((6,9), (-1,0))  ->  tbl(mMin = (-1,0), mMax = (4,8))
tbr((5,7), (0,-1))  ->  tbr(mMin = (0,-1), mMax = (4,5))

which are different so we don't return cSAME_PLATE_AS..

so
inter = tbl.intersectionWith(tbr)

 =
[57:

Sat Oct 23 10:58:52 2021 Ah, I see a problem.  The
ngb loop in L2Plate.fatalInconsistency is using

 if (a as Self) ..

so it's only considering other L2Plates.
[58:

Sat Oct 23 11:31:33 2021 So it does seem like
pu.strictlyContains has some issues.  Going to
need to go through that closer, but not right
now.. [59:

Sat Oct 23 13:48:46 2021 In particular, it seems
we have to know the C2D offset between container
and containee or the strictlyContains answer isn't
even well-defined.

    (0,0)   (1,0)   (2,0)        (5,0)
    [6,9]   [6,9]   [6,9]  ..    [6,9]

    (0,1)   (0,0)   (1,0)  ..    (4,0)
    [6,9]   [5,7]   [5,7]        [5,7]

so I guess we want to (re)compute the tboxes and
ask strictlyContains on them..



:59]

:58]
:57]
:56]

:53]

:52]
[60:

Sun Oct 24 02:57:46 2021 Going to let the current
quadratic-time movie run a few hours longer --
because the L2Plates are still holding up great so
far despite write faults -- but I think a next
stop would be to rewrite L2PlateSequencer to focus
on inter-L2 site synchronization rather than local
spatial sensing.

I'd like to see a 'full' (3x3) L2 plate doing
tick-tock synchronization across the whole plate,
and then perpetually falling towards that sync
when write faults disrupt L2 sites.

:60]
[61:

Sun Oct 24 09:23:53 2021 So if we do a new
L2PlateSeq, what do we put in?

[62:

Sun Oct 24 10:39:37 2021

 - RPS for sync

 - QStream around the L2 site border

 - QStream between L2 sites?

[63:

Sun Oct 24 10:51:06 2021 It raises the general
question of stream vs state. In the 'standard' RPS
approach we can directly inspect our up- and
downstream neighbors to assess their current
state.

If we're 'just' sending packets around the L2 site
border, we have to remember the last upstream and
downstream packets we saw.  And where do we decide
that ALL our our downstreams have reached some
state?

And how do we allow rebuilt L2 sites to rejoin the
sync in some coherent way?

Suppose we propagated state on all L2 site
borders, and forget about QStream for now.

Suppose we have newly-seeded L2Plate come up in
a fourth color GREY, instead of any of RGB.[64:

Sun Oct 24 14:46:52 2021 OK, so which is it: Do we
try to communicate RPS state via QStream packets,
or rejigger the definition of L2Plate itself?

How could it go, just at the L2 site level, to
coorindate RPS info via packet?

Suppose we circulated a packet saying "Here's what
we believe are the current upstream and the
current downstream colors. If you see something
that falsifies this, update it as it passes."

I guess maybe it says "Here's OUR current color,
AND what we believe are upstream and downstream",
and sides can update the upstream and downstream
based on their observations, but only North (say)
can change the OUR color.[65:

Sun Oct 24 16:14:04 2021 Well I think it's clearly
too late to be trying to get any packet stuff
going for #3110.  We never got it going at L2
before and now whatever we've done is swapped and
obfuscatory at best.

We might be able to rejigger the definition of
L2Plate itself.

We should probably move on to s12-L2Plate before
we try though..
[66:

Sun Oct 24 16:18:40 2021 Aaaand here we are in
s13..

Let's ditch the abortive L2PlateSequencer11 before
it confuses us more..[67:

Sun Oct 24 16:20:27 2021 Done.

:67]

:66]
:65]

:64]

:63]

:62]

:61]
[68:

Sun Oct 24 16:43:29 2021 So the current bit budget
of L2Plate is:

  /*__________________________________________________
  | COMPONENTS of L2Plate <32> (71 bits/0 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 18	| mL2Info	| B2DPlate4 <60>
  | 18	| 0	| super	| L2PlateBase <56>
  | 18	| 25	| base	| PayloadT(24) <46>
  | 43	| 0	| base	| Plexer <57>
  | 43	| 0	| base	| UrSelf <0>
  | 43	| 0	| base	| B2DStreamPlateBase <34>
  | 43	| 0	| base	| B2DStreamPlate6 <48>
  | 43	| 0	| base	| B2DStreamPlateT(6) <39>
  | 43	| 0	| base	| Stride1x1FP <53>
  | 43	| 0	| base	| B2DPlateBase <65>
  | 43	| 26	| base	| B2DTPlate(6) <43>
  | 69	| 0	| base	| Plate <35>
  | 69	| 2	| base	| QStream12 <36>
  | 71	| 0	| base	| Payload <37>
  |___________________________________________________
  */ //gcnl:NodeBlockClass.cpp:2644

and I'm thinking we should just steal a few bits
from PayloadT(24) to get ourselves some RPS room.

Let's go for PayloadT(20u).  Let's also find some
RPS code to model after.

:68]
[69:

Mon Oct 25 00:49:16 2021 OK, so quark RGBSync with
element RGBSyncDemo is working enough that I'm
starting to look at robustness issues.  And sure
enough it's easy to get local RGB lockups when
there's background write faults erasing atoms and
such.

Thinking about ways to respond. Of course we could
kill the whole sync domain, but we'd like to
explore the behavior of more local strategies.

What if we said this:

  If you can see more than two states among
  neighbors, go to cINIT_STATE

? Idea is that a RGB lockup will go to
two-state+cINIT_STATE, and the cINIT_STATE will
then spread along the 'fault line' between the two
states -- but it won't push into solid regions.

Let's Try It!
[75:

Mon Oct 25 11:17:53 2021 OK so 'seeing more than
two states' (including self) obviously doesn't
work because it happens regularly, with one color
downstream and another upstream.

Is the trapping state having two non-self colors
both upstream or both downstream? And should we be
assigning cINIT_STATE to the whole ngb, not just
self? [76:

Mon Oct 25 11:59:22 2021 Well, it looks like at
least the nuke-whole-neighborhood sync repair
mechanism is kind of working.  Kind of wow!

:76]

:75]
[70:

Mon Oct 25 01:05:29 2021 Well, our current
RGBSync.findNgb API is a real disaster for
answering the 'census' question, so I think we
need to refactor real quick.

We want an iterator over RGBSync, I guess. Plus some
way to tell if one RGBSync is upstream,
downstream, or neither, with respect to another.

[71:

Mon Oct 25 01:13:02 2021 Aand where do we put the
custom RGBSyncIterator iteration state, in this
no-malloc world?  We can't have to foggen recast
for it do we?

Could we basically implement malloc using recast,
if we wanted to, BTW?  Anyway.

[72:

Mon Oct 25 01:16:55 2021 Or we hardcode to SNs?
Was hoping to avoid that at the RGBSync level.

Or we could just try to provide a palette of
useful state in a transient, and let subclasses
decide how to use it:

    transient RGBSyncIterator {
      C2D mFirstC2D, mLastC2D, mNextC2D;
      SN mFirstSN, mNextSN, mLastSN;

      //// RGBSyncIterator API
      virtual Void init() ;
      virtual Bool hasNext() ;
      virtual RGBSync & next() ;
    }

plus like maybe

   typedef Int(2) SyncRelation;
   SyncRelation cOTHER_IS_UPSTREAM = 1;
   SyncRelation cOTHER_IS_DOWNSTREAM = -1;
   SyncRelation cOTHER_IS_UNRELATED = 0;
   virtual Relation syncRelation(RGBSync & other) ;

[73:

Mon Oct 25 01:54:57 2021 Ugh stalled trying to
convince myself to implement that.

Go the other way? Pass a visitor to the sub and
let it iterate however it likes?

But how does the visitor store hits?  That pushes
us back to SNs.
[74:

Mon Oct 25 02:11:22 2021 What about maybe yes
using a BitStorage?  In for a penny?  Subclass
offers a classid for an iterator, RGBSync recasts
one and starts using it.

:74]
:73]
:72]

:71]

:70]

:69]
[77:

Mon Oct 25 12:02:28 2021 Overdue to announce
tomorrow's livestream.  But want a little more
confirmation on the self-stabilizing-rgbsync
though.  Let's just make the demo cell bigger..
[78:

Mon Oct 25 12:32:30 2021 RGBSyncDemo[11,9] looks
pretty good!  Can see some vicious fights with
inconsistent states gradually get ironed out.
Although the whole thing blows itself up pretty
often too -- because it doesn't have L2 site
respawning.

Let's announce the livestream, then try to carry
RGBSync over into L2Plate![79:

Mon Oct 25 12:44:37 2021 OK, livestream
scheduled.  Now L2Plate.[80:

Mon Oct 25 12:47:26 2021 OK, so we need an
RGBSyncIterator designed for L2Plate.  Could we do
like Moore neighborhood plus the four corners of
the ew?[81:

Mon Oct 25 14:49:39 2021 Made some progress which
revealed a thinko: Need to check two sides when
we're in an L2 site corner, not just one, so we
have to rework the iterator again.

I guess just check all four directions, searching
for L2 cSAME_PLATE_AS but l2posl != l2posr?

:81]

:80]

:79]

:78]

:77]
[82:

Wed Oct 27 06:48:58 2021 OK so we got through
t2sup#3110, though not without some tech foggups.

We got the L2PlateRGBSyncIterator visiting the
Moore ngb sites that are in same L2 site, and the
distance 3 orthogonals that are in different L2
sites.  Which seems to make some weird kind of
sense.  Maybe.

In any case, we're thinking about reworking the
whole thing around four states rather than
three. A cYELLOW_STATE to lead green rising up
over red, analogous to the current cBLUE_STATE
that leads red falling down over green.

But I guess I don't have much clarity about the
idea really.

[83:

Wed Oct 27 07:00:45 2021 It's supposed to make it
clearer how to make things better from a standing
start.  And how would that work?

ATTRACTOR DYNAMICS
 CURME  ALLUP ALLDOWN NEWME
   R             Y     Y     R trailing edge / Y leading edge (up)
   Y     Y             G     Y trailing edge / G leading edge (up)
   G     B             B     G trailing edge / B leading edge (down)
   B     R             R     B trailing edge / R leading edge (down)

SYMMETRIC STABILIZATION DYNAMICS
 CURME  ANYUP ANYDOWN ACTION
   R     !R            SWAP  R diffuse up
   G            !G     SWAP  G diffuse down
   B     G       R     SWAP  B diffuse center
   Y     G       R     SWAP  Y diffuse center

SYMMETRY BREAKING DYNAMICS
 CURME  ANYNGB NEWME
   B     Y      Y    Break ties upward

[85:

Thu Oct 28 14:08:35 2021 Well, maybe that's even
kind of plausible. Time to implement it, I
think.[86:

Thu Oct 28 14:30:02 2021 OK, so we're going to:

 - Out with cINIT_STATE in with cYELLOW_STATE

 - Init to cRED_STATE I guess

:86]

:85]
:83]
:82]
[84:

Thu Oct 28 00:00:26 2021 Feeling a little flu-ey
11 hours after Moderna booster.  Again (still)
working on the :83: transition table above.
Getting Y in there.

:84]
[87:

Fri Oct 29 02:31:18 2021 OK have hacked a bunch
towards implementing the re-re-revised :83: rules
above, and now wondering: Do we need 'symmetric
stabilization' rules for B and Y?  It seems like
'just' an efficiency thing since the R and G rules
-- with their 'wildcard' anyup and anydown
matching -- will migrate B and Y toward 'the
center' anyway.  And the logic for the B and Y
rules is used only that once..  Let's ditch that
and go with just this:

SYMMETRIC STABILIZATION DYNAMICS
 CURME  ANYUP ANYDOWN ACTION
   R     !R            SWAP  R diffuse up
   G            !G     SWAP  G diffuse down

for the basic repair case..
[88:

Fri Oct 29 02:40:23 2021 Although now that I think
about it, it seems like we're maybe still risking
deadlock: Suppose we have loose B and Y both
floating around.  They'll get pushed below R and
above G, but there's nothing that lets B and Y
diffuse laterally along the R-G interface, so how
will B and Y find each other to invoke the
symmetry breaking rule?

Could we have the main special case be whenever R
encounters G?  Since it won't in the attractor
dynamics.

What if it was that if R sees G anywhere in the
neighborhood, it turns Y, and the same for G
seeing R.  So the asymmetric dynamics is both
sides turn yellow, and therefore (?) a yellow
boundary layer will form to separate the R and G,
and that Y layer *will* eventually encounter any B
that are also separating R and Gs.

Seems plausible.

Seems, actually that we should maybe want to break
symmetry toward B rather than Y, so muddled cases
will tend to clean up heading down -- argument
being that we'd rather see too few apparent round
trips at the upstream root, rather than too many.

[89:

Fri Oct 29 02:49:57 2021 Now, all this is
completely untested (mostly unimplemented), and I
could believe we're missing a lot of state space
-- there's lots of cases that aren't ALLUP/ALLDOWN
or ANYUP/ANYDOWN -- so deadlocks will remain
possible.  Or are there?  Man I am still fuzzy
fuzzy here.  We're not covering NONEUP/NONEDOWN, I
guess, so that's the potential missing space.

Taking a break though.  Fuzzed out; still body
aches and such.[90:

Fri Oct 29 10:48:52 2021 (Had a bunch of camera
stuff here that I moved to
/data/ackley/AV/FUJIFILM-X-T4/notes/202110291002-notes.txt
)

:90]

:89]

:88]
:87]
[91:

Thu Nov  4 11:44:37 2021 OK well after being off
for a couple days dealing with t2tile.com and the
first X-T4 timelapse, I got back to the WIP and
just now got the code roughly all filled in.

Things are deadlocking with various combinations
of Y and G next to each other, and a couple R in
upper left corners. What's supposed to be
happening there?

[92:

Thu Nov  4 11:49:17 2021 Well it appears I didn't
even try to implement the last two rows of
SYMMETRIC STABILIZATION DYNAMICS, :83: above, but
I did try to implement this part:

 CURME  ANYUP ANYDOWN ACTION
   G            !G     SWAP  G diffuse down

which doesn't appear to be working in the current
case. So let's look at that.

:92]

:91]
[93:

Thu Nov  4 12:10:02 2021 OK, so this rule:

    ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       Y     Y             G     Y trailing edge / G leading edge (up)

seems too loose: We've got Y -> G happening when
there's still !G (specifically Y) downstream.
Should it be ALLUP==Y and ALLDOWN==G? If so
shouldn't other rules change too?

[94:

Thu Nov  4 12:18:50 2021 So we're switching to
this:

    ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       R     R       Y     Y     R trailing edge / Y leading edge (up)
       Y     Y       G     G     Y trailing edge / G leading edge (up)
       G     B       G     B     G trailing edge / B leading edge (down)
       B     R       B     R     B trailing edge / R leading edge (down)

[95:

Thu Nov  4 12:22:17 2021 OK now we're deadlocked
by a Y surrounded by R -- what did we want to
happen there?

Well, at least, we'd expect

    SYMMETRIC STABILIZATION DYNAMICS
     CURME  ANYUP ANYDOWN ACTION
       R     !R            SWAP  R diffuse up

to fire on a downstream R. Why isn't that
happening? [96:

Thu Nov  4 12:26:00 2021 Well, we're still getting
SWAPPO on RGBSyncDemo's that are both R, which
seems to suggest a rule problem somewhere..
[97:

Thu Nov  4 12:40:32 2021 OK, bug in
sampleIsntInDir. Getting close to time to move the
flag here, but going again.
[98:

Thu Nov  4 12:42:21 2021 And boom! Looks like
we're working (error free) in both RGBSyncDemo and
L2Plate![99:

Thu Nov  4 12:46:12 2021 OK, I started in with the
write faults and we still have at least one
deadlock.

What should G with upstream R and upstream Y do?
Actually, let's restate our current dynamics
first.
[100:

Thu Nov  4 12:49:11 2021

   ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       R     R       Y     Y     R trailing edge / Y leading edge (up)
       Y     Y       G     G     Y trailing edge / G leading edge (up)
       G     B       G     B     G trailing edge / B leading edge (down)
       B     R       B     R     B trailing edge / R leading edge (down)

    SYMMETRIC STABILIZATION DYNAMICS
     CURME  ANYUP ANYDOWN ACTION
       R     !R            SWAP  R diffuse up
       G            !G     SWAP  G diffuse down
  [NYI B     G       R     SWAP  B diffuse center  ]
  [NYI Y     G       R     SWAP  Y diffuse center  ]

    SYMMETRY BREAKING DYNAMICS
     CURME  ANYNGB NEWME
       B     Y      Y    Break ties upward

:100]
[101:

Thu Nov  4 12:52:50 2021 So, G with uR and uY
should do what?

ATTRACTOR says nothing.

Oh I guess the key is the current case also has
all downstream G, so STABILIZATION says nothing.

So, a bigger point about the Y/B isolation is that
R & G should never be neighbors.  More BREAKING
rules maybe:

    SYMMETRY BREAKING DYNAMICS
     CURME  ANYNGB NEWME
       B     Y      Y    Break ties upward
       R     G      Y    Resolve inconsistencies up?

 :101]

:99]

:98]

:97]

:96]

:95]:94]
:93]
[102:

Thu Nov  4 13:20:55 2021 Upps, thought I had it
all, but looks like another deadlock here.

B with uR and dG, what should that do?

[103:

Thu Nov  4 13:24:29 2021 It's close to

     CURME  ALLUP ALLDOWN NEWME
       B     R       B     R     B trailing edge / R leading edge (down)

 except it's got down G
[104:

Thu Nov  4 13:28:41 2021 I guess another way to
look at it is the problem is a G with both uB and
uG.  So the ATTRACTOR G rule can't go since not
ALL uB.

Could we make a stabilization swap rule?

[105:

Thu Nov  4 13:30:42 2021 Have to think about it.
Time to move the flag.[106:

Thu Nov  4 14:53:14 2021 Moved.

:106]

:105]
:104]

:103]
:102]
[107:

Thu Nov  4 14:56:00 2021

   ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       R     R       Y     Y     R trailing edge / Y leading edge (up)
       Y     Y       G     G     Y trailing edge / G leading edge (up)
       G     B       G     B     G trailing edge / B leading edge (down)
       B     R       B     R     B trailing edge / R leading edge (down)

    SYMMETRIC STABILIZATION DYNAMICS
     CURME  ANYUP ANYDOWN ACTION
       R     !R            SWAP  R diffuse up
       Y     !Y            SWAP  Y diffuse up
       G            !G     SWAP  G diffuse down
       B            !B     SWAP  B diffuse down

    SYMMETRY BREAKING DYNAMICS
     CURME  ANYNGB NEWME
       B     Y      Y    Break ties upward
       R     G      Y    Break ties upward

[108:

Thu Nov  4 15:33:04 2021 Trying this.  Thinking
the extra STABILIZATION rules are going to be
destabilizing, but we'll see.[109:

Thu Nov  4 15:34:18 2021 Yeah, it's a mess. It
never gets past R and Y mixing it up. R is
supposed to be above Y; we don't really want to
say

     CURME  ANYUP ANYDOWN ACTION
       Y     !Y            SWAP  Y diffuse up

we want to say

     CURME  ANYUP ANYDOWN ACTION
       Y    !Y&!R          SWAP  Y diffuse up

but we don't have that. Just do two rules, for a
try anyway?

     CURME  ANYUP ANYDOWN ACTION
       Y     G             SWAP  Y diffuse up
       Y     B             SWAP  Y diffuse up
       B             R     SWAP  B diffuse down
       B             Y     SWAP  B diffuse down

:109]

:108]
:107]
[110:

Fri Nov  5 01:21:01 2021 OK so we're back to a
larger-scale deadlock, with R Y G in one corner of
an L2 site and R B G on the diagonal corner, and
neither is moving.  We need some kind of diffusion
that will, eventually, get the Y and B in sight of
each other..

[111:

Fri Nov  5 01:29:31 2021 Let's maybe say that if
nothing else fires, we try for these:

    DIFFUSION DYNAMICS
       ME  ANYUP ANYDOWN  ACTIONS
       B      R      G     u <- m, m <- d  [B diffuse up]
       Y      R      G     d <- m, m <- u  [Y diffuse down]

and.. see what happens.  Very unclear how ..
[112:

Fri Nov  5 01:36:39 2021 Actually wait. What about
considering slightly relaxed versions of the
attractor dynamics?  For example, the attractor
has

   ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       B     R       B     R     B trailing edge / R leading edge (down)

and one of the stuck B has 'half' of that -- ALLUP
R, and it has ANYDOWN B, but not ALLDOWN B.  So
it's 'close'.  What if that bein diffuses?

:112]

:111]

:110]
[113:

Fri Nov  5 01:41:12 2021 Or as another disgusting
hack, what if, as a last ditch rule we say

    CURME  ODDS   NEWME
      B    .01%     Y

calling it the 'random switch direction' rule.
Like Crazy Ivan or something.

The rules as we've set them up do not have
explicit 'wait' states -- where NEWME == CURME --
which means we can't distinguish 'meta stable
states' from 'uncovered states' in the transition
function.  If we knew we were in an uncovered
state..

A 'STABLE FIELD' rule like

  CURME   ALLNGB    NEWME
    X       X         X

would 'cover' lots of unchanging sites, so the
final uncovered rule could be more aggressive.


:113]
[114:

Fri Nov  5 02:50:19 2021 One question is whether
updateRGBSync should ever actually return true?
Well yeah, I guess so -- although RGBSync SEEMS
very standalone at the moment, eventually it needs
to get coupled in to larger computational goals,
and indeed we don't want to return false if those
goals should not depend on the rgbsync state.[115:

Fri Nov  5 10:32:26 2021 So my 'Crazy Ivan'
changeDirection(Color) method does break deadlocks
pretty well, it seems -- but it also CAUSES them,
sometimes, and also causes premature turnarounds
sometimes, so the root thinks a round trip has
completed but the tail knows nothing about it.

:115]

:114]
[116:

Sat Nov  6 23:30:38 2021 What about something like
this:

 CURME ALLUP  ANYDOWN   ACTION
   B     R       !B       u <- B; m <- !B

or I'm not sure how to write it, but: If

 - I'm B
 - all upstream are R, and
 - no downstream is B, and
 - some downstream is not B

then pick an upstream and make it B, and pick a
downstream and make us that.[118:

Sun Nov  7 00:51:24 2021 OK we've now tried that
in 'Bool blueUp(RGBSync & me)' and it too messes
up the attractor dynamics because that state
absolutely occurs naturally on the attractor.
[119:

Sun Nov  7 01:20:28 2021 You know, what about if
we just did symmetric interclocking between root
and tail?  For starters say just two bits U and D,
and the update rule for field sites is adopt the
majority in each direction:

 U = count(UPSTREAM,U,true) > count(UPSTREAM,U,false)
 D = count(DOWNSTREAM,D,true) > count(DOWNSTREAM,D,false)

maybe with ties going to no change?

So the idea is the U bit is well-founded against
(whatever is currently passing for) the root, and
the D bit is well-founded against the tail.

And then the interclocking special cases are:

 if root and U == D, U = !U    # mismatch
 if tail and D != U, D = !D    # match

so tail is endlessly trying to match root, and
root is endlessly trying to be different than
tail.

[120:

Sun Nov  7 01:28:44 2021 Probably say ties should
randomize rather than stand..  But doesn't this
make fundamental sense?  DOESN'T IT?

[121:

Sun Nov  7 01:30:42 2021 I guess there's a risk we
could end up with multiple cycles in flight at
once?  And then what stops the whole thing from
turning into hash?  If root and tail had some
extra damping that could be minimized but that's
extra state.

[122:

Sun Nov  7 01:35:04 2021 What about if we required
unanimity instead of majority?  With the claim
that it won't hard deadlock because of
well-foundedness?

 if (allNgb(UPSTREAM,U,true))       U = true;
 else if (allNgb(UPSTREAM,U,false)) U = false;
 // else U unchanged

 if (allNgb(DOWNSTREAM,D,true))       D = true;
 else if (allNgb(DOWNSTREAM,D,false)) D = false;
 // else D unchanged

[123:

Sun Nov  7 01:47:49 2021 Could I lay this on top
of RGBY or do I want to fork a whole new
RGBSync.ulam to try this?

R|G -> U == false
B|Y -> U == true
R|B -> D == false
G|Y -> D == true
[124:

Sun Nov  7 02:09:07 2021 Making SICSync.ulam
though I want a better name.. Do I want a 3D array
for SICNeighborhood counting?

  ByteCount[dir][u-or-d][t-or-f]

?  That's the general case, but really we only
care about u upstream and d downstream, right?

  ByteCount mUpCount, mUpVals[2];
  ByteCount mDownCount, mDownVals[2];

:124]
:123]
:122]

:121]

  :120]

:119]
:118]
[117:

Sat Nov  6 23:44:17 2021 So that's close to one of
the 'DIFFUSION DYNAMICS' rules from :111: above,
which it seems we never tried?

:117]
:116]
[125:

Sun Nov  7 03:19:08 2021 And for the record, once
again,

  SYMMETRIC INTERCLOCKING WORKS GREAT

-- this time for L2Plate sync -- and it's
FANTASTICALLY ROBUST AND UTTERLY BEAUTIFUL.

FOGG THAT ROCK-PAPER-SCISSORS STUFF

FOGG THAT KTN-SYNC-OVER-ASYNC STUFF

SYMMETRIC INTERCLOCKING FOR THE FOGGING WIN

:125]
[126:

Sun Nov  7 07:35:33 2021 Let's clean up a little
here and then survey the landscape looking ahead!
[127:

Sun Nov  7 07:37:21 2021 Let's have a better name
than SICSync OK?  What shall it be?

 - We had some thoughts about alternate names back
   when we first discovered/invented this, right?
   What were we thinking then?

[128:

Sun Nov  7 09:11:45 2021 Ahem.  Back from
drifting through the Dec 2017 development notes in
T2-12/low/pru/itcio/notes/201711120544-itcio-notes.txt

So:

 - Distributed NOT-gate (Found one paper with and
   an exact hit for that -- about quantum
   communication bounds).  But we need a
   distributed *self-connected* NOT-gate

 - Distributed Oscillator

[129:

Sun Nov  7 09:17:00 2021 Hmm is it maybe just

 - Ring Oscillator?

..but a ring oscillator only needs one line and
we're using two.  Actually no: A ring oscillator
does need two lines -- out and back -- to close
the ring.

And wikipedia tells us early on that a ring
oscillator can have both inverting and
non-inverting stages, so long as there's an odd
number of inverting stages.

So our thing is a ring oscillator with one
inverting stage (the mismatch stage currently in
the 'ROOT TICK' section).  ROOT TICK inverts via

  upstate = !downstate

while TAIL TOCK is non-inverting via

  downstate = upstate

and all the field sites amount to a pair of wires,
a 'downbound one' doing

  downstate = upstate

and and 'upbound one' doing

  upstate = downstate.

[130:

Sun Nov  7 09:25:25 2021 So all together we have

 - two long pieces of wire between ROOT and TAIL,

 - a loopback connection at TAIL, and

 - a single inverter at ROOT,

forming a RING OSCILLATOR

[131:

Sun Nov  7 09:29:51 2021 And, FINALLY, searching
for "DISTRIBUTED RING OSCILLATOR" finds relevant
papers, like

 - "Clock distribution using cooperative ring
   oscillators" (1997)

 - "Design of a 10GHz Clock Distribution Network
    Using Coupled Standing-Wave Oscillators"
    (2003)

 - "Analysis and Verification of Interconnected
   Rings as Clock Distribution Networks" (2004)

 - "A Distributed Synchronized Clocking Method"
   (2005)

 - "Distributed source-destination synchronization
   using inband clock distribution (2006)[133: Sun
   Nov  7 10:39:46 2021 This might be kind of
   fundamentally different, not sure.  :133]

[132:

Sun Nov  7 10:36:58 2021 So things like:

 - PDRO: Programmable Distributed Ring Oscillator

 - P2PDRO: Point-to-point Distributed Ring
   Oscillator

 - DROSS: DRO for Software Synchronization

 - DiRiOs: Distributed Ring Oscillator (slogan:
   "Are You DiRiOs?")

 - GDRO: General DRO

 - DROC: DRO Clock

[134:

Sun Nov  7 10:47:35 2021 So none of those really
grab me but I think we have to have DRO in there
somewhere.  It does seem that the
point-to-pointness of this design is pretty key.
Not sure of good compact ways to express that.
1D?

DRO1D - Distributed Ring Oscillator 1D?

[135:

Sun Nov  7 10:52:25 2021 Link? Endpoints?

DROLL - DRO Link Layer

DROPTP - DRO Point-To-Point

DROP2P - DRO Point-2-Point

SIDRO - Single Inverter DRO

DROSI - DRO - Single Inverter

But we want to get the linearization in there
too.  Yes there's only one inverter, but there's
really only one non-inverting gate in there too,
with the rest just being 'wire'

VCDRO - Virtual Circuit DRO

[136:

Sun Nov  7 10:59:45 2021 Virtual Circuit has some
potential since it kind of gets end-to-end flavor
in there, as well as 'circuit' obviously.

[137:

Sun Nov  7 11:01:46 2021 Still leaning to GDRO so
far I think.  For base class quark name
anyway.[138:

Sun Nov  7 14:55:54 2021 Renamed to GDRO.ulam and
cleaned up some.[139:

Sun Nov  7 15:02:20 2021 OK, so if we're to carry
additional information alongside the clock signal,
we need API to advance that information during
wire propagation.

Which maybe in fact means we want some API in the
iterator to merge across multiple
upstream/downstream sources..  I'd been thinking
we'd just sample randomly once we had clock
unanimity but I could pretty easily see wanting
other mappy-reducey options..

[140:

Sun Nov  7 15:08:09 2021 Although since we don't
have a tree here, but a set of overlapping
neighborhoods, it's a little harder to imagine how
we could, say, count instances using this
mechanism.  How would we ensure each site gets
counted once and only once?

We could do idempotent &= and |= stuff, but I
don't see how to count..

Could do shortest path stuff with min(parents)+1

Which could give us a centralized clue about we're
actually a full-sized L2 plate, if we wanted to
care.

:140]

:139]

:138]

:137]

:136]

:135]

:134]
:132]
:131]

:130]

:129]

:128]

:127]

:126]
[141:


Sun Nov  7 15:24:58 2021


   .  .  .   1  .  .   1  .  .   1  .  .   1  2  .   1  2  .

   .  .  .   .  .  .   2  .  .   2  .  .   2  .  .   2  3  .

   .  .  .   .  .  .   .  .  .   3  .  .   3  .  .   3  .  .


:141]
[142:

Sun Nov  7 15:32:21 2021 So, API for merging
associated state.  Do we do it on every iteration,
before we know whether we're going to have
unanimity?  Or do we rescan when we find out we
do?  Have to think update events are rare compared
to no-change; maybe rescan?
[143:

Sun Nov  7 15:48:56 2021 If we're saying rescan
maybe we can leave merging out of GDRO completely,
and just let the GDRO user do it on the update
hook.  We do need the update hook.

[144:

Sun Nov  7 16:32:34 2021 OK now we have

  /** return true to let wire propagate change into self */
  virtual Bool edge(Bool fromUp, Bool newState) { return true; }

in GDRO.

[145:

Sun Nov  7 16:56:27 2021 I wonder if we could
simplify the GDRO design a bit, somehow?
Particularly the iterator classid business -
that's kind of nasty (although it may be the
future). [146:

Sun Nov  7 16:57:42 2021 Could we not just pass an
iterator in, like

  Bool GDRO.updateGDRO(GDROIterator & itr) ..

?  And then tell caller to make whatever
GDROIterator subclass they want before calling us?
How can that be so bad?[147:

Sun Nov  7 16:59:49 2021 Seems like..  But, before
going after that, I have to say it feels like a
very long time since we committed any of this
stuff, and I'd like to commit some of this stuff,
since GDRO is kind of not sucking.

:147]

:146]

:145]
:144]

:143]
:142]
[148:

Mon Nov  8 01:05:28 2021 OK I'm trying to
consolidate all these L2Plate spike/demos here
into T2Demos/demos/L2Plate, and get some
confidence that we have the latest of all our
various hacks -- e.g., robustifications -- in one
place. 
[149:

Wed Nov 10 10:47:41 2021 OK, could I start
committing T2Demos/demos/L2Plate here?  I can't
swear it's got all the L2 robustifications but I'm
pretty clear it'll be the destination for them
all.
[150:

Wed Nov 10 10:49:59 2021 Actually, what's the
state of the T2Demos repo generally?  How much
Plate Related Material is already up there?

[151:

Wed Nov 10 10:53:36 2021 There's
T2Demos/demos/Plating committed, but its ./notes/
doesn't have any of our ./notes/ files:

202108201451-level-two-plate-notes.txt
202110180002-l2plate-robustness-notes.txt
202108270859-s11-rego-notes.txt

:151]

:150]
:149]
:148]
