quark QCtorArm : LX + SW3Cmdr + Fail {
  typedef Unsigned(1) LocalOp;
  constant LocalOp cLOP_EOP = 0u; //< End Of Program
  constant LocalOp cLOP_AEC = 1u; //< Cvt arm into ECs

  typedef Unsigned OpType;
  constant OpType cOPTY_SEG = 0u; //< Seg fault set nothing
  constant OpType cOPTY_LOC = 1u; //< Local operation set LocalOp
  constant OpType cOPTY_ARM = 2u; //< Arm operation set SW3Packet

  typedef Unsigned(8) ProgramCounter;

  ProgramCounter mPC = ProgramCounter.maxof;
  SW3Packet.SeqNo mSeqNo;

  //// QCTORARM API

  virtual Unsigned getCodeLength() ;

  virtual OpType getOp(ProgramCounter pc, SW3Packet & armop, LocalOp & localop) ;

  //// QCTORARM SERVICES
  
  Bool inStateRESET(ProcUnitInfo & pui) {
    return mPC == ProgramCounter.maxof;
  }

  Bool inStateEXIT(ProcUnitInfo & pui, Unsigned plen) {
    return mPC < ProgramCounter.maxof && mPC >= plen;
  }

  Bool inStateDISPATCH(SW3Packet & armdown, Unsigned plen) {
    return mPC < plen && mSeqNo.isEqual(armdown.mSeqNo);
  }

  Bool inStateBLOCK(SW3Packet & armdown, Unsigned plen) {
    return mPC < plen && mSeqNo.isGreater(armdown.mSeqNo);
  }

  Bool dispatchLocal(DiamondSequencerState & dss, ProcUnitInfo & pui, LocalOp lop, Unsigned plen) {
    EventWindow ew;
    print("LXCADL10");
    which (lop) {
    case cLOP_EOP: { // END OF PROGRAM FLAG
      print("LXCADL11");
      mPC = (ProgramCounter) plen;
      return true;
    }
    case cLOP_AEC: { // WHOLE ARM TO BECOME ECs
      print("LXCADL11E10");
      Int cmdstat = commandStatusInArm(pui);
      print("LXCADL11E10RET");
      print(cmdstat);
      if (cmdstat > 0) // command in progress in arm
        return false;
      if (cmdstat < 0) { // Arm is gone. Let's move on
        ++mPC;
        return true;
      }
      print("LXCADL11E11");
      Atom & a = ew[pui.mCodonSN];
      if (a as SwapWormHC3) {
        print("LXCADL11E12");
        if (inject(a, mSeqNo, SW3Packet.cSW3C_BECOME, EmptyCodon.classidof))
          return true;
      }
      print("LXCADL11E13");
      return false;
    }
    otherwise: { // ain't no other ops
      print("LXCADL12");
      Fail f;
      f.fail(__FILE__,__LINE__);
    }
    }
    return false;
  }

  Bool dispatchRemote(SwapWormHC3 & s3, SW3Packet p) {
    print("LXCADR10");
    print(p);
    if (inject(s3, mSeqNo, p.mCmd, p.mArg)) 
      return true;
    print("LXCADR12");
    return false;
  }

  /** \returns < 0 if there's no SW3 arm. \returns 0 if there is an
      arm and the current command is complete. Otherwise \returns > 0
      if the current command in the arm is still in progress */
  Int commandStatusInArm(ProcUnitInfo & pui) {
    EventWindow ew;
    SN swsn = pui.mCodonSN;
    print("ICCIA10");
    print(swsn);
    print(pui);
    if (!(ew[swsn] is SwapWormHC3)) return -1;
    print("ICCIA11");
    SwapWormHC3 & sw3 = (SwapWormHC3&) ew[swsn];
    SW3Packet dpkt = (SW3Packet) sw3.mDownSignal;
    if (mSeqNo.isEqual(dpkt.mSeqNo) &&
        dpkt.mCmdStatus != SW3Packet.cCMST_TRYING)
      return 0;
    print("ICCIA12");
    return 1;
  }

  //// LX API
  @Override
  virtual Bool perform(DiamondSequencerState & dss) {
    Fail f;
    print("LXCTA10");
    ProcUnit pu = cPUNIT_REG;
    ProcUnitInfo & pui = dss.getPUInfo(pu);
    EventWindow ew;
    Bool justReset = false;
    Unsigned plen = getCodeLength();

    if (inStateRESET(pui)) {
      //// STATE RESET

      if (killPU(pu,dss) && killPU(cPUNIT_INP,dss)) {
        if (pui.mEmptySN == SN.maxof) return true;
        SwapWormHC3 h;
        h.mPocketPtrs[cBODY_UP] = cPP_NULL;
        h.mPocketPtrs[cBODY_DOWN] = cPP_NULL;

        SW3Packet p3;           
        p3.mCmd = SW3Packet.cSW3C_NOOP; // Init to a NOOP cmd,
        p3.mArg = 0u;
        p3.mSeqNo = mSeqNo;             // matching our sequence,
        p3.mCmdStatus = SW3Packet.cCMST_DO;
        h.mUpSignal = p3;

        p3.mCmdStatus = SW3Packet.cCMST_DID; // that was just completed
        h.mDownSignal = p3;

        ew[pui.mEmptySN] = h.atomof;
        pui.mCodonSN = pui.mEmptySN; // there's a codon there now
        pui.mEmptySN = SN.maxof;     // and we just consumed the empty
        mPC = 0u;
        justReset = true;
        print("LXCTA1010JUSTRESET");
        
        // FALL THROUGH
      } else 
        return false;
    }

    print("LXCTA1011");
    if (inStateEXIT(pui,plen)) {
      //// STATE EXIT
      mPC = 0u;                 //XX we loop w/o reset if reexecuted?
      markCurrentInstructionForRotation(dss, 0u);
      return false;
    }

    // Check for local op
    SW3Packet armop;
    LocalOp localop;
    OpType opty = getOp(mPC, armop, localop);

    if (opty == cOPTY_SEG) {
      f.fail(__FILE__,__LINE__);
    }

    if (opty == cOPTY_LOC) {
      print("LXCTA1012LOCAL");
      return dispatchLocal(dss, pui, localop, plen);
    }

    if (opty != cOPTY_ARM)
      f.fail(__FILE__,__LINE__);

    // All other states must have SW3 arm

    print("LXCTA11");
    SN swsn = pui.mCodonSN;
    print(swsn);
    print(pui);
    if (!ew.isAccessible(swsn)) return false; //??
    print("LXCTA12");
    if (!(ew[swsn] is SwapWormHC3)) return false; //??
    SwapWormHC3 & sw3 = (SwapWormHC3&) ew[swsn];
    SW3Packet dpkt = (SW3Packet) sw3.mDownSignal;

    print("LXCTA13");

    //// CHECK COMMAND COMPLETION
    if (mSeqNo.isEqual(dpkt.mSeqNo)) {

      if (dpkt.mCmdStatus == SW3Packet.cCMST_TRYING) // blocking on command completion
        return false;

      if (dpkt.mCmdStatus != SW3Packet.cCMST_DID) {
        print("LXCTA13CHECK"); // Just shout it into the void, 'for now'?
        print(dpkt);
      }
      if (!justReset) {
        print("LXCTA13NOTJUST");
        mPC++; // HEAD FOR: mPC = next(p[mPC]);
        print(mPC);
      }
      // FALL THROUGH
    }
    
    if (inStateDISPATCH(dpkt,plen)) {
      //// STATE DISPATCH

      print("LXCTA14");      

      if (dispatchRemote(sw3, armop)) return true;

      print("DISPATCH FAILED");
      print(armop);
      return false;
    }

    if (inStateBLOCK(dpkt,plen)) { // blocking on command acknowledgment
      //// STATE BLOCK
      
      print("LXCTA15");      
      return false;
    }

    print("LXKIDI12");
    return false;
  }

  //// CODON API
  virtual Void init() {
    super.init();
    mDSType = cDS_NORM;
  }

}

/** \symbol CA
    \color #60f
 */
element LXCtorArm : QCtorArm {

  //// QCTORARM API
  @Override
  virtual Unsigned getCodeLength() {
    return mProgram.lengthof;
  }

  @Override
  virtual OpType getOp(ProgramCounter pc, SW3Packet & armop, LocalOp & localop) {
    if (pc >= mProgram.lengthof) return cOPTY_SEG;

    ASCII b = mProgram[pc];
    
    if (b == '.') { localop = cLOP_EOP; return cOPTY_LOC; }
    if (b == 'E') { localop = cLOP_AEC; return cOPTY_LOC; }

    if (op(b, armop)) return cOPTY_ARM;

    fail(__FILE__,__LINE__);
    return cOPTY_SEG; // NOT REACHED
  }
  
  String mProgram;

  Bool op(ASCII code, SW3Packet & p) {
    which (code) {
    case 'n': { p.mCmd = SW3Packet.cSW3C_GROW; p.mArg = (SW3Packet.Arg) (1u<<cPP_NORTH); }
    case 's': { p.mCmd = SW3Packet.cSW3C_GROW; p.mArg = (SW3Packet.Arg) (1u<<cPP_SOUTH); }
    case 'e': { p.mCmd = SW3Packet.cSW3C_GROW; p.mArg = (SW3Packet.Arg) (1u<<cPP_EAST); }
    case 'w': { p.mCmd = SW3Packet.cSW3C_GROW; p.mArg = (SW3Packet.Arg) (1u<<cPP_WEST); }
    case '-': { p.mCmd = SW3Packet.cSW3C_SHRINK; }
    case 'W': { p.mCmd = SW3Packet.cSW3C_PLACE; p.mArg = Wall.classidof; }
    case 'X': { p.mCmd = SW3Packet.cSW3C_DELATM; p.mArg = Wall.classidof; }
    case 'D': { p.mCmd = SW3Packet.cSW3C_DIEPL; p.mArg = Wall.classidof; }
    case 'E': { p.mCmd = SW3Packet.cSW3C_BECOME; p.mArg = EmptyCodon.classidof; }
    case 'S': { p.mCmd = SW3Packet.cSW3C_HC3CTL; p.mArg = (SW3Packet.Arg) ((1u<<2u)|cQUAD_SW); /* SW corner to _MAKEDS*/ }
    case 'H': { p.mCmd = SW3Packet.cSW3C_HC3CTL; p.mArg = (SW3Packet.Arg) ((0u<<2u)|cQUAD_SW); /* SW corner to _MAKEHG*/ }
    otherwise: { return false; }
    }
    return true;
  }

}
