{246}  -*-  mode: text; fill-column: 50;  -*-
[0:

Mon Oct 18 00:02:48 2021 So I've been blasting
basic L2Plates (around MyElement) with x-rays just
to see what happens.

From the basic 3x3 L2 plates, I got a 7x3 L2Plate
to grow out the side -- but it was properly
registered to the 3x3 so it amounted to a
legitimate containing plate for the 3x3.

With some further blasting, though, I got to an
L2Plate that claims it's [3,3] on the west but
[7,3] on the east.
[1:

Mon Oct 18 00:12:18 2021 And there's two spots on
the L2 border where the inconsistent
mL2Info.mSizeOfPlate.x values are in adjacent
L2Plate atoms, but the L2Plate code doesn't detect
that.

[2:

Mon Oct 18 00:13:52 2021 Can we go ahead and fix
that?
[3:

Mon Oct 18 00:15:15 2021 Do we not already have a
place to check explicitly for L2 inconsistencies?
Plate.mustBlockOrDie only deals with L1 stuff.
[4:

Mon Oct 18 12:45:45 2021 Yes, we already have
'virtual Bool Plate.fatalInconsistency()', and we
also had 'L2Plate.fatalInconsistency()' already,
so we added a Moore ngb inconsistency check,
wherein if we're on the same L1 plate, then our L2
plate size and position should be the same.
[6:

Mon Oct 18 12:57:46 2021 And that seemed to work
okay.  Now the 'failures' I'm seeing are more
arguable.  For example, I've got some L1 plates
that

(1) got into a nested L1 relationship that jointly
    filled their L2 plate, but
(2) when the L2 plate reseeded its neighbor L2, it
    (naturally) copied the single side-central L1
    atom nearest it, which
(3) recreated the L1 nested plate but not the L1
    plate that had subsumed it.

And I really don't see any easy way to argue about
that, given our current assumptions.  So this
state I'm currently looking at is 'legitimate',
even though it's not the state we first grew.[7:

Mon Oct 18 13:03:03 2021 But ha!  I did some xray
surgery on it and cut out the bad parts, and now
we're all fixed up again!

Let's keep blasting and look for more
  failures..[8:

Mon Oct 18 13:04:53 2021 OK well there's this:

    20211018130447-561651: 24799AEPS [C8CA5127]MSG: T[1,0]@S[13,23]: behave() failed at ../../../src/core/include/UlamRef.tcc:387: INCONSISTENT_ATOM (site type 0x03E0)
    20211018130447-561652: 24799AEPS [C8CA5127]MSG: BACKTRACE  ->  0: MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::LookupUlamElementTypeFromAtom() const + 0x2BE
     ->  1: MFM::Uq_10105Plate10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_9214mustBlockOrDie(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0xBC2
     ->  2: MFM::Ue_102717L2Plate10<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Uf_6behave(MFM::UlamContext<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> > const&, MFM::UlamRef<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) + 0x14D
     ->  3: MFM::UlamElement<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >::Behavior(MFM::EventWindow<MFM::EventConfig<MFM::Site<MFM::P3AtomConfig>, 4> >&) const + 0x1E1

leading to

    Failure reached top-level! Aborting
    Makefile:32: recipe for target 'run' failed
    make: *** [run] Error 134

    Compilation exited abnormally with code 2 at Mon Oct 18 13:04:47

and we're wondering (once again) how that
happens.  The entire behave() call should be
wrapped in an unwind_protect, right??

[9:

Mon Oct 18 13:14:06 2021 Well, but there's also a
whole bunch of really-REALLY-similar stack traces
immediately before that one, and they don't lead
to the engine shutting down, so we're thinking
maybe the failure in behave() IS caught, and we're
dealing with something else.

Let's rebuild mfms with debugging and see if we
can catch something in the act of dying.

[10:

Tue Oct 19 12:03:27 2021 OK, have tried a bunch of
xraying and what not but so far haven't caught a
fails-to-top occurrence..

:10]
:9]


:8]

:7]

:6]

[5:

Mon Oct 18 12:55:38 2021 (Now running a script to
do a screen shot once per minute at the top of the
minute, to gather up possible 'visual aids' for
next t2sup.  I would like to get our own viz
working again by the next livestream.  But I would
like a lot of things.)

:5]
:4]

:3]
:2]

:1]

:0]
[11:

Wed Oct 20 10:11:34 2021 OK, so we punched up the
MFM codebase a little, to catch failures durihg
painting by setting up an unwind_protect at the
(new) RootPanel level of painting.[12:

Wed Oct 20 10:27:31 2021 Actually, it appears we
already had an unwind_protect in
TileRenderer::PaintTileAtDit, and that was what
was catching our simple deliberate
MyElement.getColor failure.

The actual crash we were struggling to reproduce
must've come outside the actual painting of the
tiles -- like, during the painting of the tool
palette, perhaps.

Hmm maybe I should have left the tool palette
posted during the background write failures
test..

:12]

:11]
[13:

Wed Oct 20 23:48:59 2021 So it looks like a pretty
common failure, now, is ending up with an L1 plate
that is only incompletely surrounded by L2 plate,
which means the L2 border is incomplete and so the
L2 plate can no longer repair in the direction(s)
lacking a border.[14:

Wed Oct 20 23:52:21 2021 In the current case, for
example, the L2 plate is [4,4] while the L1 plate
is [3,3].

So that's another possible consistency check.
It's an inter-L1/L2 consistency check.
[23:

Thu Oct 21 01:19:47 2021 So, could we do that
check?  Where does it happen?[24:

Thu Oct 21 01:20:27 2021
L2Plate.fatalInconsistency, I guess.  If ngb 'a'
is cCONTAINED_BY self, then we ought to have
self.sizeOfPlate == a.sizeOfPlate+(2,2) and
self.positionOnPlate == a.positionOnPlate.. what?
Have to redo the relationTo computation?

Maybe just check the sizes..  With the argument
that the positions have already been checked -- to
some degree anyway -- during
PlateUtils.relationTo.

Let's try it, anyway.[25:

Thu Oct 21 01:27:54 2021 But hmm, do we really
want to insist on L2Plate size == L1Plate.size +
(2,2)?  That would rule out nested structure among
the L1Plate that the L2Plate is surrounding.

Now, on the one hand, failures involving
unintentional creation of nested L1 plates are one
of the remaining 'germline corruptions' that we
are dealing with.

Insisting that L2.size == L1.size + (2,2) would
make those failures unstable.  But it also means
that we couldn't have L1 plate growing inside an
L2Plate, let alone more complex nested L1
structures.

I think, maybe, let's be weaker for now, and just
say L2.size >= L1.size + (2,2).. and see what we
think about that.
[26:

Thu Oct 21 01:37:56 2021 Well, if what we want to
establish is that the L2Plate has a complete
border, just checking relative sizes doesn't
really do it.  We want sort 'strictly contained'
vs 'contained or even with'.  'Bordered by' rather
than just 'contained by'.  Does PlateUtils already
have something that would help with that?[27:

Thu Oct 21 01:45:20 2021 Well, not super
obviously.  We want

 - a.pos.x > 0, and
 - a.pos.y > 0, and
 - self.size.contains(a.size+a.pos)

Does that do it?[31:

Thu Oct 21 01:55:10 2021 I guess the idea is:
assuming we know a is cCONTAINED_BY self, then
those conditions give us self 'borders' a or
something.

:31][30:

Thu Oct 21 01:53:38 2021 OK, back here.  (This
once-a-minute auto-screenshotting eats up a ton of
space over the days!)[32:

Thu Oct 21 02:22:18 2021 And hmm also: Leaving
audacity recording for 11+ hours will eat up some
space toooooo.

:32]

:30]

:27]

:26]
:25]

:24]

:23]
:14]

:13]
[15:

Thu Oct 21 00:44:31 2021 Ooh we finally caught a
non-tile-painting atom access failure -- under
AtomViewPanel::PaintComponent.  Oh!  That makes
sense: Of course an AVP accesses the atom that
it's pointing at, both to get its color and to
examine its guts.  So if an atom goes crazy under
an AVP, failures are absolutely expected.

So okay: There's reason to have both per-tile and
RootPanel unwind_protects.  So be it.[16:

Thu Oct 21 00:49:38 2021 Ooh and we can even take
a picture of what it looks like..[17:

Thu Oct 21 00:50:32 2021 Buuuuut, umm, the display
is no longer redrawing at all? Even though we're
still getting event-related logging?

Beeeeecause we dropped the display thread when we
unwound back to the top? Or something?[18:

Thu Oct 21 00:52:06 2021 Well, not clear: We just
hit the 'failed to root panel' again (even though
nothing is updating on screen..)[19:

Thu Oct 21 00:53:06 2021 Hmm, once I started
interacting with the UI it started redisplaying
again.. Although it also appears we got rid of the
inconsistent atom under the AVP as well, so we're
not sure what's responsible for the drawing
starting to succeed again..[20:

Thu Oct 21 01:08:44 2021 Now we're save/restoring
the drawing rect and the bg/fg colors; let's see
if that improves the post-fail-to-RootPanel
graphics behavior.  It really might: It seems like
it took a window resizing to get things drawing
again. [21:

Thu Oct 21 01:10:43 2021 OK, we forced one
fail-to-rootpanel with xrays, and it recovered
after we continued..[22:

Thu Oct 21 01:11:22 2021 And there were several
more, and the subsequent drawing appeared to
survive..

:22]

:21]

:20]

:19]

:18]

:17]

:16]

:15]
[28:

Thu Oct 21 01:47:27 2021 Whups hey we just got an
actual fail-all-the-way-to-top!  How did that
happen?? [29:

Thu Oct 21 01:48:16 2021 Oh: Ran out of disk
space!  Not that exciting!

:29]

:28]
[33:

Thu Oct 21 09:54:00 2021 Well, so the overnight
run with the extra L2/L1 enforced border
consistency check seems to've helped things out
rather a lot.. We're still at 3x3 for each of our
four test L2Plates, and each 3x3 still looks
legit.

Did see some overextended 'L2 blues' in a couple
cases, but they both seemed to clean themselves up
after not too long.

So!  (And that stuff's all been committed and
pushed..)

So it's time to head forwards perhaps..?

We'd claimed we wanted to take another run at
L2Plate moving.. Could we think of a few steps
that could head us in that direction?

[34:

Thu Oct 21 09:58:04 2021

 - Review L2PlateSequencer status

 - Demonstrate some whole L2Plate sync mechanism

[35:

Thu Oct 21 09:59:22 2021 And I'm thinking we'll
fall back to a hard-coded -- or at least
compiled-in -- mechanism for deciding where the
L2Plate 'commander' is?

[36:

Thu Oct 21 10:18:28 2021 So right now, it appears
that L2PlateSequencer has nothing directly about
interacting with other L2PlateSequencers, whether
on a single L2Plate or between them.

(We need clearer language for talking about a
'single L2Plate' vs a 'whole L2Plate'.  Right now
it's pretty unclear.)

[37:

Thu Oct 21 10:25:59 2021 So, how do we make
L2PlateSequencer command and control any fraction
as robust as the underlying L2plate currently is?

I'm thinking:

 - Hardcode leader, mL2Info.mPosOnPlate == (0,0)

 - Generate a random tag when leader inits, have
   non-leaders always accept seqno/state when
   leader tag changes.
[41: Fri Oct 22 09:12:38 2021

 - Demonstrate communication between L2PSEQ of
   different L2 sites.

:41]
:37]

:36]

:35]

:34]

:33]
[38:

Thu Oct 21 12:46:40 2021 Quite the battle going on
in the central 'M2'-based L2Plate, between an
upper section that thinks it's on row 2, and a
lower section that thinks it's on row 0.

Not clear how it turns out but drives home that
we're still missing consistency checks between
L2Plates.[39:

Thu Oct 21 13:35:39 2021 Ooh, kind of looks like
it's resolved itself back to the original
position.


:39]

I guess perhaps we could say 'L2 site' vs 'L2
Plate', with an L2 site being a single L2Plate
with a surrounding L2 border.  And an L2 plate
being a grid of L2 sites, sized by their L2 info.

:38]
[40:

Thu Oct 21 13:38:31 2021 OK, so all this
background stress testing has been fun, and
useful.

Now it's time to move the flag.

:40]
[42:

Fri Oct 22 09:38:47 2021 So let's review the Plex
situation: What can we do and what are we missing?

 - Define 'arbitrary' transient (L2PlateSequencer)

 - Define Plex subclass to gather and scatter (and
   optionally render) that transient (L2SeqPlex)

 - Have currently BUSTED AND UNUSED attempts to
   let Plex subclasses render themselves spatially
   (as well as via (extended) AtomViewPanel, which
   do kind of work).[43:

Fri Oct 22 09:54:26 2021 Plex.renderPlex gets
called thusly:

  AtomViewPanel::PaintComponent ->
    Plexer.printPlex() ->
      Plexer.printPlexDefault() ->
        Plex.renderPlex(Drawable&) ->
          L2PlateSequencer.renderPlex(Drawable&)

[44:

Fri Oct 22 10:30:40 2021 And L2PS.renderPlex does
do some drawing at locations that are at least
plausible for landing on top of the gathered L1
sites..

EXCEPT the current transform and clip rectangle is
set for the AVP, not the grid.  So the drawn stuff
ends up inside of (and relative to) the AVP, or
clipped by its edges.

And it's really not clear how to avoid that, given
where we are in the drawing hierarchy.  Even if we
change the transform/clip to the grid panel, we've
already cleared the rect holding the AVP.

We'd have, somehow, to arrange to call renderPlex
during the grid rendering, not during AVP
rendering.[45:

Fri Oct 22 11:00:58 2021 Which would probably mean
we should split printPlex() and renderPlex() into
completely separate API accesses..

How hard would it be to call renderPlex from
TileRenderer (assuming that's where it would
be)?[46:

Fri Oct 22 11:06:30 2021 Two obvious
possibilities.  In TileRenderer::PaintTileAtDit,
we call PaintCustom(..) if m_drawCustom, and
we call PaintOverlays(..) unconditionally.

PaintCustom eventually dishes to
CallRenderGraphics, which calls
UrSelf.renderGraphics() .. Could we just use that
instead of renderPlex at all?[47:

Fri Oct 22 11:40:29 2021 But the question is: Who
calls Plex.open(false), before anyone could call
UrSelf.renderGraphics() on it?  I guess it would
be something like

..Plexer..

    Void renderGraphics() {
      super.renderGraphics(); // Draw on top of any other rendering?
      renderGraphicsDefault();
    }

    Void renderGraphicsDefault() {
        Plexer.ClassId classid = self.getPlex();
        ClassUtils cu;
        if (!cu.isBase(classid,Plex.classidof)) return super;

        typedef BitStorageT(8192) BitStorage8K;
        BitStorage8K bs;

        Plex & plex = (Plex &) bs.recast(classid, true);
        if (!plex.open(false)) return;
        UrSelf & urs = plex.get();

        urs.renderGraphics();
    }

[48:

Fri Oct 22 15:44:26 2021 OK, so took a crack at
that and there's just on teensy little problem:
There's no event window during site painting, so
all attempts to gather the plex fail with

    Render failed: UNSUPPORTED_OPERATION (../../../src/core/include/UlamContextRestricted.h:57)

which is pointing at 'GetEventWindow()'

So what do we do about that?  We explicitly gave
an ew to AVP[49:

Sat Oct 23 00:21:47 2021 ..so we do the same here?
We say that having an UNCOMMITABLE event window is
no problem, and rendering code can even write to
it if it wants, but the window won't be written
back to the tile no matter what.

We could insist on relatively undefined behavior
perhaps -- that writes to the ew may or may not be
visible even during while the renderGraphics() (or
whatever) code is running.  Writes might:

(1) Be utterly ignored -- re-read sees original
(2) Fail (waah-ha, so don't do it)
(3) Apparently succeed but never commit

It would be best to make it (2) -- so people don't
get any ideas -- but that also seems the hardest
to implement from where the code stands now?

[50:

Sat Oct 23 00:27:27 2021 There's also possible
leakage via random number consumption.. Is it
worth still NOT presenting access to the RNG even
when granting (read only) access to the whole ew?
Or having a whole separate RNG to use only during
renderGraphics calls?[51:

Sat Oct 23 00:54:22 2021 Well, let's just carry
whatever AVP does during PaintComponent and see
how bad it looks in TileRenderer.

:51]

:50]
:49]

:48]

:47]

:46]

:45]


:44]

:43]

:42]
[52:

Sat Oct 23 09:08:01 2021 Hmm long run seems to
show our PlateUtils.strictlyContains method is
buggy.  It's not flagging any of:

container (5,1)[6,9]  (4,0)[6,9]  (0,0)[6,9]
containee (4,0)[5,7]  (4,0)[5,7]  (0,0)[5,7]

as violations even though there's no west border
on the resulting L2Plate.  Why not?
[54:

Sat Oct 23 09:23:40 2021 Or actually maybe the
deeper errors are a missing eastern border, as in

container (1,0)[6,9]  (5,0)[6,9]  (0,6)[6,9]
containee (0,0)[5,7]  (4,0)[5,7]  (0,5)[5,7]

[55:

Sat Oct 23 09:26:38 2021 Actually it's looking
like both (missing west or east border) are
stable..

:55]

:54]
[53:

Sat Oct 23 09:14:16 2021 Perhaps because rel is
not coming back cCONTAINS_PLATE?  (In which case
strictlyContains won't even be called.)
[56:

Sat Oct 23 09:27:20 2021 Let's follow say

container (1,0)[6,9]
containee (0,0)[5,7]

this one through relationTo.

Let's say ewoffsetl is (0,0), and ewoffsetr is
(0,1).  If they're not, we're fogged.

so we're saying we've got:
relationTo(pl=(1,0)[6,9], ewoffsetl=(0,0),
           pr=(0,0)[5,7], ewoffsetr=(0,1))

L2Plate is Stride1x1FP, and MyElement is B2DPlate4
which is B2DTPlate(4) which is Plate which
defaults to stride {1,1} and phase (0,0), so
stride and phase should match.

Let's pretend inStride(..) returns true too,
although we haven't gone through it.

Except we need the pcdiff that it computes..

Sigh.  So it's like

  inStride(ew1=(0,0), ew2=(0,1), str={1,1}, pcdiff)

so
ewdiff = (0,-1)  and
pcdf = (0,-1)    and
ret = true       and
pcdiff = (0,-1)

So.. back out in relationTo, we get

tbl((6,9), -(1,0))
tbr((5,7), -(0,0) + (0,-1))

so
tbl((6,9), (-1,0))  ->  tbl(mMin = (-1,0), mMax = (-1,0)+(6,9)+(-1,-1))
tbr((5,7), (0,-1))  ->  tbr(mMin = (0,-1), mMax = (0,-1)+(5,7)+(-1,-1)

or

tbl((6,9), (-1,0))  ->  tbl(mMin = (-1,0), mMax = (-2,-1)+(6,9))
tbr((5,7), (0,-1))  ->  tbr(mMin = (0,-1), mMax = (-1,-2)+(5,7))

tbl((6,9), (-1,0))  ->  tbl(mMin = (-1,0), mMax = (4,8))
tbr((5,7), (0,-1))  ->  tbr(mMin = (0,-1), mMax = (4,5))

which are different so we don't return cSAME_PLATE_AS..

so
inter = tbl.intersectionWith(tbr)

 =
[57:

Sat Oct 23 10:58:52 2021 Ah, I see a problem.  The
ngb loop in L2Plate.fatalInconsistency is using

 if (a as Self) ..

so it's only considering other L2Plates.
[58:

Sat Oct 23 11:31:33 2021 So it does seem like
pu.strictlyContains has some issues.  Going to
need to go through that closer, but not right
now.. [59:

Sat Oct 23 13:48:46 2021 In particular, it seems
we have to know the C2D offset between container
and containee or the strictlyContains answer isn't
even well-defined.

    (0,0)   (1,0)   (2,0)        (5,0)
    [6,9]   [6,9]   [6,9]  ..    [6,9]

    (0,1)   (0,0)   (1,0)  ..    (4,0)
    [6,9]   [5,7]   [5,7]        [5,7]

so I guess we want to (re)compute the tboxes and
ask strictlyContains on them..



:59]

:58]
:57]
:56]

:53]

:52]
[60:

Sun Oct 24 02:57:46 2021 Going to let the current
quadratic-time movie run a few hours longer --
because the L2Plates are still holding up great so
far despite write faults -- but I think a next
stop would be to rewrite L2PlateSequencer to focus
on inter-L2 site synchronization rather than local
spatial sensing.

I'd like to see a 'full' (3x3) L2 plate doing
tick-tock synchronization across the whole plate,
and then perpetually falling towards that sync
when write faults disrupt L2 sites.

:60]
[61:

Sun Oct 24 09:23:53 2021 So if we do a new
L2PlateSeq, what do we put in?

[62:

Sun Oct 24 10:39:37 2021

 - RPS for sync

 - QStream around the L2 site border

 - QStream between L2 sites?

[63:

Sun Oct 24 10:51:06 2021 It raises the general
question of stream vs state. In the 'standard' RPS
approach we can directly inspect our up- and
downstream neighbors to assess their current
state.

If we're 'just' sending packets around the L2 site
border, we have to remember the last upstream and
downstream packets we saw.  And where do we decide
that ALL our our downstreams have reached some
state?

And how do we allow rebuilt L2 sites to rejoin the
sync in some coherent way?

Suppose we propagated state on all L2 site
borders, and forget about QStream for now.

Suppose we have newly-seeded L2Plate come up in
a fourth color GREY, instead of any of RGB.[64:

Sun Oct 24 14:46:52 2021 OK, so which is it: Do we
try to communicate RPS state via QStream packets,
or rejigger the definition of L2Plate itself?

How could it go, just at the L2 site level, to
coorindate RPS info via packet?

Suppose we circulated a packet saying "Here's what
we believe are the current upstream and the
current downstream colors. If you see something
that falsifies this, update it as it passes."

I guess maybe it says "Here's OUR current color,
AND what we believe are upstream and downstream",
and sides can update the upstream and downstream
based on their observations, but only North (say)
can change the OUR color.[65:

Sun Oct 24 16:14:04 2021 Well I think it's clearly
too late to be trying to get any packet stuff
going for #3110.  We never got it going at L2
before and now whatever we've done is swapped and
obfuscatory at best.

We might be able to rejigger the definition of
L2Plate itself.

We should probably move on to s12-L2Plate before
we try though..
[66:

Sun Oct 24 16:18:40 2021 Aaaand here we are in
s13..

Let's ditch the abortive L2PlateSequencer11 before
it confuses us more..[67:

Sun Oct 24 16:20:27 2021 Done.

:67]

:66]
:65]

:64]

:63]

:62]

:61]
[68:

Sun Oct 24 16:43:29 2021 So the current bit budget
of L2Plate is:

  /*__________________________________________________
  | COMPONENTS of L2Plate <32> (71 bits/0 unused):
  |
  | Pos	| Bits	| Name	| Type <classid>
  | 0	| 18	| mL2Info	| B2DPlate4 <60>
  | 18	| 0	| super	| L2PlateBase <56>
  | 18	| 25	| base	| PayloadT(24) <46>
  | 43	| 0	| base	| Plexer <57>
  | 43	| 0	| base	| UrSelf <0>
  | 43	| 0	| base	| B2DStreamPlateBase <34>
  | 43	| 0	| base	| B2DStreamPlate6 <48>
  | 43	| 0	| base	| B2DStreamPlateT(6) <39>
  | 43	| 0	| base	| Stride1x1FP <53>
  | 43	| 0	| base	| B2DPlateBase <65>
  | 43	| 26	| base	| B2DTPlate(6) <43>
  | 69	| 0	| base	| Plate <35>
  | 69	| 2	| base	| QStream12 <36>
  | 71	| 0	| base	| Payload <37>
  |___________________________________________________
  */ //gcnl:NodeBlockClass.cpp:2644

and I'm thinking we should just steal a few bits
from PayloadT(24) to get ourselves some RPS room.

Let's go for PayloadT(20u).  Let's also find some
RPS code to model after.

:68]
[69:

Mon Oct 25 00:49:16 2021 OK, so quark RGBSync with
element RGBSyncDemo is working enough that I'm
starting to look at robustness issues.  And sure
enough it's easy to get local RGB lockups when
there's background write faults erasing atoms and
such.

Thinking about ways to respond. Of course we could
kill the whole sync domain, but we'd like to
explore the behavior of more local strategies.

What if we said this:

  If you can see more than two states among
  neighbors, go to cINIT_STATE

? Idea is that a RGB lockup will go to
two-state+cINIT_STATE, and the cINIT_STATE will
then spread along the 'fault line' between the two
states -- but it won't push into solid regions.

Let's Try It!
[75:

Mon Oct 25 11:17:53 2021 OK so 'seeing more than
two states' (including self) obviously doesn't
work because it happens regularly, with one color
downstream and another upstream.

Is the trapping state having two non-self colors
both upstream or both downstream? And should we be
assigning cINIT_STATE to the whole ngb, not just
self? [76:

Mon Oct 25 11:59:22 2021 Well, it looks like at
least the nuke-whole-neighborhood sync repair
mechanism is kind of working.  Kind of wow!

:76]

:75]
[70:

Mon Oct 25 01:05:29 2021 Well, our current
RGBSync.findNgb API is a real disaster for
answering the 'census' question, so I think we
need to refactor real quick.

We want an iterator over RGBSync, I guess. Plus some
way to tell if one RGBSync is upstream,
downstream, or neither, with respect to another.

[71:

Mon Oct 25 01:13:02 2021 Aand where do we put the
custom RGBSyncIterator iteration state, in this
no-malloc world?  We can't have to foggen recast
for it do we?

Could we basically implement malloc using recast,
if we wanted to, BTW?  Anyway.

[72:

Mon Oct 25 01:16:55 2021 Or we hardcode to SNs?
Was hoping to avoid that at the RGBSync level.

Or we could just try to provide a palette of
useful state in a transient, and let subclasses
decide how to use it:

    transient RGBSyncIterator {
      C2D mFirstC2D, mLastC2D, mNextC2D;
      SN mFirstSN, mNextSN, mLastSN;

      //// RGBSyncIterator API
      virtual Void init() ;
      virtual Bool hasNext() ;
      virtual RGBSync & next() ;
    }

plus like maybe

   typedef Int(2) SyncRelation;
   SyncRelation cOTHER_IS_UPSTREAM = 1;
   SyncRelation cOTHER_IS_DOWNSTREAM = -1;
   SyncRelation cOTHER_IS_UNRELATED = 0;
   virtual Relation syncRelation(RGBSync & other) ;

[73:

Mon Oct 25 01:54:57 2021 Ugh stalled trying to
convince myself to implement that.

Go the other way? Pass a visitor to the sub and
let it iterate however it likes?

But how does the visitor store hits?  That pushes
us back to SNs.
[74:

Mon Oct 25 02:11:22 2021 What about maybe yes
using a BitStorage?  In for a penny?  Subclass
offers a classid for an iterator, RGBSync recasts
one and starts using it.

:74]
:73]
:72]

:71]

:70]

:69]
[77:

Mon Oct 25 12:02:28 2021 Overdue to announce
tomorrow's livestream.  But want a little more
confirmation on the self-stabilizing-rgbsync
though.  Let's just make the demo cell bigger..
[78:

Mon Oct 25 12:32:30 2021 RGBSyncDemo[11,9] looks
pretty good!  Can see some vicious fights with
inconsistent states gradually get ironed out.
Although the whole thing blows itself up pretty
often too -- because it doesn't have L2 site
respawning.

Let's announce the livestream, then try to carry
RGBSync over into L2Plate![79:

Mon Oct 25 12:44:37 2021 OK, livestream
scheduled.  Now L2Plate.[80:

Mon Oct 25 12:47:26 2021 OK, so we need an
RGBSyncIterator designed for L2Plate.  Could we do
like Moore neighborhood plus the four corners of
the ew?[81:

Mon Oct 25 14:49:39 2021 Made some progress which
revealed a thinko: Need to check two sides when
we're in an L2 site corner, not just one, so we
have to rework the iterator again.

I guess just check all four directions, searching
for L2 cSAME_PLATE_AS but l2posl != l2posr?

:81]

:80]

:79]

:78]

:77]
[82:

Wed Oct 27 06:48:58 2021 OK so we got through
t2sup#3110, though not without some tech foggups.

We got the L2PlateRGBSyncIterator visiting the
Moore ngb sites that are in same L2 site, and the
distance 3 orthogonals that are in different L2
sites.  Which seems to make some weird kind of
sense.  Maybe.

In any case, we're thinking about reworking the
whole thing around four states rather than
three. A cYELLOW_STATE to lead green rising up
over red, analogous to the current cBLUE_STATE
that leads red falling down over green.

But I guess I don't have much clarity about the
idea really.

[83:

Wed Oct 27 07:00:45 2021 It's supposed to make it
clearer how to make things better from a standing
start.  And how would that work?

ATTRACTOR DYNAMICS
 CURME  ALLUP ALLDOWN NEWME
   R             Y     Y     R trailing edge / Y leading edge (up)
   Y     Y             G     Y trailing edge / G leading edge (up)
   G     B             B     G trailing edge / B leading edge (down)
   B     R             R     B trailing edge / R leading edge (down)

SYMMETRIC STABILIZATION DYNAMICS
 CURME  ANYUP ANYDOWN ACTION
   R     !R            SWAP  R diffuse up
   G            !G     SWAP  G diffuse down
   B     G       R     SWAP  B diffuse center
   Y     G       R     SWAP  Y diffuse center

SYMMETRY BREAKING DYNAMICS
 CURME  ANYNGB NEWME
   B     Y      Y    Break ties upward

[85:

Thu Oct 28 14:08:35 2021 Well, maybe that's even
kind of plausible. Time to implement it, I
think.[86:

Thu Oct 28 14:30:02 2021 OK, so we're going to:

 - Out with cINIT_STATE in with cYELLOW_STATE

 - Init to cRED_STATE I guess

:86]

:85]
:83]
:82]
[84:

Thu Oct 28 00:00:26 2021 Feeling a little flu-ey
11 hours after Moderna booster.  Again (still)
working on the :83: transition table above.
Getting Y in there.

:84]
[87:

Fri Oct 29 02:31:18 2021 OK have hacked a bunch
towards implementing the re-re-revised :83: rules
above, and now wondering: Do we need 'symmetric
stabilization' rules for B and Y?  It seems like
'just' an efficiency thing since the R and G rules
-- with their 'wildcard' anyup and anydown
matching -- will migrate B and Y toward 'the
center' anyway.  And the logic for the B and Y
rules is used only that once..  Let's ditch that
and go with just this:

SYMMETRIC STABILIZATION DYNAMICS
 CURME  ANYUP ANYDOWN ACTION
   R     !R            SWAP  R diffuse up
   G            !G     SWAP  G diffuse down

for the basic repair case..
[88:

Fri Oct 29 02:40:23 2021 Although now that I think
about it, it seems like we're maybe still risking
deadlock: Suppose we have loose B and Y both
floating around.  They'll get pushed below R and
above G, but there's nothing that lets B and Y
diffuse laterally along the R-G interface, so how
will B and Y find each other to invoke the
symmetry breaking rule?

Could we have the main special case be whenever R
encounters G?  Since it won't in the attractor
dynamics.

What if it was that if R sees G anywhere in the
neighborhood, it turns Y, and the same for G
seeing R.  So the asymmetric dynamics is both
sides turn yellow, and therefore (?) a yellow
boundary layer will form to separate the R and G,
and that Y layer *will* eventually encounter any B
that are also separating R and Gs.

Seems plausible.

Seems, actually that we should maybe want to break
symmetry toward B rather than Y, so muddled cases
will tend to clean up heading down -- argument
being that we'd rather see too few apparent round
trips at the upstream root, rather than too many.

[89:

Fri Oct 29 02:49:57 2021 Now, all this is
completely untested (mostly unimplemented), and I
could believe we're missing a lot of state space
-- there's lots of cases that aren't ALLUP/ALLDOWN
or ANYUP/ANYDOWN -- so deadlocks will remain
possible.  Or are there?  Man I am still fuzzy
fuzzy here.  We're not covering NONEUP/NONEDOWN, I
guess, so that's the potential missing space.

Taking a break though.  Fuzzed out; still body
aches and such.[90:

Fri Oct 29 10:48:52 2021 (Had a bunch of camera
stuff here that I moved to
/data/ackley/AV/FUJIFILM-X-T4/notes/202110291002-notes.txt
)

:90]

:89]

:88]
:87]
[91:

Thu Nov  4 11:44:37 2021 OK well after being off
for a couple days dealing with t2tile.com and the
first X-T4 timelapse, I got back to the WIP and
just now got the code roughly all filled in.

Things are deadlocking with various combinations
of Y and G next to each other, and a couple R in
upper left corners. What's supposed to be
happening there?

[92:

Thu Nov  4 11:49:17 2021 Well it appears I didn't
even try to implement the last two rows of
SYMMETRIC STABILIZATION DYNAMICS, :83: above, but
I did try to implement this part:

 CURME  ANYUP ANYDOWN ACTION
   G            !G     SWAP  G diffuse down

which doesn't appear to be working in the current
case. So let's look at that.

:92]

:91]
[93:

Thu Nov  4 12:10:02 2021 OK, so this rule:

    ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       Y     Y             G     Y trailing edge / G leading edge (up)

seems too loose: We've got Y -> G happening when
there's still !G (specifically Y) downstream.
Should it be ALLUP==Y and ALLDOWN==G? If so
shouldn't other rules change too?

[94:

Thu Nov  4 12:18:50 2021 So we're switching to
this:

    ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       R     R       Y     Y     R trailing edge / Y leading edge (up)
       Y     Y       G     G     Y trailing edge / G leading edge (up)
       G     B       G     B     G trailing edge / B leading edge (down)
       B     R       B     R     B trailing edge / R leading edge (down)

[95:

Thu Nov  4 12:22:17 2021 OK now we're deadlocked
by a Y surrounded by R -- what did we want to
happen there?

Well, at least, we'd expect

    SYMMETRIC STABILIZATION DYNAMICS
     CURME  ANYUP ANYDOWN ACTION
       R     !R            SWAP  R diffuse up

to fire on a downstream R. Why isn't that
happening? [96:

Thu Nov  4 12:26:00 2021 Well, we're still getting
SWAPPO on RGBSyncDemo's that are both R, which
seems to suggest a rule problem somewhere..
[97:

Thu Nov  4 12:40:32 2021 OK, bug in
sampleIsntInDir. Getting close to time to move the
flag here, but going again.
[98:

Thu Nov  4 12:42:21 2021 And boom! Looks like
we're working (error free) in both RGBSyncDemo and
L2Plate![99:

Thu Nov  4 12:46:12 2021 OK, I started in with the
write faults and we still have at least one
deadlock.

What should G with upstream R and upstream Y do?
Actually, let's restate our current dynamics
first.
[100:

Thu Nov  4 12:49:11 2021

   ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       R     R       Y     Y     R trailing edge / Y leading edge (up)
       Y     Y       G     G     Y trailing edge / G leading edge (up)
       G     B       G     B     G trailing edge / B leading edge (down)
       B     R       B     R     B trailing edge / R leading edge (down)

    SYMMETRIC STABILIZATION DYNAMICS
     CURME  ANYUP ANYDOWN ACTION
       R     !R            SWAP  R diffuse up
       G            !G     SWAP  G diffuse down
  [NYI B     G       R     SWAP  B diffuse center  ]
  [NYI Y     G       R     SWAP  Y diffuse center  ]

    SYMMETRY BREAKING DYNAMICS
     CURME  ANYNGB NEWME
       B     Y      Y    Break ties upward

:100]
[101:

Thu Nov  4 12:52:50 2021 So, G with uR and uY
should do what?

ATTRACTOR says nothing.

Oh I guess the key is the current case also has
all downstream G, so STABILIZATION says nothing.

So, a bigger point about the Y/B isolation is that
R & G should never be neighbors.  More BREAKING
rules maybe:

    SYMMETRY BREAKING DYNAMICS
     CURME  ANYNGB NEWME
       B     Y      Y    Break ties upward
       R     G      Y    Resolve inconsistencies up?

 :101]

:99]

:98]

:97]

:96]

:95]:94]
:93]
[102:

Thu Nov  4 13:20:55 2021 Upps, thought I had it
all, but looks like another deadlock here.

B with uR and dG, what should that do?

[103:

Thu Nov  4 13:24:29 2021 It's close to

     CURME  ALLUP ALLDOWN NEWME
       B     R       B     R     B trailing edge / R leading edge (down)

 except it's got down G
[104:

Thu Nov  4 13:28:41 2021 I guess another way to
look at it is the problem is a G with both uB and
uG.  So the ATTRACTOR G rule can't go since not
ALL uB.

Could we make a stabilization swap rule?

[105:

Thu Nov  4 13:30:42 2021 Have to think about it.
Time to move the flag.[106:

Thu Nov  4 14:53:14 2021 Moved.

:106]

:105]
:104]

:103]
:102]
[107:

Thu Nov  4 14:56:00 2021

   ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       R     R       Y     Y     R trailing edge / Y leading edge (up)
       Y     Y       G     G     Y trailing edge / G leading edge (up)
       G     B       G     B     G trailing edge / B leading edge (down)
       B     R       B     R     B trailing edge / R leading edge (down)

    SYMMETRIC STABILIZATION DYNAMICS
     CURME  ANYUP ANYDOWN ACTION
       R     !R            SWAP  R diffuse up
       Y     !Y            SWAP  Y diffuse up
       G            !G     SWAP  G diffuse down
       B            !B     SWAP  B diffuse down

    SYMMETRY BREAKING DYNAMICS
     CURME  ANYNGB NEWME
       B     Y      Y    Break ties upward
       R     G      Y    Break ties upward

[108:

Thu Nov  4 15:33:04 2021 Trying this.  Thinking
the extra STABILIZATION rules are going to be
destabilizing, but we'll see.[109:

Thu Nov  4 15:34:18 2021 Yeah, it's a mess. It
never gets past R and Y mixing it up. R is
supposed to be above Y; we don't really want to
say

     CURME  ANYUP ANYDOWN ACTION
       Y     !Y            SWAP  Y diffuse up

we want to say

     CURME  ANYUP ANYDOWN ACTION
       Y    !Y&!R          SWAP  Y diffuse up

but we don't have that. Just do two rules, for a
try anyway?

     CURME  ANYUP ANYDOWN ACTION
       Y     G             SWAP  Y diffuse up
       Y     B             SWAP  Y diffuse up
       B             R     SWAP  B diffuse down
       B             Y     SWAP  B diffuse down

:109]

:108]
:107]
[110:

Fri Nov  5 01:21:01 2021 OK so we're back to a
larger-scale deadlock, with R Y G in one corner of
an L2 site and R B G on the diagonal corner, and
neither is moving.  We need some kind of diffusion
that will, eventually, get the Y and B in sight of
each other..

[111:

Fri Nov  5 01:29:31 2021 Let's maybe say that if
nothing else fires, we try for these:

    DIFFUSION DYNAMICS
       ME  ANYUP ANYDOWN  ACTIONS
       B      R      G     u <- m, m <- d  [B diffuse up]
       Y      R      G     d <- m, m <- u  [Y diffuse down]

and.. see what happens.  Very unclear how ..
[112:

Fri Nov  5 01:36:39 2021 Actually wait. What about
considering slightly relaxed versions of the
attractor dynamics?  For example, the attractor
has

   ATTRACTOR DYNAMICS
     CURME  ALLUP ALLDOWN NEWME
       B     R       B     R     B trailing edge / R leading edge (down)

and one of the stuck B has 'half' of that -- ALLUP
R, and it has ANYDOWN B, but not ALLDOWN B.  So
it's 'close'.  What if that bein diffuses?

:112]

:111]

:110]
[113:

Fri Nov  5 01:41:12 2021 Or as another disgusting
hack, what if, as a last ditch rule we say

    CURME  ODDS   NEWME
      B    .01%     Y

calling it the 'random switch direction' rule.
Like Crazy Ivan or something.

The rules as we've set them up do not have
explicit 'wait' states -- where NEWME == CURME --
which means we can't distinguish 'meta stable
states' from 'uncovered states' in the transition
function.  If we knew we were in an uncovered
state..

A 'STABLE FIELD' rule like

  CURME   ALLNGB    NEWME
    X       X         X

would 'cover' lots of unchanging sites, so the
final uncovered rule could be more aggressive.


:113]
[114:

Fri Nov  5 02:50:19 2021 One question is whether
updateRGBSync should ever actually return true?
Well yeah, I guess so -- although RGBSync SEEMS
very standalone at the moment, eventually it needs
to get coupled in to larger computational goals,
and indeed we don't want to return false if those
goals should not depend on the rgbsync state.[115:

Fri Nov  5 10:32:26 2021 So my 'Crazy Ivan'
changeDirection(Color) method does break deadlocks
pretty well, it seems -- but it also CAUSES them,
sometimes, and also causes premature turnarounds
sometimes, so the root thinks a round trip has
completed but the tail knows nothing about it.

:115]

:114]
[116:

Sat Nov  6 23:30:38 2021 What about something like
this:

 CURME ALLUP  ANYDOWN   ACTION
   B     R       !B       u <- B; m <- !B

or I'm not sure how to write it, but: If

 - I'm B
 - all upstream are R, and
 - no downstream is B, and
 - some downstream is not B

then pick an upstream and make it B, and pick a
downstream and make us that.[118:

Sun Nov  7 00:51:24 2021 OK we've now tried that
in 'Bool blueUp(RGBSync & me)' and it too messes
up the attractor dynamics because that state
absolutely occurs naturally on the attractor.
[119:

Sun Nov  7 01:20:28 2021 You know, what about if
we just did symmetric interclocking between root
and tail?  For starters say just two bits U and D,
and the update rule for field sites is adopt the
majority in each direction:

 U = count(UPSTREAM,U,true) > count(UPSTREAM,U,false)
 D = count(DOWNSTREAM,D,true) > count(DOWNSTREAM,D,false)

maybe with ties going to no change?

So the idea is the U bit is well-founded against
(whatever is currently passing for) the root, and
the D bit is well-founded against the tail.

And then the interclocking special cases are:

 if root and U == D, U = !U    # mismatch
 if tail and D != U, D = !D    # match

so tail is endlessly trying to match root, and
root is endlessly trying to be different than
tail.

[120:

Sun Nov  7 01:28:44 2021 Probably say ties should
randomize rather than stand..  But doesn't this
make fundamental sense?  DOESN'T IT?

[121:

Sun Nov  7 01:30:42 2021 I guess there's a risk we
could end up with multiple cycles in flight at
once?  And then what stops the whole thing from
turning into hash?  If root and tail had some
extra damping that could be minimized but that's
extra state.

[122:

Sun Nov  7 01:35:04 2021 What about if we required
unanimity instead of majority?  With the claim
that it won't hard deadlock because of
well-foundedness?

 if (allNgb(UPSTREAM,U,true))       U = true;
 else if (allNgb(UPSTREAM,U,false)) U = false;
 // else U unchanged

 if (allNgb(DOWNSTREAM,D,true))       D = true;
 else if (allNgb(DOWNSTREAM,D,false)) D = false;
 // else D unchanged

[123:

Sun Nov  7 01:47:49 2021 Could I lay this on top
of RGBY or do I want to fork a whole new
RGBSync.ulam to try this?

R|G -> U == false
B|Y -> U == true
R|B -> D == false
G|Y -> D == true
[124:

Sun Nov  7 02:09:07 2021 Making SICSync.ulam
though I want a better name.. Do I want a 3D array
for SICNeighborhood counting?

  ByteCount[dir][u-or-d][t-or-f]

?  That's the general case, but really we only
care about u upstream and d downstream, right?

  ByteCount mUpCount, mUpVals[2];
  ByteCount mDownCount, mDownVals[2];

:124]
:123]
:122]

:121]

  :120]

:119]
:118]
[117:

Sat Nov  6 23:44:17 2021 So that's close to one of
the 'DIFFUSION DYNAMICS' rules from :111: above,
which it seems we never tried?

:117]
:116]
[125:

Sun Nov  7 03:19:08 2021 And for the record, once
again,

  SYMMETRIC INTERCLOCKING WORKS GREAT

-- this time for L2Plate sync -- and it's
FANTASTICALLY ROBUST AND UTTERLY BEAUTIFUL.

FOGG THAT ROCK-PAPER-SCISSORS STUFF

FOGG THAT KTN-SYNC-OVER-ASYNC STUFF

SYMMETRIC INTERCLOCKING FOR THE FOGGING WIN

:125]
[126:

Sun Nov  7 07:35:33 2021 Let's clean up a little
here and then survey the landscape looking ahead!
[127:

Sun Nov  7 07:37:21 2021 Let's have a better name
than SICSync OK?  What shall it be?

 - We had some thoughts about alternate names back
   when we first discovered/invented this, right?
   What were we thinking then?

[128:

Sun Nov  7 09:11:45 2021 Ahem.  Back from
drifting through the Dec 2017 development notes in
T2-12/low/pru/itcio/notes/201711120544-itcio-notes.txt

So:

 - Distributed NOT-gate (Found one paper with and
   an exact hit for that -- about quantum
   communication bounds).  But we need a
   distributed *self-connected* NOT-gate

 - Distributed Oscillator

[129:

Sun Nov  7 09:17:00 2021 Hmm is it maybe just

 - Ring Oscillator?

..but a ring oscillator only needs one line and
we're using two.  Actually no: A ring oscillator
does need two lines -- out and back -- to close
the ring.

And wikipedia tells us early on that a ring
oscillator can have both inverting and
non-inverting stages, so long as there's an odd
number of inverting stages.

So our thing is a ring oscillator with one
inverting stage (the mismatch stage currently in
the 'ROOT TICK' section).  ROOT TICK inverts via

  upstate = !downstate

while TAIL TOCK is non-inverting via

  downstate = upstate

and all the field sites amount to a pair of wires,
a 'downbound one' doing

  downstate = upstate

and and 'upbound one' doing

  upstate = downstate.

[130:

Sun Nov  7 09:25:25 2021 So all together we have

 - two long pieces of wire between ROOT and TAIL,

 - a loopback connection at TAIL, and

 - a single inverter at ROOT,

forming a RING OSCILLATOR

[131:

Sun Nov  7 09:29:51 2021 And, FINALLY, searching
for "DISTRIBUTED RING OSCILLATOR" finds relevant
papers, like

 - "Clock distribution using cooperative ring
   oscillators" (1997)

 - "Design of a 10GHz Clock Distribution Network
    Using Coupled Standing-Wave Oscillators"
    (2003)

 - "Analysis and Verification of Interconnected
   Rings as Clock Distribution Networks" (2004)

 - "A Distributed Synchronized Clocking Method"
   (2005)

 - "Distributed source-destination synchronization
   using inband clock distribution (2006)[133: Sun
   Nov  7 10:39:46 2021 This might be kind of
   fundamentally different, not sure.  :133]

[132:

Sun Nov  7 10:36:58 2021 So things like:

 - PDRO: Programmable Distributed Ring Oscillator

 - P2PDRO: Point-to-point Distributed Ring
   Oscillator

 - DROSS: DRO for Software Synchronization

 - DiRiOs: Distributed Ring Oscillator (slogan:
   "Are You DiRiOs?")

 - GDRO: General DRO

 - DROC: DRO Clock

[134:

Sun Nov  7 10:47:35 2021 So none of those really
grab me but I think we have to have DRO in there
somewhere.  It does seem that the
point-to-pointness of this design is pretty key.
Not sure of good compact ways to express that.
1D?

DRO1D - Distributed Ring Oscillator 1D?

[135:

Sun Nov  7 10:52:25 2021 Link? Endpoints?

DROLL - DRO Link Layer

DROPTP - DRO Point-To-Point

DROP2P - DRO Point-2-Point

SIDRO - Single Inverter DRO

DROSI - DRO - Single Inverter

But we want to get the linearization in there
too.  Yes there's only one inverter, but there's
really only one non-inverting gate in there too,
with the rest just being 'wire'

VCDRO - Virtual Circuit DRO

[136:

Sun Nov  7 10:59:45 2021 Virtual Circuit has some
potential since it kind of gets end-to-end flavor
in there, as well as 'circuit' obviously.

[137:

Sun Nov  7 11:01:46 2021 Still leaning to GDRO so
far I think.  For base class quark name
anyway.[138:

Sun Nov  7 14:55:54 2021 Renamed to GDRO.ulam and
cleaned up some.[139:

Sun Nov  7 15:02:20 2021 OK, so if we're to carry
additional information alongside the clock signal,
we need API to advance that information during
wire propagation.

Which maybe in fact means we want some API in the
iterator to merge across multiple
upstream/downstream sources..  I'd been thinking
we'd just sample randomly once we had clock
unanimity but I could pretty easily see wanting
other mappy-reducey options..

[140:

Sun Nov  7 15:08:09 2021 Although since we don't
have a tree here, but a set of overlapping
neighborhoods, it's a little harder to imagine how
we could, say, count instances using this
mechanism.  How would we ensure each site gets
counted once and only once?

We could do idempotent &= and |= stuff, but I
don't see how to count..

Could do shortest path stuff with min(parents)+1

Which could give us a centralized clue about we're
actually a full-sized L2 plate, if we wanted to
care.

:140]

:139]

:138]

:137]

:136]

:135]

:134]
:132]
:131]

:130]

:129]

:128]

:127]

:126]
[141:


Sun Nov  7 15:24:58 2021


   .  .  .   1  .  .   1  .  .   1  .  .   1  2  .   1  2  .

   .  .  .   .  .  .   2  .  .   2  .  .   2  .  .   2  3  .

   .  .  .   .  .  .   .  .  .   3  .  .   3  .  .   3  .  .


:141]
[142:

Sun Nov  7 15:32:21 2021 So, API for merging
associated state.  Do we do it on every iteration,
before we know whether we're going to have
unanimity?  Or do we rescan when we find out we
do?  Have to think update events are rare compared
to no-change; maybe rescan?
[143:

Sun Nov  7 15:48:56 2021 If we're saying rescan
maybe we can leave merging out of GDRO completely,
and just let the GDRO user do it on the update
hook.  We do need the update hook.

[144:

Sun Nov  7 16:32:34 2021 OK now we have

  /** return true to let wire propagate change into self */
  virtual Bool edge(Bool fromUp, Bool newState) { return true; }

in GDRO.

[145:

Sun Nov  7 16:56:27 2021 I wonder if we could
simplify the GDRO design a bit, somehow?
Particularly the iterator classid business -
that's kind of nasty (although it may be the
future). [146:

Sun Nov  7 16:57:42 2021 Could we not just pass an
iterator in, like

  Bool GDRO.updateGDRO(GDROIterator & itr) ..

?  And then tell caller to make whatever
GDROIterator subclass they want before calling us?
How can that be so bad?[147:

Sun Nov  7 16:59:49 2021 Seems like..  But, before
going after that, I have to say it feels like a
very long time since we committed any of this
stuff, and I'd like to commit some of this stuff,
since GDRO is kind of not sucking.

:147]

:146]

:145]
:144]

:143]
:142]
[148:

Mon Nov  8 01:05:28 2021 OK I'm trying to
consolidate all these L2Plate spike/demos here
into T2Demos/demos/L2Plate, and get some
confidence that we have the latest of all our
various hacks -- e.g., robustifications -- in one
place. 
[149:

Wed Nov 10 10:47:41 2021 OK, could I start
committing T2Demos/demos/L2Plate here?  I can't
swear it's got all the L2 robustifications but I'm
pretty clear it'll be the destination for them
all.
[150:

Wed Nov 10 10:49:59 2021 Actually, what's the
state of the T2Demos repo generally?  How much
Plate Related Material is already up there?

[151:

Wed Nov 10 10:53:36 2021 There's
T2Demos/demos/Plating committed, but its ./notes/
doesn't have any of our ./notes/ files:

202108201451-level-two-plate-notes.txt
202110180002-l2plate-robustness-notes.txt
202108270859-s11-rego-notes.txt

[152:

Wed Nov 10 12:21:12 2021 OK, a first
T2Demos/demos/L2Plate is committed and pushed.
[153:

Wed Nov 10 14:10:11 2021 Well, shutting down
nubiga to swap in the new workstation.  This is
going to mean disruption for some time..

:153]
:152]

:151]

:150]
:149]
:148]
[154:

Sun Nov 14 03:33:20 2021 OK, so we've moved nubiga
to its new home.

:154]
[155:

Sun Nov 14 03:38:20 2021 So let's get some kind of
plan for USING our next-level sync to move or grow
or SOMETHING.

[156:

Sun Nov 14 03:44:09 2021 What about a 'test plate'
that can be seeded anywhere, and it tries to heal
up, and if it heals up successfully and fully and
begins to clock, then the original source of the
seed can detect that and issue a second command
that causes the test plate to decay into something
useful or empty or whatever.

[157:

Sun Nov 14 04:29:52 2021 And it puffs into
nothingness if it touches anything?

:157]

:156]

:155]
[158:

Sun Nov 14 07:46:19 2021 So now I'm wondering:

 Given that RingO propagation depends on L2Plate
 coordinates, how can we ever change those
 coordinates, on any RingO phase, and still
 continue to propagate properly?

And saying that makes me think the implied answer
is 'obvious' from (traditional) KTN sync: We have,
somehow, to maintain old and new sets of state,
and when we check between local sites, we have to
decide whether to use the old or new state
depending on the relative RingO states between the
local sites.
[160:

Sun Nov 14 08:07:46 2021 So to keep RingO
propagation itself going, we could hack the
RingOIterator subclass to compensate for inflight
changes.  In principle anyway.

But at the moment, for example, the L2Plate
behave() looks like this:

  Void behave() {
    if (onceOnlyInit()) return;
    if (mustBlockOrDie()) return;
    if (checkGrowthAndHealing()) return;
    if (updateRingO()) return;
    if (checkLocalActions()) return;
  }

We can overlook onceOnlyInit() for now but how the
heck can we do mustBlockOrDie() without depending
on L2Plate coordinate comparisons?

[161:

Sun Nov 14 08:18:15 2021 The superscary
in-for-a-pound is we override positionOnPlate()
and sizeOfPlate() to .. what?  Return different
answers depending on who's asking?  We don't know
who's asking.

[162:

Sun Nov 14 08:21:04 2021 It's really all 'just'
Tecton dynamics, and Tecton global disruption, all
over again.

If we are EVER going to change, say, plate size,
(1) That change has to reach all plate sites
(2) Which literally cannot happen all at once
(3) So there will be EWs that can see both sizes

Which we handled in Tecton-land by passivating
whenever (3) might be true.  And we had the
problem that if the Tecton got destroyed, we had
no way to know how to recover -- no way to know
which size was the 'real' one, say.

But it seems like now we're heading toward a view
where we keep additional redundant state in the
(L2)Plate, so that when (3) occurs, we have a
chance to figure out what was going on.

"The size mismatches BECAUSE we're BLU and it's
RED and its RED DELTA says increment the size like
so, which precisely accounts for mismatch we see."

Or the like.

The point is, be able to self-stabilize even in
the presence of coordinate disruption. Be able to
self-stabilize back to an in-progress global
coordinate change, and then complete that change
plausible/successfully.

[163:

Sun Nov 14 08:36:44 2021 We could add new API like

 C2D RingOPlate.sizeOfPlate(RingOPlate& asSeenFrom) 
 C2D RingOPlate.positionOnPlate(RingOPlate& asSeenFrom) 

and those would have enough smarts to compensate
between different RingOState, using this (so far
hypothetical) RingODelta information.[165:

Sun Nov 14 08:44:38 2021 With the idea that RingO
self stabilization stuff would need to happen
early, and it would use this new API to help
figure out what's going on.  And if it detected
that non-RingO-aware code would see spurious
inconsistencies, it returns true to passivate the
rest of the event.

:165]

[164:

Sun Nov 14 08:41:02 2021 RingODelta sample:

8 bits == 2 bits for each of sX sY pX pY
00 no change
01 increment
10 decrement
11 empty

[166:

Sun Nov 14 09:36:19 2021 So what might this early
stabilization stuff look like?

  Void behave() {
    if (onceOnlyInit()) return;
    if (mustBlockOrDie()) return;
    if (checkGrowthAndHealing()) return;
    if (updateRingO()) return;
    if (checkLocalActions()) return;
  }

Seems like we might need to split mustBlockOrDie
up?  Well, let's just say

  Void behave() {
    if (onceOnlyInit()) return;
    if (updateRingO()) return;
    if (mustBlockOrDie()) return;
    if (checkGrowthAndHealing()) return;
    if (checkLocalActions()) return;
  }

What if we 'just' move updateRingO earlier?  [167:

Sun Nov 14 09:46:01 2021 Actually hey: Weren't we
going to redo to like

  Bool RingO.updateRingo(RingOIterator &) 

and get rid of the classid stuff?  That doesn't
appear to have happened in this code.
[168:

Sun Nov 14 09:54:19 2021 Yeah the discussion back
at :146: above.  Let's do that first right now.
[169:

Sun Nov 14 10:17:06 2021 OK, now there's no
mentions of classid in RingO.ulam.

Made RingOPlate in RingO.ulam and RingOL2Plate in
L2Plate.ulam to abstract away the RingOIterator;
we'll see how that goes.

:169]
:168]
:167]

:166]


:164]

:163]

:162]

:161]

:160]
[159:

Sun Nov 14 07:55:35 2021

 UP DOWN COLOR      
 F  F    BLUE      -> RED  (D)
 T  F    RED       -> YLW  (U) 
 T  T    YELLOW    -> GRN  (D)
 F  T    GREEN     -> BLU  (U)

ENTER RED:
  ROOT:  COMPUTE NEW STATE DELTA
  FIELD: COPY NEW STATE DELTA

:159]

:158]
[170:

Sun Nov 14 10:28:46 2021 OK, now what blows up if
we move updateRingO .. no, if we

 - Split mustBlockOrDie into mustBlock and
   mustDie.  

 - Move updateRing between mustDie and mustBlock



:170]
[171:

Sun Nov 14 10:33:09 2021 OK OK OK not clear how we
do this.  We can kill ourselves but we can't
propagate death bits without checking plate
relations.  So how do we split up mustBlockOrDie?

[172:

Sun Nov 14 10:54:13 2021 Could we use dynamic
priority to get a tecton-like effect but just by
examining the RingOState?  So we only commit plate
state changes when we're at an elevated priority,
so neighbors will bail?

Maybe.  Head hurts; big surprise.

Going around on all this yet again does make me
think about all the more-and-less general
techniques we have for composing dynamics.

    Plate coords -> Spatial hierarchy
    Passivation -> Execution order, temporal hierarchy
    Virtual function delegations

To some degree we can choose any of those for some
dynamics composition task, can mix and match among
them, but we have to sort out the interactions no
matter what we choose.

[173:

Sun Nov 14 11:18:13 2021 And there's also types of
dynamics:

   Homeostatic
   Sequential

Is that the main distinction?  Homeostatic says
(robustly) stay where we are, sequential says
(somehow) go to a different place/state.

And that's the/an inherent tension in developing
dynamics.
[174:

Sun Nov 14 12:44:03 2021 And the/a basic metalevel
move we're considering here is: Adding enough
redundancy that the intermediate stages of a
sequential act can be maintained homeostatically
as the sequence unfolds.

So an (always) obvious question is how much
redundancy do we want to add, to defend against
what kinds and amounts of damage?

 - Detect and repair single atom deletion during a
   sequence, possibly skipping or repeating a step
   but maintaining the wavefront dynamics.

 - Turn limited forms of individual atom
   corruption into single atom deletions?

:174]
   

:173]

:172]

:171]
[175:

Sun Nov 14 14:10:27 2021 How about adding some
checking using a fourth state?

RingODelta sample:

8 bits == 2 bits for each of sX sY pX pY
00 no change (even parity)
01 increment
11 decrement
10 no change (odd parity)

[176:

Sun Nov 14 17:03:02 2021 Seems like an enumeration
of possible state changes 'would be so much more
efficient'.  [177:

Mon Nov 15 02:10:15 2021 OK come on let's go.

 - Assign actions to RingO state changes

 - Make a RingO-named thing to hold a plate delta

 - Refactor for RingOPlateBase

 - Put RingO-themed plate delta in RingOPlateBase
[178:

Mon Nov 15 04:49:50 2021 Four stroke engine

UD    UD
00 -> 10 (enter RED) AIM        (ROOT TICK)
10 -> 11 (enter YLW) AIMED      (TAIL TICK)
11 -> 01 (enter GRN) FIRE       (ROOT TOCK)
01 -> 00 (enter BLU) FIRED      (TAIL TOCK)

:178]

:177]

:176]


:175]
[179:

Mon Nov 15 13:50:56 2021 OK, so we gave RingODemo an

   MyB2D mNewSize;

data member,

 - and we have RingODemo.rootTick(..) updating it
   at random when entering RED

 - and we have RingODemo.edge(..) propagating down
   mNewSize to everybody as they enter RED

So next steps were going to be something like:

 - do self.setSizeOfPlate(mNewSize) when entering
   GRN (or: exchange mNewSize and sizeOfPlate?)

 - make some kind of priority() override so that
   when sites that see GRN from YLW, they
   passivate, so the inconsistent sizeOfPlate
   doesn't bug them?

Still going to be sequencing issues at least,
there, because we haven't reordered the behave()
code to move the updateRingO stuff earlier -- we
haven't dealt with that at all.

[180:

Mon Nov 15 14:32:10 2021 Also, the existing
priority scheme is first-order only, right? In
this case we could want a second-order priority
scheme where we ask 'what is the priority of A
when seen from B?'[181:

Mon Nov 15 14:35:03 2021 Well but priority is
already 'kind of' second-order because we compare
another's priority to our own.

I guess the point is we'd ditch the whole idea of
numeric priority and just go with

  Bool Plate.priority(Plate& other) ; //< do we have priority over other?

[182:

Mon Nov 15 14:39:39 2021 But all that stuff is
just within-plate only.  (And just Plate-only, for
that matter.)

Maybe we want a separate notion of RingO priority?
That can be tied to Plate priority if desired but
isn't welded to it?

But but.. We're trying to keep RingO pretty clean,
and put the load on subclasses of RingOIterator.
Buuuut L2PlateRingOIterator, for example, is
comparing self.posititionOnL2Plate() vs
ngb.positionOnL2Plate() to decide if that site is
part of the iteration.

If we were trying to renumber L2 plates -- to let
it shift position by growth, for example -- then
the positionOnL2Plate would change when ngbs enter
GRN.

:182]

:181]

:180]

:179]
[183:

Tue Nov 16 13:48:18 2021 OK so here's the thing:
I'm getting increasingly conflicted about how or
if to get L2 plates moving, but if I am going to
take a serious run at it at all, then

  WE HAVE TO MAKE THE L2 SITE SPACING FLEXIBLE

So to that end I want to at least make some TODO:

[211: Wed Nov 17 04:58:04 2021
DONE :211] - Refresh standard Tecton so we can hand trigger
   one on a given L2 site. Get that working on a
   1x1 L2Plate

[216: Wed Nov 17 11:49:55 2021 3x3 but for starters:
DONE  :216] - Move to a 2x2 L2Plate and see what breaks when
   one L2 site is misaligned with the other three.

[217:
DONE :217] - Report those findings here

[219: Wed Nov 17 12:16:38 2021
DONE :219] - Make more to-do based on that report.

[218:

Wed Nov 17 12:03:24 2021 More TODO

[222: Wed Nov 17 12:37:27 2021 
DONE :222] - Review how L2 site decides to reseed.

[227: Wed Nov 17 15:24:09 2021
DONE :227] - Review how L2 neighborhood works

[235: Thu Nov 18 12:58:22 2021
DONE :235] - Propose mechanism(s) to allow variable distance
   between L2 sites, supporting

[240: DONE  :240]   - Don't reseed if there's any plausible
     neighbor there

[241: DONE just saying  :241]   - Support RingO propagation regardless of small
     spatial phase differences

[236: Thu Nov 18 12:58:28 2021
DONE :236] - Implement a mechanism

[237: Thu Nov 18 12:58:46 2021 
DONE :237] - Demonstrate L2 site movability

[238: Thu Nov 18 12:58:48 2021 
DONE :238] - Move an entire L2 plate, site by site, 'by
   hand'

 - Come make more to-do

:218]


GO GO GO NOW GO

:183]
[184:

Tue Nov 16 13:53:50 2021 Imported
demos/Plating/code/Tecton.ulam. Not building:

./Tecton.ulam:94:12: ERROR: (1) 'lineForwardOffsetEWC' has no defined function with 2 matching argument types: Unsigned(2), C2D(32), and cannot be called.
[185:

Tue Nov 16 13:55:28 2021 Which corresponds to:

      C2D lineForwardOffsetEWC() {
>>      return lineForwardOffsetEWC(mPlateDir, stride());
      }

and Tecton inherited (!?) from PlateUtils, which
has an implementation.

[186:

Tue Nov 16 13:57:33 2021 Our current
PlateUtils.ulam has that commented out.  We
absolutely don't remember why.  Let's put it back
in and see what pops.
[187:

Tue Nov 16 13:58:54 2021 OK next issue:

./Tecton.ulam:225:5: ERROR: Typedef 'Ephemeron' in class Tecton remains undefined.

[188:

Tue Nov 16 14:00:16 2021 OK imported
Ephemeron.ulam too; going again.
[189:

Tue Nov 16 14:03:27 2021 Built clean. Trying it.

[190: 

Tue Nov 16 14:04:30 2021 Runs, but we need some
kind of SeedTecton 
[191:

Tue Nov 16 14:17:18 2021 OK making (Q)SeedTecton
and wondering: How does a Tecton grow? What do we
actually need to seed it with?[192:

Tue Nov 16 14:20:05 2021 I guess we're looking to
get enough info to call Tecton's

  C2D initFromOpCmd(Bool doGrow, PlateDir inDir,C2D pos,C2D size,C2D str) 

method?
[193:

Tue Nov 16 14:49:41 2021 Calls to initFromOpCmd
are currently failing. First issue seems to be
it's expecting to be at an CCW corner, but I
wasn't counting on that.  I guess we could try
picking such a spot and see what happens next
though.. [194:

Tue Nov 16 14:51:28 2021 OK I picked a corner and
we got a successful return.  We're not doing
anything with it, though, yet.[195:

Tue Nov 16 14:52:29 2021 Well,
Plating/../B2DPacket.ulam just goes straight to
the ew with the returned coord.[196:

Tue Nov 16 15:33:52 2021 OK, the mapping isn't
quite what I was expecting but we can now trigger
moves with a 'Tm' SeedTectonMove.  Let's try some
more.  Can we grow?[197:

Tue Nov 16 15:48:34 2021 OK, we had to generalize
some stuff hardcoded to B2DPlate to use
B2DPlateBase instead, but now we can move and grow
(L1) Plates!  Can we claim a to-do?[198:

Tue Nov 16 15:49:33 2021 Well, we don't have a
mechanism to make a 1x1 L2Plate, do we?[199:

Tue Nov 16 15:56:50 2021 OK, it looks like L2Plate
is failing to passivate when Tecton is around?
Does that seem likely from the code?[200:

Tue Nov 16 16:01:28 2021 OK so we need to review
our concepts here. In particular, how is
conventional same-or-containing-plate priority
supposed to be sufficient to passivate around
Tecton if we can't safely determine
same-or-containing plate when a Tecton is foggen
moving through??
[201:

Tue Nov 16 16:06:31 2021 Is it completely
disgusting to consider passivating on priority
when overlap is detected??[202:

Tue Nov 16 16:26:15 2021 Well it might be
completely disgusting but that aside it doesn't
really work: Because we then get states where,
after the tecton has passed, a fixed-up plate site
sees itself as consistent with the Tecton, so that 
doesn't block it but then looks diagonally across
the tecton line to an unfixed-up plate site, and
triggers death.

[203:

Tue Nov 16 16:45:30 2021 But why doesn't it see
the (consistent) Tecton as needing a priority
comparison, and it should have passivated
there.. No?

Time to get cooking for dinner.[204:

Wed Nov 17 02:13:39 2021 OK back.

So I guess we're starting with a mystery.  Why
don't the Tecton passivate a consistent-with-them
L2Plate?[205:

Wed Nov 17 03:25:13 2021 OK we're actually dying
via mustBlockOrDie going to fatalInconsistency()
which then (in the case of L2Plate) does a Moore
neighborhood search, and apparently fails to
suspend its own checking when tecton's around.

[206:

Wed Nov 17 03:27:46 2021 With

  virtual Bool fatalInconsistency()

the return values are

 true to DIE of inconsistency, or
 false to CONTINUE, seeing nothing wrong

and we don't have an option to return passivate or
suspend or whatever. Even though it seems possible
that a fatalInconsistency check might well
determine something that would call for
passivation. 
[207:

Wed Nov 17 04:10:44 2021 Well, trying to interact
with Tecton solely on a priority() basis -- which
assumes that plate relations are reliable -- seems
like an awful finicky balancing act.  It feels
like we should move Tecton passivation to a
supra-plate level -- like the 'huge hammer'
iSeeTecton() method did in previous versions.

But, how did that not risk deadlock on
tecton-tecton interactions?  I guess Tecton didn't
call iSeeTecton()?
[208:

Wed Nov 17 04:22:41 2021 Yeah just reviewed
iSeeTecton in ../../Plating/code and it's totally
gross cuttenpasta in four different files with no
Plate-central involvement. Although in some of
those cases it gets called after mustBlockOrDie
rather than before, which makes me wonder why that
never ran into problems.. but whatever.

[209:

Wed Nov 17 04:24:49 2021 So.  One thing I think
about here is the 'as seen from' notion: What if
you could return different sizeOfPlate or
positionOnPlate as a function of who's asking?

But again that misses the point.  Tecton is
returning (locally) consistent sizes and positions
and that's not the problem. The problem is looking
across the tecton and comparing pre- and
post-Tecton conventional plate and seeing overlap
there, which is absolutely true.

Suppose we create a concept of Plate disruptor, or
something like that, as a generalization of
Tecton.  (Or maybe Tecton IS that concept.)  And
the idea is: Seeing any Plate disruptor means you
should passivate, unless you are a Plate disruptor
yourself, regardless of plate containment -- which
is what makes it different than priority.

Or what if we 

[210:

Wed Nov 17 04:52:35 2021 OK, the proximal problem
was that L2Plate.fatalInconsistency wasn't
considering cCONTAINED_BY_PLATE at all.

So now we have [1,1] L2Plate motion and growing
'working'.

Note the L1 plate inside doesn't automatically
grow when the surrounding L2Plate grows, so the L2
plate border gets thicker.

However, one can move the inner L1 plate around
using tectons within the L2Plate (!) except that
the current SeedTecton technology picks a plate to
consider at random, which means it might pick an
L2Plate rather than the L1 plate, and the seeding
fails in that case.  Or something like that.

Second sleep.  Actually let's claim our to-do
first! [212:

Wed Nov 17 04:58:34 2021 OK, claimed. But we
really think we need to rethink tecton priority?
We'll see.   Sleep now.[213:

Wed Nov 17 10:30:48 2021 So, what breaks on when
we move a piece of a 3x3 L2 plate?
[214:

Wed Nov 17 10:45:13 2021 OK, so the first test on
moving went like this:

 - 3x3 builds itself

 - trigger L2 site (2,0) to move east

 - Tecton starts moving L2 site east

 - Tecton reaches west side of L2 site (2,0),
   begins to erase itself

 - L2 site (1,0) decides to reseed site (2,0),
   putting on a new L2 border on top of a Tc and
   placing a MyElement in the position it used to
   be before moving (which is now inconsistent
   with the moved L1 sites).

 - Then a little later, one of the moved L2 border
   sites detected that new L2 border was
   inconsistent and set its death bits

 - And a little while after that, one of the moved
   L1 MyElements detected that the new MyElement
   was inconsistent and set its death bits

 - Then the new L2 border, as part of
   dying, discovered that most of the moved L1
   sites where contained by the new L2 border, so
   it set their death bits before erasing itself.

And everything went poof from there.

[215:

Wed Nov 17 11:36:24 2021 So of course it's
primarily the decision to reseed that's at fault.
And that's exactly what we were expecting to
find.

Seems like we could claim the rest of the (actual)
to-dos of :211: above..

So now we need more to-do..  [220:

Wed Nov 17 12:28:16 2021 OK so how to we decide to
reseed an L2 site?[221:

Wed Nov 17 12:30:25 2021 OK, it looks like:

 L2Plate.behave() ->
  L2Plate.checkLocalActions() ->
   L2Plate.checkFaces() ->
    L2PlateSequencer.update(MyPlex&) ->
     L2PlateSequencer.checkSeed(MyPlex&) ->
         if (plex[22] is L2Plate && !(plex[38] is L2Plate))
           return false;

So we're hardcoded to check SN 22 and 38, which is
(0,-3) and (0,-4) in the (normalized) Plex
mapping.

And if we pass that 'if' statement, we're pretty
much going to reseed, modulo unlikely edge cases.

Claiming reseed review

[223:

Wed Nov 17 12:38:42 2021 OK, how does the L2Plate
RingO neighborhood work?

[224:

Wed Nov 17 14:50:40 2021 Well, it considers SNs
21..24 and then 1..8 and that's it.

Looking ahead: What are we going to do about
upstream/downstream when an upstream L2 site is
shifted upwards/downwards in L1 position, and VV?

[225:

Wed Nov 17 14:56:02 2021 That's determined, I
think, by L2Plate.syncRelation(RingO & other),
which has one case for same L2 site, which we
don't care about here I think, and otherwise
compares the L2 coords, which we do care about.

So I think what the existing code is going to do
is say that everything on an upstream L2 site is
UPSTREAM, even if its L1 coord would put it
downstream of us, were we in the same L2 site.

[226:

Wed Nov 17 15:18:18 2021 But maybe that's okay?
Now I'm worried that a top-row L2 site shifted up
is going to look like a separate RingO root, isn't
is?

Maybe not if we search the full ew for L2 site
ngbs, and stick with the existing L2 over L1
dominance scheme.  Then a protruding L2 site could
look diagonally below itself (in L1 terms) -- like
to SN 30 at (-3,1) -- and still find something to
call 'upstream'.

I think I have to have faith that RingO
propagation will do something sensible even in
such cases.

But, claiming L2 ngb review.[228:

Wed Nov 17 15:38:27 2021 So, mechanisms.

[233: Thu Nov 18 12:57:54 2021
DONE :233] - Proposal for RingO ngb:
   (1) Search whole ew [THIS IS ONLY CHANGE]
   (2) same L2 site, max/min L1 coords
   (3) different L2 site, max/min L2 coords

[234:
DONE :234] - Proposal for L2PlateSequencer.checkSeed(Plex&):
   [229: Thu Nov 18 02:41:26 2021
   (1) Don't seed if plex[22] or plex[38] is inaccessible
   (2) Don't seed if plex[22] or plex[38] are non-empty
   (3) Search all of 'north hemisphere'
       (-4..4,-1..-4) for any L2 plate of matching
       l2size and appropriate l2pos; don't seed if
       found.
   (4) Otherwise seed at 22 & 38
   :229]
   
[230:

Thu Nov 18 03:13:54 2021 OK let's take a crack at this.
[231:

Thu Nov 18 09:23:02 2021 Well, slept instead, but
now have done the expanded L2PlateRingOIterator.
Seems noticeably slower but it seems to be
working.


:231]
:230]
:228]

:226]

:225]

:224]

:223]

:221]

:220]

:215]

:214]
:213]

:212]

:210]

:209]

:208]

:207]
:206]

:205]

:204]

:203]

:202]

:201]
:200]

:199]

:198]

:197]

:196]

:195]

:194]

:193]

:192]

:191]
:190]

:189]
:188]

:187]
:186]

:185]

:184]
[232:

Thu Nov 18 12:57:21 2021 OK, so some progress.
Let's claim stuff..[239:

Thu Nov 18 12:58:57 2021 OK, yow claimed like
everything.  Next stop is need to make more
to-do.

Committing this stuff.

:239]

:232]
[242:

Thu Nov 18 13:04:28 2021 First cut more TODO

 - Consider reseeding (just) L2 if (just) L1 is
   seen.  (Right now, MyElement is much more
   robust than L2Plate to write faults, and we end
   up with bare MyElement l1 plates blocking L2
   reseeding.)

 - Consider how to implement a second RingO for
   each L2 site independently.

 - Consider how a single L2 site could centralize
   L2 site border knowledge and select a plausible
   move direction.  

   - Is it by QStream12ing on the L2 site border?

   - Or is it by adding RingO payload?


:242]
[243:

Sun Nov 28 00:14:24 2021 Well, have been on other
stuff (mostly 'Robust Local Sync: Research
Notebook Video') for over a week, it appears.

But we're going to put some time in here and see
if we can get a second RingO circuit going in each
L2 site individually.

Obvious issue: Can't inherit from RingO twice.
[244:

Sun Nov 28 00:18:24 2021 Now, if we added

  virtual RingOState & getRingOState() ; //< Access relevant state

to the RingO API, and added like

  RingOState mRingOState;
  @Override
  virtual RingOState & getRingOState() { return mRingOState; }

in the subclasses, then we could keep multiple
RingOState data members around.

And how is it we associate the right mRingOState
with the right RingOIterator?  By having each
subclass pass the right RingOIterator to
updateRingO.

That makes sense.

So I guess this has to work?  But one more little
detail: How does some rando other class handle
accessing the correct RingO services 'from the
outside'?  Like:

  Atom & a = ew[1];
  if (a as RingO) {
    // Now what?
  }

Well, I guess the point is: Either the Rando knows
specifically what kind of RingO it's looking for
(e.g., Self), or the Rando has to be happy with
just getRingOState().

That's not so unreasonable, I think..

:244]

:243]
[245:

Sun Nov 28 00:33:22 2021 Are we clean here?  Need
a commit before we start this?

:245]
